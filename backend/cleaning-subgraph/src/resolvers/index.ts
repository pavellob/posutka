import type { Context } from '../context.js';
import { createGraphQLLogger } from '@repo/shared-logger';
// import { notificationClient } from '../services/notification-client.js'; // üî¥ –û–¢–ö–õ–Æ–ß–ï–ù–û - –∏—Å–ø–æ–ª—å–∑—É–µ–º Event Bus

const logger = createGraphQLLogger('cleaning-subgraph-resolvers');

export const resolvers = {
  Query: {
    // Unit preferred cleaners query
    unitPreferredCleaners: async (_: unknown, { unitId }: { unitId: string }, context: Context) => {
      const { prisma } = context;
      
      if (!prisma) {
        logger.error('‚ùå prisma is undefined in context!');
        throw new Error('Prisma client not available in context');
      }
      
      const preferences = await prisma.unitPreferredCleaner.findMany({
        where: { unitId },
        include: { cleaner: true },
        orderBy: { createdAt: 'desc' },
      });
      
      return preferences.map(pref => ({
        id: pref.id,
        cleaner: pref.cleaner,
        createdAt: pref.createdAt,
      }));
    },
    
    // Cleaner queries
    cleaner: (_: unknown, { id }: { id: string }, { dl }: Context) => 
      dl.getCleanerById(id),
    
    cleaners: (_: unknown, params: any, { dl }: Context) => 
      dl.listCleaners(params),
    
    // Cleaning template queries
    cleaningTemplate: (_: unknown, { id }: { id: string }, { dl }: Context) => 
      dl.getCleaningTemplateById(id),
    
    cleaningTemplates: (_: unknown, { unitId }: { unitId: string }, { dl }: Context) => 
      dl.getCleaningTemplatesByUnitId(unitId),
    
    // Cleaning queries
    cleaning: (_: unknown, { id }: { id: string }, { dl }: Context) => 
      dl.getCleaningById(id),
    
    cleaningByTask: (_: unknown, { taskId }: { taskId: string }, { dl }: Context) => 
      dl.getCleaningByTaskId(taskId),
    
    cleanings: (_: unknown, params: any, { dl }: Context) => 
      dl.listCleanings(params),
  },

  Mutation: {
    // Cleaner mutations
    createCleaner: async (_: unknown, { input }: { input: any }, { dl }: Context) => {
      logger.info('Creating cleaner', { input });
      return dl.createCleaner(input);
    },
    
    updateCleaner: async (_: unknown, { id, input }: { id: string; input: any }, { dl }: Context) => {
      logger.info('Updating cleaner', { id, input });
      return dl.updateCleaner(id, input);
    },
    
    deactivateCleaner: async (_: unknown, { id }: { id: string }, { dl }: Context) => {
      logger.info('Deactivating cleaner', { id });
      return dl.deactivateCleaner(id);
    },
    
    activateCleaner: async (_: unknown, { id }: { id: string }, { dl }: Context) => {
      logger.info('Activating cleaner', { id });
      return dl.activateCleaner(id);
    },
    
    // Cleaning template mutations
    createCleaningTemplate: async (_: unknown, { input }: { input: any }, { dl }: Context) => {
      logger.info('Creating cleaning template', { input });
      return dl.createCleaningTemplate(input);
    },
    
    updateCleaningTemplate: async (_: unknown, { id, input }: { id: string; input: any }, { dl }: Context) => {
      logger.info('Updating cleaning template', { id, input });
      return dl.updateCleaningTemplate(id, input);
    },
    
    deleteCleaningTemplate: async (_: unknown, { id }: { id: string }, { dl }: Context) => {
      logger.info('Deleting cleaning template', { id });
      return dl.deleteCleaningTemplate(id);
    },
    
    // Cleaning mutations
    scheduleCleaning: async (_: unknown, { input }: { input: any }, { dl, prisma }: Context) => {
      logger.info('Scheduling cleaning', { input });
      const cleaning = await dl.scheduleCleaning(input);
      
      const unit = await prisma.unit.findUnique({
        where: { id: cleaning.unitId },
        include: { property: true, preferredCleaners: { include: { cleaner: true } } }
      });
      
      if (!unit) {
        logger.warn('‚ùå Unit not found', { unitId: cleaning.unitId });
        return cleaning;
      }
      
      logger.info('‚úÖ Unit found', { unitId: unit.id, unitName: unit.name, preferredCleanersCount: unit.preferredCleaners.length });
      
      // üéØ –ù–û–í–ê–Ø –õ–û–ì–ò–ö–ê: –ü—É–±–ª–∏–∫—É–µ–º —Å–æ–±—ã—Ç–∏–µ –≤–º–µ—Å—Ç–æ –ø—Ä—è–º–æ–≥–æ –≤—ã–∑–æ–≤–∞
      try {
        const unitName = `${unit.property?.title || ''} - ${unit.name}`.trim();
        const targetUserIds: string[] = [];
        
        if (cleaning.cleanerId) {
          // –ï—Å–ª–∏ —É–±–æ—Ä—â–∏–∫ –Ω–∞–∑–Ω–∞—á–µ–Ω
          const cleaner = await prisma.cleaner.findUnique({
            where: { id: cleaning.cleanerId }
          });
          const targetUserId = cleaner?.userId || cleaner?.id;
          if (targetUserId) {
            targetUserIds.push(targetUserId);
          }
        } else {
          // –ï—Å–ª–∏ —É–±–æ—Ä—â–∏–∫ –ù–ï –Ω–∞–∑–Ω–∞—á–µ–Ω - —É–≤–µ–¥–æ–º–ª—è–µ–º –≤—Å–µ—Ö preferred cleaners
          for (const pref of unit.preferredCleaners) {
            const targetUserId = pref.cleaner.userId || pref.cleaner.id;
            if (targetUserId) {
              targetUserIds.push(targetUserId);
            }
          }
        }
        
        // –ü—É–±–ª–∏–∫—É–µ–º —Å–æ–±—ã—Ç–∏–µ –≤ Event Bus
        await prisma.event.create({
          data: {
            type: cleaning.cleanerId ? 'CLEANING_ASSIGNED' : 'CLEANING_SCHEDULED',
            sourceSubgraph: 'cleaning-subgraph',
            entityType: 'Cleaning',
            entityId: cleaning.id,
            orgId: cleaning.orgId || null,
            actorUserId: null, // TODO: –ø–æ–ª—É—á–∏—Ç—å –∏–∑ context
            targetUserIds,
            payload: {
              cleaningId: cleaning.id,
              unitId: cleaning.unitId,
              unitName,
              scheduledAt: cleaning.scheduledAt,
              cleanerId: cleaning.cleanerId || null,
              requiresLinenChange: cleaning.requiresLinenChange
            },
            status: 'PENDING'
          }
        });
        
        logger.info('‚úÖ Event published', { 
          cleaningId: cleaning.id,
          eventType: cleaning.cleanerId ? 'CLEANING_ASSIGNED' : 'CLEANING_SCHEDULED',
          targetUserIds
        });
      } catch (error: any) {
        logger.error('‚ùå Failed to publish event', { error: error.message });
        // –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π flow
      }
      
      // üî¥ –°–¢–ê–†–ê–Ø –õ–û–ì–ò–ö–ê - –û–¢–ö–õ–Æ–ß–ï–ù–ê (–∏—Å–ø–æ–ª—å–∑—É–µ–º Event Bus)
      /*
      if (cleaning.cleanerId) {
        try {
          logger.info('üîî Sending ASSIGNED notification to specific cleaner', { cleanerId: cleaning.cleanerId });
          
          const cleaner = await prisma.cleaner.findUnique({
            where: { id: cleaning.cleanerId },
            include: { cleanings: false }
          });
          
          if (!cleaner) {
            logger.warn('‚ùå Cleaner not found', { cleanerId: cleaning.cleanerId });
            return cleaning;
          }
          
          const targetUserId = cleaner.userId || cleaner.id;
          logger.info('üéØ Target userId determined', { targetUserId, cleanerUserId: cleaner.userId, cleanerId: cleaner.id });
        
        const settings = targetUserId 
          ? await prisma.userNotificationSettings.findUnique({
              where: { userId: targetUserId },
            }).catch((err) => {
              logger.error('‚ùå Error fetching notification settings', { error: err });
              return null;
            })
          : null;
        
        if (!settings) {
          logger.warn('‚ö†Ô∏è No notification settings found for user', { 
            targetUserId,
            hint: 'User needs to set up notification settings first. They can do this in /settings/notifications'
          });
          return cleaning;
        }
        
        logger.info('‚úÖ Notification settings found', { 
          userId: settings.userId,
          enabled: settings.enabled,
          telegramChatId: settings.telegramChatId ? '***' + settings.telegramChatId.slice(-4) : null,
          enabledChannels: settings.enabledChannels,
          subscribedEvents: settings.subscribedEvents
        });
        
        if (!settings.enabled) {
          logger.warn('‚ö†Ô∏è Notifications disabled for user', { targetUserId });
          return cleaning;
        }
        
        if (!settings.telegramChatId) {
          logger.warn('‚ö†Ô∏è No Telegram chat ID configured', { 
            targetUserId,
            hint: 'User needs to connect Telegram bot via /start command'
          });
          return cleaning;
        }
        
        if (!settings.enabledChannels.includes('TELEGRAM')) {
          logger.warn('‚ö†Ô∏è Telegram channel not enabled', { 
            targetUserId,
            enabledChannels: settings.enabledChannels 
          });
          return cleaning;
        }
        
        if (!settings.subscribedEvents.includes('CLEANING_ASSIGNED')) {
          logger.warn('‚ö†Ô∏è User not subscribed to CLEANING_ASSIGNED events', { 
            targetUserId,
            subscribedEvents: settings.subscribedEvents 
          });
          return cleaning;
        }
        
        logger.info('üì§ Sending notification...', { 
          cleaningId: cleaning.id,
          userId: targetUserId,
          telegramChatId: settings?.telegramChatId ? '***' + settings.telegramChatId.slice(-4) : 'none'
        });
        
        await notificationClient.notifyCleaningAssigned({
          userId: targetUserId,
          telegramChatId: settings?.telegramChatId,
          cleanerId: cleaning.cleanerId,
          cleaningId: cleaning.id,
          unitName: `${unit.property?.title || ''} - ${unit.name}`,
          scheduledAt: cleaning.scheduledAt,
          requiresLinenChange: cleaning.requiresLinenChange,
          orgId: cleaning.orgId,
        });
        
          logger.info('‚úÖ ASSIGNED notification sent successfully!', { cleaningId: cleaning.id });
        } catch (error) {
          logger.error('‚ùå Failed to send ASSIGNED notification:', error);
          // –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π flow
        }
      } else {
        // –£–±–æ—Ä—â–∏–∫ –ù–ï –Ω–∞–∑–Ω–∞—á–µ–Ω - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –í–°–ï–ú –ø—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–º —É–±–æ—Ä—â–∏–∫–∞–º
        logger.info('üîî No cleaner assigned, sending AVAILABLE notifications to preferred cleaners', { 
          cleaningId: cleaning.id,
          preferredCleanersCount: unit.preferredCleaners.length 
        });
        
        if (unit.preferredCleaners.length === 0) {
          logger.warn('‚ö†Ô∏è No preferred cleaners for this unit', { unitId: unit.id });
          return cleaning;
        }
        
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤—Å–µ–º –ø—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–º —É–±–æ—Ä—â–∏–∫–∞–º
        for (const preferredCleaner of unit.preferredCleaners) {
          try {
            const cleaner = preferredCleaner.cleaner;
            
            if (!cleaner.isActive) {
              logger.info('‚è≠Ô∏è Skipping inactive cleaner', { cleanerId: cleaner.id });
              continue;
            }
            
            const targetUserId = cleaner.userId || cleaner.id;
            const settings = await prisma.userNotificationSettings.findUnique({
              where: { userId: targetUserId },
            }).catch(() => null);
            
            if (!settings || !settings.enabled || !settings.telegramChatId) {
              logger.info('‚è≠Ô∏è Skipping cleaner without notification settings', { cleanerId: cleaner.id });
              continue;
            }
            
            await notificationClient.notifyCleaningAvailable({
              userId: targetUserId,
              telegramChatId: settings.telegramChatId,
              cleaningId: cleaning.id,
              unitName: `${unit.property?.title || ''} - ${unit.name}`,
              scheduledAt: cleaning.scheduledAt,
              requiresLinenChange: cleaning.requiresLinenChange,
              orgId: cleaning.orgId,
            });
            
            logger.info('‚úÖ AVAILABLE notification sent to preferred cleaner', { 
              cleanerId: cleaner.id,
              cleanerName: `${cleaner.firstName} ${cleaner.lastName}`
            });
          } catch (error) {
            logger.error('‚ùå Failed to send AVAILABLE notification to cleaner:', error);
            // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –æ—Å—Ç–∞–ª—å–Ω—ã–º
          }
        }
        
        logger.info('‚úÖ All AVAILABLE notifications sent', { 
          cleaningId: cleaning.id,
          sentTo: unit.preferredCleaners.length 
        });
      }
      */
      
      return cleaning;
    },
    
    startCleaning: async (_: unknown, { id }: { id: string }, { dl, prisma }: Context) => {
      logger.info('Starting cleaning', { id });
      const cleaning = await dl.startCleaning(id);
      
      // üî¥ –°–¢–ê–†–ê–Ø –õ–û–ì–ò–ö–ê - –û–¢–ö–õ–Æ–ß–ï–ù–ê (–∏—Å–ø–æ–ª—å–∑—É–µ–º Event Bus)
      /*
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —É–±–æ—Ä—â–∏–∫—É –æ –Ω–∞—á–∞–ª–µ
      try {
        if (!cleaning.cleanerId) {
          logger.warn('No cleaner assigned to send notification', { cleaningId: id });
          return cleaning;
        }

        const cleaner = await prisma.cleaner.findUnique({
          where: { id: cleaning.cleanerId }
        });
        
        if (!cleaner) {
          logger.warn('Cleaner not found', { cleanerId: cleaning.cleanerId });
          return cleaning;
        }
        
        const unit = await prisma.unit.findUnique({
          where: { id: cleaning.unitId },
          include: { property: true }
        });
        
        if (!unit) {
          logger.warn('Unit not found', { unitId: cleaning.unitId });
          return cleaning;
        }
        
        const targetUserId = cleaner.userId || cleaner.id;
        const settings = await prisma.userNotificationSettings.findUnique({
          where: { userId: targetUserId },
        }).catch(() => null);
        
        if (settings?.telegramChatId) {
          await notificationClient.notifyCleaningStarted({
            userId: targetUserId,
            telegramChatId: settings.telegramChatId,
            cleaningId: cleaning.id,
            unitName: `${unit.property?.title || ''} - ${unit.name}`,
            cleanerName: `${cleaner.firstName} ${cleaner.lastName}`,
          });
          
          logger.info('‚úÖ STARTED notification sent', { cleaningId: id });
        }
      } catch (error) {
        logger.error('Failed to send start notification:', error);
      }
      */
      
      return cleaning;
    },
    
    completeCleaning: async (_: unknown, { id, input }: { id: string; input: any }, { dl, prisma }: Context) => {
      logger.info('Completing cleaning', { id, input });
      const cleaning = await dl.completeCleaning(id, input);
      
      // üî¥ –°–¢–ê–†–ê–Ø –õ–û–ì–ò–ö–ê - –û–¢–ö–õ–Æ–ß–ï–ù–ê (–∏—Å–ø–æ–ª—å–∑—É–µ–º Event Bus)
      /*
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —É–±–æ—Ä—â–∏–∫—É –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏
      try {
        if (!cleaning.cleanerId) {
          logger.warn('No cleaner assigned to cleaning, skipping completion notification', { cleaningId: id });
          return cleaning;
        }
        
        const cleaner = await prisma.cleaner.findUnique({
          where: { id: cleaning.cleanerId }
        });
        
        const unit = await prisma.unit.findUnique({
          where: { id: cleaning.unitId },
          include: { property: true }
        });
        
        const targetUserId = cleaner?.userId || cleaner?.id;
        const settings = targetUserId 
          ? await prisma.userNotificationSettings.findUnique({
              where: { userId: targetUserId },
            }).catch(() => null)
          : null;
        
        if (cleaner && unit) {
          // –í—ã—á–∏—Å–ª—è–µ–º –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
          const duration = cleaning.startedAt && cleaning.completedAt
            ? Math.floor((new Date(cleaning.completedAt).getTime() - new Date(cleaning.startedAt).getTime()) / 60000)
            : undefined;
          
          await notificationClient.notifyCleaningCompleted({
            userId: targetUserId!,
            telegramChatId: settings?.telegramChatId || undefined,
            cleaningId: cleaning.id,
            unitName: `${unit.property?.title || ''} - ${unit.name}`,
            cleanerName: `${cleaner.firstName} ${cleaner.lastName}`,
            duration,
          });
        }
      } catch (error) {
        logger.error('Failed to send completion notification:', error);
      }
      */
      
      return cleaning;
    },
    
    assignCleaningToMe: async (_: unknown, { cleaningId }: { cleaningId: string }, { prisma }: Context) => {
      logger.info('üéØ Assigning cleaning to current user', { cleaningId });
      
      // TODO: –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ context/JWT
      // –°–µ–π—á–∞—Å –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤–æ–≥–æ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —É–±–æ—Ä—â–∏–∫–∞
      const currentCleaner = await prisma.cleaner.findFirst({
        where: { isActive: true }
      });
      
      if (!currentCleaner) {
        throw new Error('Cleaner not found');
      }
      
      // –û–±–Ω–æ–≤–ª—è–µ–º —É–±–æ—Ä–∫—É - –Ω–∞–∑–Ω–∞—á–∞–µ–º —É–±–æ—Ä—â–∏–∫–∞
      const cleaning = await prisma.cleaning.update({
        where: { id: cleaningId },
        data: {
          cleanerId: currentCleaner.id,
          status: 'SCHEDULED', // –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ
        },
      });
      
      logger.info('‚úÖ Cleaning assigned to cleaner', { 
        cleaningId, 
        cleanerId: currentCleaner.id,
        cleanerName: `${currentCleaner.firstName} ${currentCleaner.lastName}`
      });
      
      // üî¥ –°–¢–ê–†–ê–Ø –õ–û–ì–ò–ö–ê - –û–¢–ö–õ–Æ–ß–ï–ù–ê (–∏—Å–ø–æ–ª—å–∑—É–µ–º Event Bus)
      /*
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞—é—â–µ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
      try {
        const unit = await prisma.unit.findUnique({
          where: { id: cleaning.unitId },
          include: { property: true }
        });
        
        const targetUserId = currentCleaner.userId || currentCleaner.id;
        const settings = await prisma.userNotificationSettings.findUnique({
          where: { userId: targetUserId },
        }).catch(() => null);
        
        if (settings?.telegramChatId && unit) {
          await notificationClient.notifyCleaningAssigned({
            userId: targetUserId,
            telegramChatId: settings.telegramChatId,
            cleanerId: currentCleaner.id,
            cleaningId: cleaning.id,
            unitName: `${unit.property?.title || ''} - ${unit.name}`,
            scheduledAt: cleaning.scheduledAt.toISOString(),
            requiresLinenChange: cleaning.requiresLinenChange,
            orgId: cleaning.orgId,
          });
          
          logger.info('‚úÖ Assignment confirmation sent', { cleaningId });
        }
      } catch (error) {
        logger.error('Failed to send assignment confirmation:', error);
      }
      */
      
      return cleaning;
    },
    
    updateCleaningChecklist: async (_: unknown, { id, items }: { id: string; items: any[] }, { dl }: Context) => {
      logger.info('Updating cleaning checklist', { id, itemsCount: items.length });
      return dl.updateCleaningChecklist(id, items);
    },
    
    cancelCleaning: async (_: unknown, { id, reason }: { id: string; reason?: string }, { dl, prisma }: Context) => {
      logger.info('Cancelling cleaning', { id, reason });
      const cleaning = await dl.cancelCleaning(id, reason);
      
      // üî¥ –°–¢–ê–†–ê–Ø –õ–û–ì–ò–ö–ê - –û–¢–ö–õ–Æ–ß–ï–ù–ê (–∏—Å–ø–æ–ª—å–∑—É–µ–º Event Bus)
      /*
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—Ç–º–µ–Ω–µ
      try {
        if (!cleaning.cleanerId) {
          logger.warn('No cleaner assigned to cleaning, skipping cancellation notification', { cleaningId: id });
          return cleaning;
        }
        
        const cleaner = await prisma.cleaner.findUnique({
          where: { id: cleaning.cleanerId }
        });
        
        const unit = await prisma.unit.findUnique({
          where: { id: cleaning.unitId },
          include: { property: true }
        });
        
        const targetUserId = cleaner?.userId || cleaner?.id;
        const settings = targetUserId 
          ? await prisma.userNotificationSettings.findUnique({
              where: { userId: targetUserId },
            }).catch(() => null)
          : null;
        
        if (unit) {
          await notificationClient.notifyCleaningCancelled({
            userId: targetUserId!,
            telegramChatId: settings?.telegramChatId || undefined,
            cleaningId: cleaning.id,
            unitName: `${unit.property?.title || ''} - ${unit.name}`,
            reason,
          });
        }
      } catch (error) {
        logger.error('Failed to send cancellation notification:', error);
      }
      */
      
      return cleaning;
    },
    
    // Cleaning document mutations
    createPreCleaningDocument: async (_: unknown, { cleaningId, input }: { cleaningId: string; input: any }, { dl }: Context) => {
      logger.info('Creating pre-cleaning document', { cleaningId });
      return dl.createPreCleaningDocument(cleaningId, input);
    },
    
    createPostCleaningDocument: async (_: unknown, { cleaningId, input }: { cleaningId: string; input: any }, { dl }: Context) => {
      logger.info('Creating post-cleaning document', { cleaningId });
      return dl.createPostCleaningDocument(cleaningId, input);
    },
    
    addPhotoToDocument: async (_: unknown, { documentId, input }: { documentId: string; input: any }, { dl }: Context) => {
      logger.info('Adding photo to document', { documentId });
      return dl.addPhotoToDocument(documentId, input);
    },
    
    deletePhotoFromDocument: async (_: unknown, { photoId }: { photoId: string }, { dl }: Context) => {
      logger.info('Deleting photo from document', { photoId });
      return dl.deletePhotoFromDocument(photoId);
    },
    
    // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∏–≤—è–∑–∫–æ–π —É–±–æ—Ä—â–∏–∫–æ–≤ –∫ –∫–≤–∞—Ä—Ç–∏—Ä–∞–º
    addPreferredCleaner: async (_: unknown, { unitId, cleanerId }: { unitId: string; cleanerId: string }, context: Context) => {
      logger.info('Adding preferred cleaner to unit', { unitId, cleanerId });
      
      const { prisma } = context;
      
      if (!prisma) {
        logger.error('‚ùå prisma is undefined in context!', { 
          contextKeys: Object.keys(context),
          hasContext: !!context 
        });
        throw new Error('Prisma client not available in context');
      }
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å–≤—è–∑—å –µ—â–µ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
      const existing = await prisma.unitPreferredCleaner.findUnique({
        where: {
          unitId_cleanerId: {
            unitId,
            cleanerId,
          },
        },
      });
      
      if (existing) {
        logger.warn('Preferred cleaner already added', { unitId, cleanerId });
        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º unit –±–µ–∑ —Å–æ–∑–¥–∞–Ω–∏—è –¥—É–±–ª–∏–∫–∞—Ç–∞
        return prisma.unit.findUnique({ where: { id: unitId } });
      }
      
      // –°–æ–∑–¥–∞–µ–º —Å–≤—è–∑—å
      await prisma.unitPreferredCleaner.create({
        data: {
          unitId,
          cleanerId,
        },
      });
      
      logger.info('‚úÖ Preferred cleaner added', { unitId, cleanerId });
      
      // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π unit
      return prisma.unit.findUnique({
        where: { id: unitId },
        include: { preferredCleaners: { include: { cleaner: true } } },
      });
    },
    
    removePreferredCleaner: async (_: unknown, { unitId, cleanerId }: { unitId: string; cleanerId: string }, context: Context) => {
      logger.info('Removing preferred cleaner from unit', { unitId, cleanerId });
      
      const { prisma } = context;
      
      if (!prisma) {
        logger.error('‚ùå prisma is undefined in context!');
        throw new Error('Prisma client not available in context');
      }
      
      // –£–¥–∞–ª—è–µ–º —Å–≤—è–∑—å
      await prisma.unitPreferredCleaner.deleteMany({
        where: {
          unitId,
          cleanerId,
        },
      });
      
      logger.info('‚úÖ Preferred cleaner removed', { unitId, cleanerId });
      
      // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π unit
      return prisma.unit.findUnique({
        where: { id: unitId },
        include: { preferredCleaners: { include: { cleaner: true } } },
      });
    },
  },

  // Type resolvers
  Cleaner: {
    user: (parent: any, _: unknown, { identityDL }: Context) => {
      return { id: parent.userId };
    },
    org: (parent: any, _: unknown, { identityDL }: Context) => {
      return { id: parent.orgId };
    },
    preferredUnits: async (parent: any, _: unknown, { prisma }: Context) => {
      try {
        const preferences = await prisma.unitPreferredCleaner.findMany({
          where: { cleanerId: parent.id },
          include: { unit: true },
          orderBy: { createdAt: 'desc' },
        });
        
        return preferences.map(pref => ({
          id: pref.id,
          unit: pref.unit,
          createdAt: pref.createdAt,
        }));
      } catch (error) {
        logger.error('Error fetching preferredUnits', { cleanerId: parent.id, error });
        return []; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
      }
    },
    cleanings: async (parent: any, _: unknown, { dl }: Context) => {
      const result = await dl.listCleanings({
        cleanerId: parent.id,
        first: 100,
      });
      return result.edges.map((edge: any) => edge.node);
    },
  },

  CleaningTemplate: {
    unit: (parent: any, _: unknown, { inventoryDL }: Context) => {
      return { id: parent.unitId };
    },
  },

  Cleaning: {
    org: (parent: any, _: unknown, { identityDL }: Context) => {
      return { id: parent.orgId };
    },
    cleaner: (parent: any, _: unknown, { dl }: Context) => {
      if (!parent.cleanerId) return null;  // ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ null
      return dl.getCleanerById(parent.cleanerId);
    },
    unit: (parent: any, _: unknown, { inventoryDL }: Context) => {
      return { id: parent.unitId };
    },
    booking: (parent: any, _: unknown, { bookingsDL }: Context) => {
      if (!parent.bookingId) return null;
      return { id: parent.bookingId };
    },
    documents: async (parent: any, _: unknown, { prisma }: Context) => {
      // Get documents for this cleaning
      const documents = await prisma.cleaningDocument.findMany({
        where: { cleaningId: parent.id },
        include: { photos: true },
      });
      
      return documents.map((doc: any) => ({
        id: doc.id,
        cleaningId: doc.cleaningId,
        type: doc.type,
        notes: doc.notes,
        photos: doc.photos.map((photo: any) => ({
          id: photo.id,
          documentId: photo.documentId,
          url: photo.url,
          caption: photo.caption,
          order: photo.order,
          createdAt: photo.createdAt.toISOString(),
          updatedAt: photo.updatedAt.toISOString(),
        })),
        createdAt: doc.createdAt.toISOString(),
        updatedAt: doc.updatedAt.toISOString(),
      }));
    },
  },

  CleaningDocument: {
    cleaning: (parent: any, _: unknown, { dl }: Context) => {
      return dl.getCleaningById(parent.cleaningId);
    },
  },
};

