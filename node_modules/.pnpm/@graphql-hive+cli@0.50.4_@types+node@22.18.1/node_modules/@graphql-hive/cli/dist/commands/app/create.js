"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const zod_1 = require("zod");
const core_1 = require("@oclif/core");
const base_command_1 = tslib_1.__importDefault(require("../../base-command"));
const gql_1 = require("../../gql");
const graphql_1 = require("../../gql/graphql");
const config_1 = require("../../helpers/config");
const errors_1 = require("../../helpers/errors");
const TargetInput = tslib_1.__importStar(require("../../helpers/target-input"));
class AppCreate extends base_command_1.default {
    async run() {
        const { flags, args } = await this.parse(AppCreate);
        let endpoint, accessToken;
        try {
            endpoint = this.ensure({
                key: 'registry.endpoint',
                args: flags,
                defaultValue: config_1.graphqlEndpoint,
                env: 'HIVE_REGISTRY',
                description: AppCreate.flags['registry.endpoint'].description,
            });
        }
        catch (e) {
            throw new errors_1.MissingEndpointError();
        }
        try {
            accessToken = this.ensure({
                key: 'registry.accessToken',
                args: flags,
                env: 'HIVE_TOKEN',
                description: AppCreate.flags['registry.accessToken'].description,
            });
        }
        catch (e) {
            throw new errors_1.MissingRegistryTokenError();
        }
        let target = null;
        if (flags.target) {
            const result = TargetInput.parse(flags.target);
            if (result.type === 'error') {
                throw new errors_1.InvalidTargetError();
            }
            target = result.data;
        }
        const file = args.file;
        const contents = this.readJSON(file);
        const operations = JSON.parse(contents);
        const validationResult = ManifestModel.safeParse(operations);
        if (validationResult.success === false) {
            throw new errors_1.PersistedOperationsMalformedError(file);
        }
        const result = await this.registryApi(endpoint, accessToken).request({
            operation: CreateAppDeploymentMutation,
            variables: {
                input: {
                    appName: flags['name'],
                    appVersion: flags['version'],
                    target,
                },
            },
        });
        if (result.createAppDeployment.error) {
            throw new errors_1.APIError(result.createAppDeployment.error.message);
        }
        if (!result.createAppDeployment.ok) {
            throw new errors_1.APIError(`Create App failed without providing a reason.`);
        }
        if (result.createAppDeployment.ok.createdAppDeployment.status !== graphql_1.AppDeploymentStatus.Pending) {
            this.log(`App deployment "${flags['name']}@${flags['version']}" is "${result.createAppDeployment.ok.createdAppDeployment.status}". Skip uploading documents...`);
            return;
        }
        let buffer = [];
        const flush = async (force = false) => {
            if (buffer.length >= 100 || force) {
                const result = await this.registryApi(endpoint, accessToken).request({
                    operation: AddDocumentsToAppDeploymentMutation,
                    variables: {
                        input: {
                            target,
                            appName: flags['name'],
                            appVersion: flags['version'],
                            documents: buffer,
                        },
                    },
                });
                if (result.addDocumentsToAppDeployment.error) {
                    if (result.addDocumentsToAppDeployment.error.details) {
                        const affectedOperation = buffer.at(result.addDocumentsToAppDeployment.error.details.index);
                        const maxCharacters = 40;
                        if (affectedOperation) {
                            const truncatedBody = (affectedOperation.body.length > maxCharacters - 3
                                ? affectedOperation.body.substring(0, maxCharacters) + '...'
                                : affectedOperation.body).replace(/\n/g, '\\n');
                            this.logWarning(`Failed uploading document: ${result.addDocumentsToAppDeployment.error.details.message}` +
                                `\nOperation hash: ${affectedOperation === null || affectedOperation === void 0 ? void 0 : affectedOperation.hash}` +
                                `\nOperation body: ${truncatedBody}`);
                        }
                    }
                    throw new errors_1.APIError(result.addDocumentsToAppDeployment.error.message);
                }
                buffer = [];
            }
        };
        let counter = 0;
        for (const [hash, body] of Object.entries(validationResult.data)) {
            buffer.push({ hash, body });
            await flush();
            counter++;
        }
        await flush(true);
        this.log(`\nApp deployment "${flags['name']}@${flags['version']}" (${counter} operations) created.\nActive it with the "hive app:publish" command.`);
    }
}
AppCreate.description = 'create an app deployment';
AppCreate.flags = {
    'registry.endpoint': core_1.Flags.string({
        description: 'registry endpoint',
    }),
    'registry.accessToken': core_1.Flags.string({
        description: 'registry access token',
    }),
    name: core_1.Flags.string({
        description: 'app name',
        required: true,
    }),
    version: core_1.Flags.string({
        description: 'app version',
        required: true,
    }),
    target: core_1.Flags.string({
        description: 'The target in which the app deployment will be created.' +
            ' This can either be a slug following the format "$organizationSlug/$projectSlug/$targetSlug" (e.g "the-guild/graphql-hive/staging")' +
            ' or an UUID (e.g. "a0f4c605-6541-4350-8cfe-b31f21a4bf80").',
    }),
};
AppCreate.args = {
    file: core_1.Args.string({
        name: 'file',
        required: true,
        description: 'Path to the persisted operations mapping.',
        hidden: false,
    }),
};
exports.default = AppCreate;
const ManifestModel = zod_1.z.record(zod_1.z.string());
const CreateAppDeploymentMutation = (0, gql_1.graphql)(/* GraphQL */ `
  mutation CreateAppDeployment($input: CreateAppDeploymentInput!) {
    createAppDeployment(input: $input) {
      ok {
        createdAppDeployment {
          id
          name
          version
          status
        }
      }
      error {
        message
      }
    }
  }
`);
const AddDocumentsToAppDeploymentMutation = (0, gql_1.graphql)(/* GraphQL */ `
  mutation AddDocumentsToAppDeployment($input: AddDocumentsToAppDeploymentInput!) {
    addDocumentsToAppDeployment(input: $input) {
      ok {
        appDeployment {
          id
          name
          version
          status
        }
      }
      error {
        message
        details {
          index
          message
          __typename
        }
      }
    }
  }
`);
//# sourceMappingURL=create.js.map