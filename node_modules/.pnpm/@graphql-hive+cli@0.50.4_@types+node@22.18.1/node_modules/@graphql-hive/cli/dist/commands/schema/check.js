"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const node_fs_1 = tslib_1.__importDefault(require("node:fs"));
const core_1 = require("@oclif/core");
const base_command_1 = tslib_1.__importDefault(require("../../base-command"));
const gql_1 = require("../../gql");
const config_1 = require("../../helpers/config");
const errors_1 = require("../../helpers/errors");
const git_1 = require("../../helpers/git");
const schema_1 = require("../../helpers/schema");
const TargetInput = tslib_1.__importStar(require("../../helpers/target-input"));
const schemaCheckMutation = (0, gql_1.graphql)(/* GraphQL */ `
  mutation schemaCheck($input: SchemaCheckInput!) {
    schemaCheck(input: $input) {
      __typename
      ... on SchemaCheckSuccess {
        valid
        initial
        warnings {
          nodes {
            message
            source
            line
            column
          }
          total
        }
        changes {
          edges {
            __typename
          }
          ...RenderChanges_schemaChanges
        }
        schemaCheck {
          webUrl
        }
      }
      ... on SchemaCheckError {
        valid
        changes {
          edges {
            __typename
          }
          ...RenderChanges_schemaChanges
        }
        warnings {
          nodes {
            message
            source
            line
            column
          }
          total
        }
        errors {
          ...RenderErrors_SchemaErrorConnectionFragment
        }
        schemaCheck {
          webUrl
        }
      }
      ... on GitHubSchemaCheckSuccess {
        message
      }
      ... on GitHubSchemaCheckError {
        message
      }
    }
  }
`);
class SchemaCheck extends base_command_1.default {
    async run() {
        var _a, _b, _c;
        try {
            const { flags, args } = await this.parse(SchemaCheck);
            await this.require(flags);
            let target = null;
            if (flags.target) {
                const result = TargetInput.parse(flags.target);
                if (result.type === 'error') {
                    throw new errors_1.InvalidTargetError();
                }
                target = result.data;
            }
            const service = flags.service;
            const forceSafe = flags.forceSafe;
            const usesGitHubApp = flags.github === true;
            let endpoint, accessToken;
            try {
                endpoint = this.ensure({
                    key: 'registry.endpoint',
                    args: flags,
                    legacyFlagName: 'registry',
                    defaultValue: config_1.graphqlEndpoint,
                    env: 'HIVE_REGISTRY',
                    description: SchemaCheck.flags['registry.endpoint'].description,
                });
            }
            catch (e) {
                throw new errors_1.MissingEndpointError();
            }
            const file = args.file;
            try {
                accessToken = this.ensure({
                    key: 'registry.accessToken',
                    args: flags,
                    legacyFlagName: 'token',
                    env: 'HIVE_TOKEN',
                    description: SchemaCheck.flags['registry.accessToken'].description,
                });
            }
            catch (e) {
                throw new errors_1.MissingRegistryTokenError();
            }
            const sdl = await (0, schema_1.loadSchema)(file).catch(e => {
                throw new errors_1.SchemaFileNotFoundError(file, e);
            });
            const git = await (0, git_1.gitInfo)(() => {
                // noop
            });
            const commit = flags.commit || (git === null || git === void 0 ? void 0 : git.commit);
            const author = flags.author || (git === null || git === void 0 ? void 0 : git.author);
            if (typeof sdl !== 'string' || sdl.length === 0) {
                throw new errors_1.SchemaFileEmptyError(file);
            }
            let github = null;
            if (usesGitHubApp) {
                if (!commit) {
                    throw new errors_1.CommitRequiredError();
                }
                if (!git.repository) {
                    throw new errors_1.GithubRepositoryRequiredError();
                }
                if (!git.pullRequestNumber) {
                    this.warn("Could not resolve pull request number. Are you running this command on a 'pull_request' event?\n" +
                        'See https://the-guild.dev/graphql/hive/docs/other-integrations/ci-cd#github-workflow-for-ci');
                }
                github = {
                    commit: commit,
                    repository: git.repository,
                    pullRequestNumber: git.pullRequestNumber,
                };
            }
            const result = await this.registryApi(endpoint, accessToken).request({
                operation: schemaCheckMutation,
                variables: {
                    input: {
                        service,
                        sdl: (0, schema_1.minifySchema)(sdl),
                        github,
                        meta: !!commit && !!author
                            ? {
                                commit,
                                author,
                            }
                            : null,
                        contextId: (_a = flags.contextId) !== null && _a !== void 0 ? _a : undefined,
                        target,
                        url: flags.url,
                    },
                },
            });
            if (flags.experimentalJsonFile) {
                node_fs_1.default.writeFileSync(flags.experimentalJsonFile, JSON.stringify(result, null, 2));
            }
            if (result.schemaCheck.__typename === 'SchemaCheckSuccess') {
                const changes = result.schemaCheck.changes;
                if (result.schemaCheck.initial) {
                    this.logSuccess('Schema registry is empty, nothing to compare your schema with.');
                }
                else if (!(changes === null || changes === void 0 ? void 0 : changes.edges.length)) {
                    this.logSuccess('No changes');
                }
                else {
                    this.log((0, schema_1.renderChanges)(changes));
                }
                const warnings = result.schemaCheck.warnings;
                if (warnings === null || warnings === void 0 ? void 0 : warnings.total) {
                    this.log((0, schema_1.renderWarnings)(warnings));
                }
                if ((_b = result.schemaCheck.schemaCheck) === null || _b === void 0 ? void 0 : _b.webUrl) {
                    this.log(`View full report:\n${result.schemaCheck.schemaCheck.webUrl}`);
                }
            }
            else if (result.schemaCheck.__typename === 'SchemaCheckError') {
                const changes = result.schemaCheck.changes;
                const errors = result.schemaCheck.errors;
                const warnings = result.schemaCheck.warnings;
                this.log((0, schema_1.renderErrors)(errors));
                if (warnings === null || warnings === void 0 ? void 0 : warnings.total) {
                    this.log((0, schema_1.renderWarnings)(warnings));
                }
                if (changes === null || changes === void 0 ? void 0 : changes.edges.length) {
                    this.log((0, schema_1.renderChanges)(changes));
                }
                if ((_c = result.schemaCheck.schemaCheck) === null || _c === void 0 ? void 0 : _c.webUrl) {
                    this.log(`View full report:\n${result.schemaCheck.schemaCheck.webUrl}`);
                }
                this.log('');
                if (forceSafe) {
                    this.logSuccess('Breaking changes were expected (forced)');
                }
                else {
                    this.exit(1);
                }
            }
            else if (result.schemaCheck.__typename === 'GitHubSchemaCheckSuccess') {
                this.logSuccess(result.schemaCheck.message);
            }
            else {
                throw new errors_1.APIError(result.schemaCheck.message);
            }
        }
        catch (error) {
            if (error instanceof core_1.Errors.CLIError) {
                throw error;
            }
            else {
                this.logFailure('Failed to check schema');
                throw new errors_1.UnexpectedError(error);
            }
        }
    }
}
SchemaCheck.description = 'checks schema';
SchemaCheck.flags = {
    service: core_1.Flags.string({
        description: 'service name (only for distributed schemas)',
    }),
    'registry.endpoint': core_1.Flags.string({
        description: 'registry endpoint',
    }),
    /** @deprecated */
    registry: core_1.Flags.string({
        description: 'registry address',
        deprecated: {
            message: 'use --registry.endpoint instead',
            version: '0.21.0',
        },
    }),
    'registry.accessToken': core_1.Flags.string({
        description: 'registry access token',
    }),
    /** @deprecated */
    token: core_1.Flags.string({
        description: 'api token',
        deprecated: {
            message: 'use --registry.accessToken instead',
            version: '0.21.0',
        },
    }),
    experimentalJsonFile: core_1.Flags.string({
        name: 'experimental-json-file',
        description: "File path to output a JSON file containing the command's result. Useful for e.g. CI scripting with `jq`.",
    }),
    forceSafe: core_1.Flags.boolean({
        description: 'mark the check as safe, breaking changes are expected',
    }),
    github: core_1.Flags.boolean({
        description: 'Connect with GitHub Application',
        default: false,
    }),
    require: core_1.Flags.string({
        description: 'Loads specific require.extensions before running the codegen and reading the configuration',
        default: [],
        multiple: true,
    }),
    author: core_1.Flags.string({
        description: 'Author of the change',
    }),
    commit: core_1.Flags.string({
        description: 'Associated commit sha',
    }),
    contextId: core_1.Flags.string({
        description: 'Context ID for grouping the schema check.',
    }),
    target: core_1.Flags.string({
        description: 'The target against which to check the schema (slug or ID).' +
            ' This can either be a slug following the format "$organizationSlug/$projectSlug/$targetSlug" (e.g "the-guild/graphql-hive/staging")' +
            ' or an UUID (e.g. "a0f4c605-6541-4350-8cfe-b31f21a4bf80").',
    }),
    url: core_1.Flags.string({
        description: 'If checking a service, then you can optionally provide the service URL to see the difference in the supergraph during the check.',
    }),
};
SchemaCheck.args = {
    file: core_1.Args.string({
        name: 'file',
        required: true,
        description: 'Path to the schema file(s)',
        hidden: false,
    }),
};
exports.default = SchemaCheck;
//# sourceMappingURL=check.js.map