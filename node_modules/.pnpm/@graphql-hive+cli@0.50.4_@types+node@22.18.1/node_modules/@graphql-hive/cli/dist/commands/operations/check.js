"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const graphql_1 = require("graphql");
const core_1 = require("@graphql-inspector/core");
const core_2 = require("@oclif/core");
const base_command_1 = tslib_1.__importDefault(require("../../base-command"));
const gql_1 = require("../../gql");
const config_1 = require("../../helpers/config");
const errors_1 = require("../../helpers/errors");
const operations_1 = require("../../helpers/operations");
const TargetInput = tslib_1.__importStar(require("../../helpers/target-input"));
const texture_1 = require("../../helpers/texture/texture");
const fetchLatestVersionQuery = (0, gql_1.graphql)(/* GraphQL */ `
  query fetchLatestVersion($target: TargetReferenceInput) {
    latestValidVersion(target: $target) {
      sdl
    }
  }
`);
class OperationsCheck extends base_command_1.default {
    async run() {
        var _a;
        try {
            const { flags, args } = await this.parse(OperationsCheck);
            await this.require(flags);
            let accessToken, endpoint;
            try {
                endpoint = this.ensure({
                    key: 'registry.endpoint',
                    args: flags,
                    legacyFlagName: 'registry',
                    defaultValue: config_1.graphqlEndpoint,
                    env: 'HIVE_REGISTRY',
                    description: OperationsCheck.flags['registry.endpoint'].description,
                });
            }
            catch (e) {
                throw new errors_1.MissingEndpointError();
            }
            try {
                accessToken = this.ensure({
                    key: 'registry.accessToken',
                    args: flags,
                    legacyFlagName: 'token',
                    env: 'HIVE_TOKEN',
                    description: OperationsCheck.flags['registry.accessToken'].description,
                });
            }
            catch (e) {
                throw new errors_1.MissingRegistryTokenError();
            }
            let target = null;
            if (flags.target) {
                const result = TargetInput.parse(flags.target);
                if (result.type === 'error') {
                    throw new errors_1.InvalidTargetError();
                }
                target = result.data;
            }
            const graphqlTag = flags.graphqlTag;
            const globalGraphqlTag = flags.globalGraphqlTag;
            const file = args.file;
            const operations = await (0, operations_1.loadOperations)(file, {
                normalize: false,
                pluckModules: graphqlTag === null || graphqlTag === void 0 ? void 0 : graphqlTag.map(tag => {
                    const [name, identifier] = tag.split(':');
                    return {
                        name,
                        identifier,
                    };
                }),
                pluckGlobalGqlIdentifierName: globalGraphqlTag,
            });
            if (operations.length === 0) {
                this.logInfo('No operations found');
                this.exit(0);
                return;
            }
            const result = await this.registryApi(endpoint, accessToken).request({
                operation: fetchLatestVersionQuery,
                variables: { target },
            });
            const sdl = (_a = result.latestValidVersion) === null || _a === void 0 ? void 0 : _a.sdl;
            if (!sdl) {
                throw new errors_1.SchemaNotFoundError();
            }
            const schema = (0, graphql_1.buildSchema)(sdl, {
                assumeValidSDL: true,
                assumeValid: true,
            });
            if (!flags.apolloClient) {
                const detectedApolloDirectives = operations.some(s => s.content.includes('@client') || s.content.includes('@connection'));
                if (detectedApolloDirectives) {
                    this.warn('Apollo Client specific directives detected (@client, @connection). Please use the --apolloClient flag to enable support.');
                }
            }
            const invalidOperations = (0, core_1.validate)(schema, operations.map(s => new graphql_1.Source(s.content, s.location)), {
                apollo: flags.apolloClient === true,
            });
            const operationsWithErrors = invalidOperations.filter(o => o.errors.length > 0);
            if (operationsWithErrors.length === 0) {
                this.logSuccess(`All operations are valid (${operations.length})`);
                this.exit(0);
                return;
            }
            this.log(texture_1.Texture.header('Summary'));
            this.log([
                `Total: ${operations.length}`,
                `Invalid: ${operationsWithErrors.length} (${Math.floor((operationsWithErrors.length / operations.length) * 100)}%)`,
                '',
            ].join('\n'));
            this.log(texture_1.Texture.header('Details'));
            throw new errors_1.InvalidDocumentsError(operationsWithErrors);
        }
        catch (error) {
            if (error instanceof core_2.Errors.CLIError) {
                throw error;
            }
            else {
                this.logFailure('Failed to validate operations');
                throw new errors_1.UnexpectedError(error);
            }
        }
    }
}
OperationsCheck.description = 'checks operations against a published schema';
OperationsCheck.flags = {
    'registry.endpoint': core_2.Flags.string({
        description: 'registry endpoint',
    }),
    /** @deprecated */
    registry: core_2.Flags.string({
        description: 'registry address',
        deprecated: {
            message: 'use --registry.endpoint instead',
            version: '0.21.0',
        },
    }),
    'registry.accessToken': core_2.Flags.string({
        description: 'registry access token',
    }),
    /** @deprecated */
    token: core_2.Flags.string({
        description: 'api token',
        deprecated: {
            message: 'use --registry.accessToken instead',
            version: '0.21.0',
        },
    }),
    require: core_2.Flags.string({
        description: 'Loads specific require.extensions before running the command',
        default: [],
        multiple: true,
    }),
    graphqlTag: core_2.Flags.string({
        description: [
            'Identify template literals containing GraphQL queries in JavaScript/TypeScript code. Supports multiple values.',
            'Examples:',
            '  --graphqlTag graphql-tag (Equivalent to: import gqlTagFunction from "graphql-tag")',
            '  --graphqlTag graphql:react-relay (Equivalent to: import { graphql } from "react-relay")',
        ].join('\n'),
        multiple: true,
    }),
    globalGraphqlTag: core_2.Flags.string({
        description: [
            'Allows to use a global identifier instead of a module import. Similar to --graphqlTag.',
            'Examples:',
            '  --globalGraphqlTag gql (Supports: export const meQuery = gql`{ me { id } }`)',
            '  --globalGraphqlTag graphql (Supports: export const meQuery = graphql`{ me { id } }`)',
        ].join('\n'),
        multiple: true,
    }),
    apolloClient: core_2.Flags.boolean({
        description: 'Supports Apollo Client specific directives',
        default: false,
    }),
    target: core_2.Flags.string({
        description: 'The target to which to check agains (slug or ID).' +
            ' This can either be a slug following the format "$organizationSlug/$projectSlug/$targetSlug" (e.g "the-guild/graphql-hive/staging")' +
            ' or an UUID (e.g. "a0f4c605-6541-4350-8cfe-b31f21a4bf80").',
    }),
};
OperationsCheck.args = {
    file: core_2.Args.string({
        name: 'file',
        required: true,
        description: 'Glob pattern to find the operations',
        hidden: false,
    }),
};
exports.default = OperationsCheck;
//# sourceMappingURL=check.js.map