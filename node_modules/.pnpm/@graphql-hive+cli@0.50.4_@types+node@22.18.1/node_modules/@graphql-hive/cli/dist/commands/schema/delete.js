"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const base_command_1 = tslib_1.__importDefault(require("../../base-command"));
const gql_1 = require("../../gql");
const config_1 = require("../../helpers/config");
const errors_1 = require("../../helpers/errors");
const schema_1 = require("../../helpers/schema");
const TargetInput = tslib_1.__importStar(require("../../helpers/target-input"));
const schemaDeleteMutation = (0, gql_1.graphql)(/* GraphQL */ `
  mutation schemaDelete($input: SchemaDeleteInput!) {
    schemaDelete(input: $input) {
      __typename
      ... on SchemaDeleteSuccess {
        valid
        errors {
          ...RenderErrors_SchemaErrorConnectionFragment
        }
      }
      ... on SchemaDeleteError {
        valid
        errors {
          ...RenderErrors_SchemaErrorConnectionFragment
        }
      }
    }
  }
`);
class SchemaDelete extends base_command_1.default {
    async run() {
        try {
            const { flags, args } = await this.parse(SchemaDelete);
            const service = args.service;
            if (!flags.confirm) {
                const confirmed = await core_1.ux.confirm(`Are you sure you want to delete "${service}" from the registry? (y/n)`);
                if (!confirmed) {
                    this.logInfo('Aborting');
                    this.exit(0);
                }
            }
            let accessToken, endpoint;
            try {
                endpoint = this.ensure({
                    key: 'registry.endpoint',
                    args: flags,
                    legacyFlagName: 'registry',
                    defaultValue: config_1.graphqlEndpoint,
                    env: 'HIVE_REGISTRY',
                    description: SchemaDelete.flags['registry.endpoint'].description,
                });
            }
            catch (e) {
                throw new errors_1.MissingEndpointError();
            }
            try {
                accessToken = this.ensure({
                    key: 'registry.accessToken',
                    args: flags,
                    legacyFlagName: 'token',
                    env: 'HIVE_TOKEN',
                    description: SchemaDelete.flags['registry.accessToken'].description,
                });
            }
            catch (e) {
                throw new errors_1.MissingRegistryTokenError();
            }
            let target = null;
            if (flags.target) {
                const result = TargetInput.parse(flags.target);
                if (result.type === 'error') {
                    throw new errors_1.InvalidTargetError();
                }
                target = result.data;
            }
            const result = await this.registryApi(endpoint, accessToken).request({
                operation: schemaDeleteMutation,
                variables: {
                    input: {
                        serviceName: service,
                        dryRun: flags.dryRun,
                        target,
                    },
                },
            });
            if (result.schemaDelete.__typename === 'SchemaDeleteSuccess') {
                this.logSuccess(`${service} deleted`);
                this.exit(0);
                return;
            }
            this.logFailure(`Failed to delete ${service}`);
            const errors = result.schemaDelete.errors;
            if (errors) {
                throw new errors_1.APIError((0, schema_1.renderErrors)(errors));
            }
        }
        catch (error) {
            if (error instanceof core_1.Errors.CLIError) {
                throw error;
            }
            else {
                this.logFailure(`Failed to complete`);
                throw new errors_1.UnexpectedError(error);
            }
        }
    }
}
SchemaDelete.description = 'deletes a schema';
SchemaDelete.flags = {
    'registry.endpoint': core_1.Flags.string({
        description: 'registry endpoint',
    }),
    /** @deprecated */
    registry: core_1.Flags.string({
        description: 'registry address',
        deprecated: {
            message: 'use --registry.accessToken instead',
            version: '0.21.0',
        },
    }),
    'registry.accessToken': core_1.Flags.string({
        description: 'registry access token',
    }),
    /** @deprecated */
    token: core_1.Flags.string({
        description: 'api token',
        deprecated: {
            message: 'use --registry.accessToken instead',
            version: '0.21.0',
        },
    }),
    dryRun: core_1.Flags.boolean({
        description: 'Does not delete the service, only reports what it would have done.',
        default: false,
    }),
    confirm: core_1.Flags.boolean({
        description: 'Confirm deletion of the service',
        default: false,
    }),
    target: core_1.Flags.string({
        description: 'The target to which to publish to (slug or ID).' +
            ' This can either be a slug following the format "$organizationSlug/$projectSlug/$targetSlug" (e.g "the-guild/graphql-hive/staging")' +
            ' or an UUID (e.g. "a0f4c605-6541-4350-8cfe-b31f21a4bf80").',
    }),
};
SchemaDelete.args = {
    service: core_1.Args.string({
        name: 'service',
        required: true,
        description: 'name of the service',
        hidden: false,
    }),
};
exports.default = SchemaDelete;
//# sourceMappingURL=delete.js.map