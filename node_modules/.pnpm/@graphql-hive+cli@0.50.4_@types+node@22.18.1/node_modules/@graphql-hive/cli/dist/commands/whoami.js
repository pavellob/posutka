"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const base_command_1 = tslib_1.__importDefault(require("../base-command"));
const gql_1 = require("../gql");
const config_1 = require("../helpers/config");
const errors_1 = require("../helpers/errors");
const texture_1 = require("../helpers/texture/texture");
const myTokenInfoQuery = (0, gql_1.graphql)(/* GraphQL */ `
  query myTokenInfo {
    tokenInfo {
      __typename
      ... on TokenInfo {
        token {
          name
        }
        organization {
          slug
        }
        project {
          type
          slug
        }
        target {
          slug
        }
        canPublishSchema: hasTargetScope(scope: REGISTRY_WRITE)
        canCheckSchema: hasTargetScope(scope: REGISTRY_READ)
      }
      ... on TokenNotFoundError {
        message
      }
    }
  }
`);
class WhoAmI extends base_command_1.default {
    async run() {
        const { flags } = await this.parse(WhoAmI);
        let registry, token;
        try {
            registry = this.ensure({
                key: 'registry.endpoint',
                legacyFlagName: 'registry',
                args: flags,
                defaultValue: config_1.graphqlEndpoint,
                env: 'HIVE_REGISTRY',
                description: WhoAmI.flags['registry.endpoint'].description,
            });
        }
        catch (e) {
            throw new errors_1.MissingEndpointError();
        }
        try {
            token = this.ensure({
                key: 'registry.accessToken',
                legacyFlagName: 'token',
                args: flags,
                env: 'HIVE_TOKEN',
                description: WhoAmI.flags['registry.accessToken'].description,
            });
        }
        catch (e) {
            throw new errors_1.MissingRegistryTokenError();
        }
        const result = await this.registryApi(registry, token).request({
            operation: myTokenInfoQuery,
        });
        if (result.tokenInfo.__typename === 'TokenInfo') {
            const { tokenInfo } = result;
            const { organization, project, target } = tokenInfo;
            const organizationUrl = `https://app.graphql-hive.com/${organization.slug}`;
            const projectUrl = `${organizationUrl}/${project.slug}`;
            const targetUrl = `${projectUrl}/${target.slug}`;
            const access = {
                yes: texture_1.Texture.colors.green('Yes'),
                not: texture_1.Texture.colors.red('No access'),
            };
            const print = createPrinter({
                'Token name:': [texture_1.Texture.colors.bold(tokenInfo.token.name)],
                ' ': [''],
                'Organization:': [
                    texture_1.Texture.colors.bold(organization.slug),
                    texture_1.Texture.colors.dim(organizationUrl),
                ],
                'Project:': [texture_1.Texture.colors.bold(project.slug), texture_1.Texture.colors.dim(projectUrl)],
                'Target:': [texture_1.Texture.colors.bold(target.slug), texture_1.Texture.colors.dim(targetUrl)],
                '  ': [''],
                'Access to schema:publish': [tokenInfo.canPublishSchema ? access.yes : access.not],
                'Access to schema:check': [tokenInfo.canCheckSchema ? access.yes : access.not],
            });
            this.log(print());
        }
        else if (result.tokenInfo.__typename === 'TokenNotFoundError') {
            this.debug(result.tokenInfo.message);
            throw new errors_1.InvalidRegistryTokenError();
        }
        else {
            throw new errors_1.UnexpectedError(`Token response got an unsupported type: ${result.tokenInfo.__typename}`);
        }
    }
}
WhoAmI.description = 'shows information about the current token';
WhoAmI.flags = {
    'registry.endpoint': core_1.Flags.string({
        description: 'registry endpoint',
    }),
    /** @deprecated */
    registry: core_1.Flags.string({
        description: 'registry address',
        deprecated: {
            message: 'use --registry.endpoint instead',
            version: '0.21.0',
        },
    }),
    'registry.accessToken': core_1.Flags.string({
        description: 'registry access token',
    }),
    /** @deprecated */
    token: core_1.Flags.string({
        description: 'api token',
        deprecated: {
            message: 'use --registry.accessToken instead',
            version: '0.21.0',
        },
    }),
};
exports.default = WhoAmI;
function createPrinter(records) {
    const labels = Object.keys(records);
    const values = Object.values(records).map(v => v[0]);
    const maxLabelsLen = Math.max(...labels.map(v => v.length)) + 4;
    const maxValuesLen = Math.max(...values.map(v => v.length)) + 4;
    return () => {
        const lines = [];
        for (const label in records) {
            const [value, extra] = records[label];
            lines.push(label.padEnd(maxLabelsLen, ' ') + value.padEnd(maxValuesLen, ' ') + (extra || ''));
        }
        return lines.join('\n');
    };
}
//# sourceMappingURL=whoami.js.map