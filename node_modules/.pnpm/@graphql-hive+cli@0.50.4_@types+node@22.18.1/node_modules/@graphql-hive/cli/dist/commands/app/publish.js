"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const base_command_1 = tslib_1.__importDefault(require("../../base-command"));
const gql_1 = require("../../gql");
const config_1 = require("../../helpers/config");
const errors_1 = require("../../helpers/errors");
const TargetInput = tslib_1.__importStar(require("../../helpers/target-input"));
class AppPublish extends base_command_1.default {
    async run() {
        const { flags } = await this.parse(AppPublish);
        let endpoint, accessToken;
        try {
            endpoint = this.ensure({
                key: 'registry.endpoint',
                args: flags,
                defaultValue: config_1.graphqlEndpoint,
                env: 'HIVE_REGISTRY',
                description: AppPublish.flags['registry.endpoint'].description,
            });
        }
        catch (e) {
            throw new errors_1.MissingEndpointError();
        }
        try {
            accessToken = this.ensure({
                key: 'registry.accessToken',
                args: flags,
                env: 'HIVE_TOKEN',
                description: AppPublish.flags['registry.accessToken'].description,
            });
        }
        catch (e) {
            throw new errors_1.MissingRegistryTokenError();
        }
        let target = null;
        if (flags.target) {
            const result = TargetInput.parse(flags.target);
            if (result.type === 'error') {
                throw new errors_1.InvalidTargetError();
            }
            target = result.data;
        }
        const result = await this.registryApi(endpoint, accessToken).request({
            operation: ActivateAppDeploymentMutation,
            variables: {
                input: {
                    target,
                    appName: flags['name'],
                    appVersion: flags['version'],
                },
            },
        });
        if (result.activateAppDeployment.error) {
            throw new errors_1.APIError(result.activateAppDeployment.error.message);
        }
        if (result.activateAppDeployment.ok) {
            const name = `${result.activateAppDeployment.ok.activatedAppDeployment.name}@${result.activateAppDeployment.ok.activatedAppDeployment.version}`;
            if (result.activateAppDeployment.ok.isSkipped) {
                this.warn(`App deployment "${name}" is already published. Skipping...`);
                return;
            }
            this.log(`App deployment "${name}" published successfully.`);
        }
    }
}
AppPublish.description = 'publish an app deployment';
AppPublish.flags = {
    'registry.endpoint': core_1.Flags.string({
        description: 'registry endpoint',
    }),
    'registry.accessToken': core_1.Flags.string({
        description: 'registry access token',
    }),
    name: core_1.Flags.string({
        description: 'app name',
        required: true,
    }),
    version: core_1.Flags.string({
        description: 'app version',
        required: true,
    }),
    target: core_1.Flags.string({
        description: 'The target in which the app deployment will be published (slug or ID).' +
            ' This can either be a slug following the format "$organizationSlug/$projectSlug/$targetSlug" (e.g "the-guild/graphql-hive/staging")' +
            ' or an UUID (e.g. "a0f4c605-6541-4350-8cfe-b31f21a4bf80").',
    }),
};
exports.default = AppPublish;
const ActivateAppDeploymentMutation = (0, gql_1.graphql)(/* GraphQL */ `
  mutation ActivateAppDeployment($input: ActivateAppDeploymentInput!) {
    activateAppDeployment(input: $input) {
      ok {
        activatedAppDeployment {
          id
          name
          version
          status
        }
        isSkipped
      }
      error {
        message
      }
    }
  }
`);
//# sourceMappingURL=publish.js.map