"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@graphql-hive/core");
const core_2 = require("@oclif/core");
const base_command_1 = tslib_1.__importDefault(require("../../base-command"));
const errors_1 = require("../../helpers/errors");
class ArtifactsFetch extends base_command_1.default {
    async run() {
        var _a, _b, _c;
        const { flags } = await this.parse(ArtifactsFetch);
        let cdnEndpoint, token;
        try {
            cdnEndpoint = this.ensure({
                key: 'cdn.endpoint',
                args: flags,
                env: 'HIVE_CDN_ENDPOINT',
                description: ArtifactsFetch.flags['cdn.endpoint'].description,
            });
        }
        catch (e) {
            throw new errors_1.MissingCdnEndpointError();
        }
        try {
            token = this.ensure({
                key: 'cdn.accessToken',
                args: flags,
                env: 'HIVE_CDN_ACCESS_TOKEN',
                description: ArtifactsFetch.flags['cdn.accessToken'].description,
            });
        }
        catch (e) {
            throw new errors_1.MissingCdnKeyError();
        }
        const artifactType = flags.artifact;
        const url = new core_1.URL(`${cdnEndpoint}/${artifactType}`);
        let response;
        try {
            response = await core_1.http.get(url.toString(), {
                headers: {
                    'x-hive-cdn-key': token,
                    'User-Agent': `hive-cli/${this.config.version}`,
                },
                retry: {
                    retries: 3,
                },
                logger: {
                    info: (...args) => {
                        if (this.flags.debug) {
                            console.info(...args);
                        }
                    },
                    error: (...args) => {
                        if (this.flags.debug) {
                            console.error(...args);
                        }
                    },
                },
            });
        }
        catch (e) {
            const sourceError = (_a = e === null || e === void 0 ? void 0 : e.cause) !== null && _a !== void 0 ? _a : e;
            if ((0, errors_1.isAggregateError)(sourceError)) {
                throw new errors_1.NetworkError((_b = sourceError.errors[0]) === null || _b === void 0 ? void 0 : _b.message);
            }
            else {
                throw new errors_1.NetworkError(sourceError);
            }
        }
        if (!response.ok) {
            const responseBody = await response.text();
            throw new errors_1.HTTPError(url.toString(), response.status, (_c = responseBody !== null && responseBody !== void 0 ? responseBody : response.statusText) !== null && _c !== void 0 ? _c : 'Invalid status code for HTTP call');
        }
        try {
            if (flags.outputFile) {
                const fs = await Promise.resolve().then(() => tslib_1.__importStar(require('fs/promises')));
                const contents = Buffer.from(await response.arrayBuffer());
                await fs.writeFile(flags.outputFile, contents);
                this.log(`Wrote ${contents.length} bytes to ${flags.outputFile}`);
                return;
            }
            this.log(await response.text());
        }
        catch (e) {
            throw new errors_1.UnexpectedError(e);
        }
    }
}
ArtifactsFetch.description = 'fetch artifacts from the CDN';
ArtifactsFetch.flags = {
    'cdn.endpoint': core_2.Flags.string({
        description: 'CDN endpoint',
    }),
    'cdn.accessToken': core_2.Flags.string({
        description: 'CDN access token',
    }),
    artifact: core_2.Flags.string({
        description: 'artifact to fetch (Note: supergraph is only available for federation projects)',
        options: ['sdl', 'supergraph', 'metadata', 'services', 'sdl.graphql', 'sdl.graphqls'],
        required: true,
    }),
    outputFile: core_2.Flags.string({
        description: 'whether to write to a file instead of stdout',
    }),
};
exports.default = ArtifactsFetch;
//# sourceMappingURL=fetch.js.map