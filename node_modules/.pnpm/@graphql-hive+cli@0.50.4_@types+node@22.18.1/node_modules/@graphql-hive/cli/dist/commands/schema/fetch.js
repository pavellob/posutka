"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const promises_1 = require("node:fs/promises");
const node_path_1 = require("node:path");
const core_1 = require("@oclif/core");
const base_command_1 = tslib_1.__importDefault(require("../../base-command"));
const gql_1 = require("../../gql");
const config_1 = require("../../helpers/config");
const errors_1 = require("../../helpers/errors");
const TargetInput = tslib_1.__importStar(require("../../helpers/target-input"));
const texture_1 = require("../../helpers/texture/texture");
const SchemaVersionForActionIdQuery = (0, gql_1.graphql)(/* GraphQL */ `
  query SchemaVersionForActionId(
    $actionId: ID!
    $includeSDL: Boolean!
    $includeSupergraph: Boolean!
    $includeSubgraphs: Boolean!
    $target: TargetReferenceInput
  ) {
    schemaVersionForActionId(actionId: $actionId, target: $target) {
      id
      isValid
      sdl @include(if: $includeSDL)
      supergraph @include(if: $includeSupergraph)
      schemas @include(if: $includeSubgraphs) {
        edges {
          node {
            __typename
            ... on SingleSchema {
              id
              date
            }
            ... on CompositeSchema {
              id
              date
              url
              service
            }
          }
        }
      }
    }
  }
`);
const LatestSchemaVersionQuery = (0, gql_1.graphql)(/* GraphQL */ `
  query LatestSchemaVersion(
    $includeSDL: Boolean!
    $includeSupergraph: Boolean!
    $includeSubgraphs: Boolean!
    $target: TargetReferenceInput
  ) {
    latestValidVersion(target: $target) {
      id
      isValid
      sdl @include(if: $includeSDL)
      supergraph @include(if: $includeSupergraph)
      schemas @include(if: $includeSubgraphs) {
        edges {
          node {
            __typename
            ... on SingleSchema {
              id
              date
            }
            ... on CompositeSchema {
              id
              date
              url
              service
            }
          }
        }
      }
    }
  }
`);
class SchemaFetch extends base_command_1.default {
    async run() {
        var _a;
        const { flags, args } = await this.parse(SchemaFetch);
        let endpoint, accessToken;
        try {
            endpoint = this.ensure({
                key: 'registry.endpoint',
                args: flags,
                env: 'HIVE_REGISTRY',
                legacyFlagName: 'registry',
                defaultValue: config_1.graphqlEndpoint,
                description: SchemaFetch.flags['registry.endpoint'].description,
            });
        }
        catch (e) {
            throw new errors_1.MissingEndpointError();
        }
        try {
            accessToken = this.ensure({
                key: 'registry.accessToken',
                args: flags,
                legacyFlagName: 'token',
                env: 'HIVE_TOKEN',
                description: SchemaFetch.flags['registry.accessToken'].description,
            });
        }
        catch (e) {
            throw new errors_1.MissingRegistryTokenError();
        }
        const { actionId } = args;
        const sdlType = this.ensure({
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            key: 'type',
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            args: flags,
            defaultValue: 'sdl',
        });
        let target = null;
        if (flags.target) {
            const result = TargetInput.parse(flags.target);
            if (result.type === 'error') {
                throw new errors_1.InvalidTargetError();
            }
            target = result.data;
        }
        let schemaVersion;
        if (actionId) {
            const result = await this.registryApi(endpoint, accessToken).request({
                operation: SchemaVersionForActionIdQuery,
                variables: {
                    actionId,
                    includeSDL: sdlType === 'sdl',
                    includeSupergraph: sdlType === 'supergraph',
                    includeSubgraphs: sdlType === 'subgraphs',
                    target,
                },
            });
            schemaVersion = result.schemaVersionForActionId;
        }
        else {
            const result = await this.registryApi(endpoint, accessToken).request({
                operation: LatestSchemaVersionQuery,
                variables: {
                    includeSDL: sdlType === 'sdl',
                    includeSupergraph: sdlType === 'supergraph',
                    includeSubgraphs: sdlType === 'subgraphs',
                    target,
                },
            });
            schemaVersion = result.latestValidVersion;
        }
        if (schemaVersion == null) {
            throw new errors_1.SchemaNotFoundError(actionId);
        }
        if (schemaVersion.isValid === false) {
            throw new errors_1.InvalidSchemaError(actionId);
        }
        if (schemaVersion.schemas) {
            const tableData = [
                ['service', 'url', 'date'],
                ...schemaVersion.schemas.edges.map(edge => [
                    'service' in edge.node && edge.node.service != null ? edge.node.service : edge.node.id,
                    'url' in edge.node && edge.node.url != null ? edge.node.url : 'n/a',
                    edge.node.date,
                ]),
            ];
            const stats = `subgraphs length: ${schemaVersion.schemas.edges.length}`;
            const printed = `${texture_1.Texture.table(tableData)}\n\r${stats}`;
            if (flags.write) {
                const filepath = (0, node_path_1.resolve)(process.cwd(), flags.write);
                await (0, promises_1.writeFile)(filepath, printed, 'utf8');
            }
            this.log(printed);
        }
        else {
            const schema = (_a = schemaVersion.sdl) !== null && _a !== void 0 ? _a : schemaVersion.supergraph;
            if (schema == null) {
                throw new errors_1.SchemaNotFoundError(actionId);
            }
            if (flags.write) {
                const filepath = (0, node_path_1.resolve)(process.cwd(), flags.write);
                switch ((0, node_path_1.extname)(flags.write.toLowerCase())) {
                    case '.graphql':
                    case '.gql':
                    case '.gqls':
                    case '.graphqls':
                        await (0, promises_1.writeFile)(filepath, schema, 'utf8');
                        break;
                    default:
                        throw new errors_1.UnsupportedFileExtensionError(flags.write, [
                            '.graphql',
                            '.gql',
                            '.gqls',
                            '.graphqls',
                        ]);
                }
                return;
            }
            this.log(schema);
        }
    }
}
SchemaFetch.description = 'fetch a schema, supergraph, or list of subgraphs from the Hive API';
SchemaFetch.flags = {
    /** @deprecated */
    registry: core_1.Flags.string({
        description: 'registry address',
        deprecated: {
            message: 'use --registry.endpoint instead',
            version: '0.21.0',
        },
    }),
    /** @deprecated */
    token: core_1.Flags.string({
        description: 'api token',
        deprecated: {
            message: 'use --registry.accessToken instead',
            version: '0.21.0',
        },
    }),
    'registry.endpoint': core_1.Flags.string({
        description: 'registry endpoint',
    }),
    'registry.accessToken': core_1.Flags.string({
        description: 'registry access token',
    }),
    type: core_1.Flags.string({
        aliases: ['T'],
        description: 'Type to fetch (possible types: sdl, supergraph, subgraphs)',
    }),
    write: core_1.Flags.string({
        aliases: ['W'],
        description: 'Write to a file (possible extensions: .graphql, .gql, .gqls, .graphqls)',
    }),
    outputFile: core_1.Flags.string({
        description: 'whether to write to a file instead of stdout',
    }),
    target: core_1.Flags.string({
        description: 'The target from which to fetch the schema (slug or ID).' +
            ' This can either be a slug following the format "$organizationSlug/$projectSlug/$targetSlug" (e.g "the-guild/graphql-hive/staging")' +
            ' or an UUID (e.g. "a0f4c605-6541-4350-8cfe-b31f21a4bf80").',
    }),
};
SchemaFetch.args = {
    actionId: core_1.Args.string({
        name: 'actionId',
        description: 'action id (e.g. commit sha)',
        hidden: false,
    }),
};
exports.default = SchemaFetch;
//# sourceMappingURL=fetch.js.map