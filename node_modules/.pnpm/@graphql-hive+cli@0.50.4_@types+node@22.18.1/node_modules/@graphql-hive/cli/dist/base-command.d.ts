import type { TypedDocumentNode } from '@graphql-typed-document-node/core';
import { Command, Interfaces } from '@oclif/core';
import { Config, GetConfigurationValueType, ValidConfigurationKeys } from './helpers/config';
export type Flags<T extends typeof Command> = Interfaces.InferredFlags<(typeof BaseCommand)['baseFlags'] & T['flags']>;
export type Args<T extends typeof Command> = Interfaces.InferredArgs<T['args']>;
type OmitNever<T> = {
    [K in keyof T as T[K] extends never ? never : K]: T[K];
};
export default abstract class BaseCommand<T extends typeof Command> extends Command {
    protected _userConfig: Config | undefined;
    static baseFlags: {
        debug: Interfaces.BooleanFlag<boolean>;
    };
    protected flags: Flags<T>;
    protected args: Args<T>;
    protected get userConfig(): Config;
    init(): Promise<void>;
    logSuccess(...args: any[]): void;
    logFailure(...args: any[]): void;
    logInfo(...args: any[]): void;
    logWarning(...args: any[]): void;
    maybe<TArgs extends Record<string, any>, TKey extends keyof TArgs>({ key, env, args, }: {
        key: TKey;
        env: string;
        args: TArgs;
    }): string | NonNullable<TArgs[TKey]> | undefined;
    /**
     * Get a value from arguments or flags first, then from env variables,
     * then fallback to config.
     * Throw when there's no value.
     *
     * @param key
     * @param args all arguments or flags
     * @param defaultValue default value
     * @param description description of the flag in case of no value
     * @param env an env var name
     */
    ensure<TKey extends ValidConfigurationKeys, TArgs extends {
        [key in TKey]: GetConfigurationValueType<TKey>;
    }>({ key, args, legacyFlagName, defaultValue, env: envName, description, }: {
        args: TArgs;
        key: TKey;
        /** By default we try to match config names with flag names, but for legacy compatibility we need to provide the old flag name. */
        legacyFlagName?: keyof OmitNever<{
            [TArgKey in keyof TArgs]: typeof Symbol.asyncIterator extends TArgs[TArgKey] ? never : string extends TArgs[TArgKey] ? TArgKey : never;
        }>;
        defaultValue?: TArgs[keyof TArgs] | null;
        description: string;
        env?: string;
    }): NonNullable<GetConfigurationValueType<TKey>> | never;
    cleanRequestId(requestId?: string | null): string | undefined;
    registryApi(registry: string, token: string): {
        request: <TResult, TVariables>(args: {
            operation: TypedDocumentNode<TResult, TVariables>;
            /** timeout in milliseconds */
            timeout?: number;
        } & (TVariables extends Record<string, never> ? {
            variables?: never;
        } : {
            variables: TVariables;
        })) => Promise<TResult>;
    };
    graphql(endpoint: string, additionalHeaders?: Record<string, string>): {
        request: <TResult, TVariables>(args: {
            operation: TypedDocumentNode<TResult, TVariables>;
            /** timeout in milliseconds */
            timeout?: number;
        } & (TVariables extends Record<string, never> ? {
            variables?: never;
        } : {
            variables: TVariables;
        })) => Promise<TResult>;
    };
    require<TFlags extends {
        require: string[];
        [key: string]: any;
    }>(flags: TFlags): Promise<void>;
    readJSON(file: string): string;
}
export {};
//# sourceMappingURL=base-command.d.ts.map