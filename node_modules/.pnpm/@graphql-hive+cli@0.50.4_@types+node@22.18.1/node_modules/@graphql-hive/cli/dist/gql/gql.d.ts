import * as types from './graphql';
import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 * Learn more about it here: https://the-guild.dev/graphql/codegen/plugins/presets/preset-client#reducing-bundle-size
 */
type Documents = {
    "\n  mutation CreateAppDeployment($input: CreateAppDeploymentInput!) {\n    createAppDeployment(input: $input) {\n      ok {\n        createdAppDeployment {\n          id\n          name\n          version\n          status\n        }\n      }\n      error {\n        message\n      }\n    }\n  }\n": typeof types.CreateAppDeploymentDocument;
    "\n  mutation AddDocumentsToAppDeployment($input: AddDocumentsToAppDeploymentInput!) {\n    addDocumentsToAppDeployment(input: $input) {\n      ok {\n        appDeployment {\n          id\n          name\n          version\n          status\n        }\n      }\n      error {\n        message\n        details {\n          index\n          message\n          __typename\n        }\n      }\n    }\n  }\n": typeof types.AddDocumentsToAppDeploymentDocument;
    "\n  mutation ActivateAppDeployment($input: ActivateAppDeploymentInput!) {\n    activateAppDeployment(input: $input) {\n      ok {\n        activatedAppDeployment {\n          id\n          name\n          version\n          status\n        }\n        isSkipped\n      }\n      error {\n        message\n      }\n    }\n  }\n": typeof types.ActivateAppDeploymentDocument;
    "\n  mutation CLI_SchemaComposeMutation($input: SchemaComposeInput!) {\n    schemaCompose(input: $input) {\n      __typename\n      ... on SchemaComposeSuccess {\n        valid\n        compositionResult {\n          supergraphSdl\n          errors {\n            ...RenderErrors_SchemaErrorConnectionFragment\n          }\n        }\n      }\n      ... on SchemaComposeError {\n        message\n      }\n    }\n  }\n": typeof types.Cli_SchemaComposeMutationDocument;
    "\n  query fetchLatestVersion($target: TargetReferenceInput) {\n    latestValidVersion(target: $target) {\n      sdl\n    }\n  }\n": typeof types.FetchLatestVersionDocument;
    "\n  mutation schemaCheck($input: SchemaCheckInput!) {\n    schemaCheck(input: $input) {\n      __typename\n      ... on SchemaCheckSuccess {\n        valid\n        initial\n        warnings {\n          nodes {\n            message\n            source\n            line\n            column\n          }\n          total\n        }\n        changes {\n          edges {\n            __typename\n          }\n          ...RenderChanges_schemaChanges\n        }\n        schemaCheck {\n          webUrl\n        }\n      }\n      ... on SchemaCheckError {\n        valid\n        changes {\n          edges {\n            __typename\n          }\n          ...RenderChanges_schemaChanges\n        }\n        warnings {\n          nodes {\n            message\n            source\n            line\n            column\n          }\n          total\n        }\n        errors {\n          ...RenderErrors_SchemaErrorConnectionFragment\n        }\n        schemaCheck {\n          webUrl\n        }\n      }\n      ... on GitHubSchemaCheckSuccess {\n        message\n      }\n      ... on GitHubSchemaCheckError {\n        message\n      }\n    }\n  }\n": typeof types.SchemaCheckDocument;
    "\n  mutation schemaDelete($input: SchemaDeleteInput!) {\n    schemaDelete(input: $input) {\n      __typename\n      ... on SchemaDeleteSuccess {\n        valid\n        errors {\n          ...RenderErrors_SchemaErrorConnectionFragment\n        }\n      }\n      ... on SchemaDeleteError {\n        valid\n        errors {\n          ...RenderErrors_SchemaErrorConnectionFragment\n        }\n      }\n    }\n  }\n": typeof types.SchemaDeleteDocument;
    "\n  query SchemaVersionForActionId(\n    $actionId: ID!\n    $includeSDL: Boolean!\n    $includeSupergraph: Boolean!\n    $includeSubgraphs: Boolean!\n    $target: TargetReferenceInput\n  ) {\n    schemaVersionForActionId(actionId: $actionId, target: $target) {\n      id\n      isValid\n      sdl @include(if: $includeSDL)\n      supergraph @include(if: $includeSupergraph)\n      schemas @include(if: $includeSubgraphs) {\n        edges {\n          node {\n            __typename\n            ... on SingleSchema {\n              id\n              date\n            }\n            ... on CompositeSchema {\n              id\n              date\n              url\n              service\n            }\n          }\n        }\n      }\n    }\n  }\n": typeof types.SchemaVersionForActionIdDocument;
    "\n  query LatestSchemaVersion(\n    $includeSDL: Boolean!\n    $includeSupergraph: Boolean!\n    $includeSubgraphs: Boolean!\n    $target: TargetReferenceInput\n  ) {\n    latestValidVersion(target: $target) {\n      id\n      isValid\n      sdl @include(if: $includeSDL)\n      supergraph @include(if: $includeSupergraph)\n      schemas @include(if: $includeSubgraphs) {\n        edges {\n          node {\n            __typename\n            ... on SingleSchema {\n              id\n              date\n            }\n            ... on CompositeSchema {\n              id\n              date\n              url\n              service\n            }\n          }\n        }\n      }\n    }\n  }\n": typeof types.LatestSchemaVersionDocument;
    "\n  mutation schemaPublish($input: SchemaPublishInput!, $usesGitHubApp: Boolean!) {\n    schemaPublish(input: $input) {\n      __typename\n      ... on SchemaPublishSuccess @skip(if: $usesGitHubApp) {\n        initial\n        valid\n        successMessage: message\n        linkToWebsite\n        changes {\n          edges {\n            __typename\n          }\n          ...RenderChanges_schemaChanges\n        }\n      }\n      ... on SchemaPublishError @skip(if: $usesGitHubApp) {\n        valid\n        linkToWebsite\n        changes {\n          edges {\n            __typename\n          }\n          ...RenderChanges_schemaChanges\n        }\n        errors {\n          ...RenderErrors_SchemaErrorConnectionFragment\n        }\n      }\n      ... on SchemaPublishMissingServiceError @skip(if: $usesGitHubApp) {\n        missingServiceError: message\n      }\n      ... on SchemaPublishMissingUrlError @skip(if: $usesGitHubApp) {\n        missingUrlError: message\n      }\n      ... on GitHubSchemaPublishSuccess @include(if: $usesGitHubApp) {\n        message\n      }\n      ... on GitHubSchemaPublishError @include(if: $usesGitHubApp) {\n        message\n      }\n      ... on SchemaPublishRetry {\n        reason\n      }\n    }\n  }\n": typeof types.SchemaPublishDocument;
    "\n  query myTokenInfo {\n    tokenInfo {\n      __typename\n      ... on TokenInfo {\n        token {\n          name\n        }\n        organization {\n          slug\n        }\n        project {\n          type\n          slug\n        }\n        target {\n          slug\n        }\n        canPublishSchema: hasTargetScope(scope: REGISTRY_WRITE)\n        canCheckSchema: hasTargetScope(scope: REGISTRY_READ)\n      }\n      ... on TokenNotFoundError {\n        message\n      }\n    }\n  }\n": typeof types.MyTokenInfoDocument;
    "\n  fragment RenderErrors_SchemaErrorConnectionFragment on SchemaErrorConnection {\n    edges {\n      node {\n        message\n      }\n    }\n  }\n": typeof types.RenderErrors_SchemaErrorConnectionFragmentFragmentDoc;
    "\n  fragment RenderChanges_schemaChanges on SchemaChangeConnection {\n    edges {\n      node {\n        severityLevel\n        isSafeBasedOnUsage\n        message(withSafeBasedOnUsageNote: false)\n        approval {\n          approvedBy {\n            displayName\n          }\n        }\n      }\n    }\n  }\n": typeof types.RenderChanges_SchemaChangesFragmentDoc;
};
declare const documents: Documents;
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = graphql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export declare function graphql(source: string): unknown;
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export declare function graphql(source: "\n  mutation CreateAppDeployment($input: CreateAppDeploymentInput!) {\n    createAppDeployment(input: $input) {\n      ok {\n        createdAppDeployment {\n          id\n          name\n          version\n          status\n        }\n      }\n      error {\n        message\n      }\n    }\n  }\n"): (typeof documents)["\n  mutation CreateAppDeployment($input: CreateAppDeploymentInput!) {\n    createAppDeployment(input: $input) {\n      ok {\n        createdAppDeployment {\n          id\n          name\n          version\n          status\n        }\n      }\n      error {\n        message\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export declare function graphql(source: "\n  mutation AddDocumentsToAppDeployment($input: AddDocumentsToAppDeploymentInput!) {\n    addDocumentsToAppDeployment(input: $input) {\n      ok {\n        appDeployment {\n          id\n          name\n          version\n          status\n        }\n      }\n      error {\n        message\n        details {\n          index\n          message\n          __typename\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  mutation AddDocumentsToAppDeployment($input: AddDocumentsToAppDeploymentInput!) {\n    addDocumentsToAppDeployment(input: $input) {\n      ok {\n        appDeployment {\n          id\n          name\n          version\n          status\n        }\n      }\n      error {\n        message\n        details {\n          index\n          message\n          __typename\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export declare function graphql(source: "\n  mutation ActivateAppDeployment($input: ActivateAppDeploymentInput!) {\n    activateAppDeployment(input: $input) {\n      ok {\n        activatedAppDeployment {\n          id\n          name\n          version\n          status\n        }\n        isSkipped\n      }\n      error {\n        message\n      }\n    }\n  }\n"): (typeof documents)["\n  mutation ActivateAppDeployment($input: ActivateAppDeploymentInput!) {\n    activateAppDeployment(input: $input) {\n      ok {\n        activatedAppDeployment {\n          id\n          name\n          version\n          status\n        }\n        isSkipped\n      }\n      error {\n        message\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export declare function graphql(source: "\n  mutation CLI_SchemaComposeMutation($input: SchemaComposeInput!) {\n    schemaCompose(input: $input) {\n      __typename\n      ... on SchemaComposeSuccess {\n        valid\n        compositionResult {\n          supergraphSdl\n          errors {\n            ...RenderErrors_SchemaErrorConnectionFragment\n          }\n        }\n      }\n      ... on SchemaComposeError {\n        message\n      }\n    }\n  }\n"): (typeof documents)["\n  mutation CLI_SchemaComposeMutation($input: SchemaComposeInput!) {\n    schemaCompose(input: $input) {\n      __typename\n      ... on SchemaComposeSuccess {\n        valid\n        compositionResult {\n          supergraphSdl\n          errors {\n            ...RenderErrors_SchemaErrorConnectionFragment\n          }\n        }\n      }\n      ... on SchemaComposeError {\n        message\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export declare function graphql(source: "\n  query fetchLatestVersion($target: TargetReferenceInput) {\n    latestValidVersion(target: $target) {\n      sdl\n    }\n  }\n"): (typeof documents)["\n  query fetchLatestVersion($target: TargetReferenceInput) {\n    latestValidVersion(target: $target) {\n      sdl\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export declare function graphql(source: "\n  mutation schemaCheck($input: SchemaCheckInput!) {\n    schemaCheck(input: $input) {\n      __typename\n      ... on SchemaCheckSuccess {\n        valid\n        initial\n        warnings {\n          nodes {\n            message\n            source\n            line\n            column\n          }\n          total\n        }\n        changes {\n          edges {\n            __typename\n          }\n          ...RenderChanges_schemaChanges\n        }\n        schemaCheck {\n          webUrl\n        }\n      }\n      ... on SchemaCheckError {\n        valid\n        changes {\n          edges {\n            __typename\n          }\n          ...RenderChanges_schemaChanges\n        }\n        warnings {\n          nodes {\n            message\n            source\n            line\n            column\n          }\n          total\n        }\n        errors {\n          ...RenderErrors_SchemaErrorConnectionFragment\n        }\n        schemaCheck {\n          webUrl\n        }\n      }\n      ... on GitHubSchemaCheckSuccess {\n        message\n      }\n      ... on GitHubSchemaCheckError {\n        message\n      }\n    }\n  }\n"): (typeof documents)["\n  mutation schemaCheck($input: SchemaCheckInput!) {\n    schemaCheck(input: $input) {\n      __typename\n      ... on SchemaCheckSuccess {\n        valid\n        initial\n        warnings {\n          nodes {\n            message\n            source\n            line\n            column\n          }\n          total\n        }\n        changes {\n          edges {\n            __typename\n          }\n          ...RenderChanges_schemaChanges\n        }\n        schemaCheck {\n          webUrl\n        }\n      }\n      ... on SchemaCheckError {\n        valid\n        changes {\n          edges {\n            __typename\n          }\n          ...RenderChanges_schemaChanges\n        }\n        warnings {\n          nodes {\n            message\n            source\n            line\n            column\n          }\n          total\n        }\n        errors {\n          ...RenderErrors_SchemaErrorConnectionFragment\n        }\n        schemaCheck {\n          webUrl\n        }\n      }\n      ... on GitHubSchemaCheckSuccess {\n        message\n      }\n      ... on GitHubSchemaCheckError {\n        message\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export declare function graphql(source: "\n  mutation schemaDelete($input: SchemaDeleteInput!) {\n    schemaDelete(input: $input) {\n      __typename\n      ... on SchemaDeleteSuccess {\n        valid\n        errors {\n          ...RenderErrors_SchemaErrorConnectionFragment\n        }\n      }\n      ... on SchemaDeleteError {\n        valid\n        errors {\n          ...RenderErrors_SchemaErrorConnectionFragment\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  mutation schemaDelete($input: SchemaDeleteInput!) {\n    schemaDelete(input: $input) {\n      __typename\n      ... on SchemaDeleteSuccess {\n        valid\n        errors {\n          ...RenderErrors_SchemaErrorConnectionFragment\n        }\n      }\n      ... on SchemaDeleteError {\n        valid\n        errors {\n          ...RenderErrors_SchemaErrorConnectionFragment\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export declare function graphql(source: "\n  query SchemaVersionForActionId(\n    $actionId: ID!\n    $includeSDL: Boolean!\n    $includeSupergraph: Boolean!\n    $includeSubgraphs: Boolean!\n    $target: TargetReferenceInput\n  ) {\n    schemaVersionForActionId(actionId: $actionId, target: $target) {\n      id\n      isValid\n      sdl @include(if: $includeSDL)\n      supergraph @include(if: $includeSupergraph)\n      schemas @include(if: $includeSubgraphs) {\n        edges {\n          node {\n            __typename\n            ... on SingleSchema {\n              id\n              date\n            }\n            ... on CompositeSchema {\n              id\n              date\n              url\n              service\n            }\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query SchemaVersionForActionId(\n    $actionId: ID!\n    $includeSDL: Boolean!\n    $includeSupergraph: Boolean!\n    $includeSubgraphs: Boolean!\n    $target: TargetReferenceInput\n  ) {\n    schemaVersionForActionId(actionId: $actionId, target: $target) {\n      id\n      isValid\n      sdl @include(if: $includeSDL)\n      supergraph @include(if: $includeSupergraph)\n      schemas @include(if: $includeSubgraphs) {\n        edges {\n          node {\n            __typename\n            ... on SingleSchema {\n              id\n              date\n            }\n            ... on CompositeSchema {\n              id\n              date\n              url\n              service\n            }\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export declare function graphql(source: "\n  query LatestSchemaVersion(\n    $includeSDL: Boolean!\n    $includeSupergraph: Boolean!\n    $includeSubgraphs: Boolean!\n    $target: TargetReferenceInput\n  ) {\n    latestValidVersion(target: $target) {\n      id\n      isValid\n      sdl @include(if: $includeSDL)\n      supergraph @include(if: $includeSupergraph)\n      schemas @include(if: $includeSubgraphs) {\n        edges {\n          node {\n            __typename\n            ... on SingleSchema {\n              id\n              date\n            }\n            ... on CompositeSchema {\n              id\n              date\n              url\n              service\n            }\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  query LatestSchemaVersion(\n    $includeSDL: Boolean!\n    $includeSupergraph: Boolean!\n    $includeSubgraphs: Boolean!\n    $target: TargetReferenceInput\n  ) {\n    latestValidVersion(target: $target) {\n      id\n      isValid\n      sdl @include(if: $includeSDL)\n      supergraph @include(if: $includeSupergraph)\n      schemas @include(if: $includeSubgraphs) {\n        edges {\n          node {\n            __typename\n            ... on SingleSchema {\n              id\n              date\n            }\n            ... on CompositeSchema {\n              id\n              date\n              url\n              service\n            }\n          }\n        }\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export declare function graphql(source: "\n  mutation schemaPublish($input: SchemaPublishInput!, $usesGitHubApp: Boolean!) {\n    schemaPublish(input: $input) {\n      __typename\n      ... on SchemaPublishSuccess @skip(if: $usesGitHubApp) {\n        initial\n        valid\n        successMessage: message\n        linkToWebsite\n        changes {\n          edges {\n            __typename\n          }\n          ...RenderChanges_schemaChanges\n        }\n      }\n      ... on SchemaPublishError @skip(if: $usesGitHubApp) {\n        valid\n        linkToWebsite\n        changes {\n          edges {\n            __typename\n          }\n          ...RenderChanges_schemaChanges\n        }\n        errors {\n          ...RenderErrors_SchemaErrorConnectionFragment\n        }\n      }\n      ... on SchemaPublishMissingServiceError @skip(if: $usesGitHubApp) {\n        missingServiceError: message\n      }\n      ... on SchemaPublishMissingUrlError @skip(if: $usesGitHubApp) {\n        missingUrlError: message\n      }\n      ... on GitHubSchemaPublishSuccess @include(if: $usesGitHubApp) {\n        message\n      }\n      ... on GitHubSchemaPublishError @include(if: $usesGitHubApp) {\n        message\n      }\n      ... on SchemaPublishRetry {\n        reason\n      }\n    }\n  }\n"): (typeof documents)["\n  mutation schemaPublish($input: SchemaPublishInput!, $usesGitHubApp: Boolean!) {\n    schemaPublish(input: $input) {\n      __typename\n      ... on SchemaPublishSuccess @skip(if: $usesGitHubApp) {\n        initial\n        valid\n        successMessage: message\n        linkToWebsite\n        changes {\n          edges {\n            __typename\n          }\n          ...RenderChanges_schemaChanges\n        }\n      }\n      ... on SchemaPublishError @skip(if: $usesGitHubApp) {\n        valid\n        linkToWebsite\n        changes {\n          edges {\n            __typename\n          }\n          ...RenderChanges_schemaChanges\n        }\n        errors {\n          ...RenderErrors_SchemaErrorConnectionFragment\n        }\n      }\n      ... on SchemaPublishMissingServiceError @skip(if: $usesGitHubApp) {\n        missingServiceError: message\n      }\n      ... on SchemaPublishMissingUrlError @skip(if: $usesGitHubApp) {\n        missingUrlError: message\n      }\n      ... on GitHubSchemaPublishSuccess @include(if: $usesGitHubApp) {\n        message\n      }\n      ... on GitHubSchemaPublishError @include(if: $usesGitHubApp) {\n        message\n      }\n      ... on SchemaPublishRetry {\n        reason\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export declare function graphql(source: "\n  query myTokenInfo {\n    tokenInfo {\n      __typename\n      ... on TokenInfo {\n        token {\n          name\n        }\n        organization {\n          slug\n        }\n        project {\n          type\n          slug\n        }\n        target {\n          slug\n        }\n        canPublishSchema: hasTargetScope(scope: REGISTRY_WRITE)\n        canCheckSchema: hasTargetScope(scope: REGISTRY_READ)\n      }\n      ... on TokenNotFoundError {\n        message\n      }\n    }\n  }\n"): (typeof documents)["\n  query myTokenInfo {\n    tokenInfo {\n      __typename\n      ... on TokenInfo {\n        token {\n          name\n        }\n        organization {\n          slug\n        }\n        project {\n          type\n          slug\n        }\n        target {\n          slug\n        }\n        canPublishSchema: hasTargetScope(scope: REGISTRY_WRITE)\n        canCheckSchema: hasTargetScope(scope: REGISTRY_READ)\n      }\n      ... on TokenNotFoundError {\n        message\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export declare function graphql(source: "\n  fragment RenderErrors_SchemaErrorConnectionFragment on SchemaErrorConnection {\n    edges {\n      node {\n        message\n      }\n    }\n  }\n"): (typeof documents)["\n  fragment RenderErrors_SchemaErrorConnectionFragment on SchemaErrorConnection {\n    edges {\n      node {\n        message\n      }\n    }\n  }\n"];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export declare function graphql(source: "\n  fragment RenderChanges_schemaChanges on SchemaChangeConnection {\n    edges {\n      node {\n        severityLevel\n        isSafeBasedOnUsage\n        message(withSafeBasedOnUsageNote: false)\n        approval {\n          approvedBy {\n            displayName\n          }\n        }\n      }\n    }\n  }\n"): (typeof documents)["\n  fragment RenderChanges_schemaChanges on SchemaChangeConnection {\n    edges {\n      node {\n        severityLevel\n        isSafeBasedOnUsage\n        message(withSafeBasedOnUsageNote: false)\n        approval {\n          approvedBy {\n            displayName\n          }\n        }\n      }\n    }\n  }\n"];
export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<infer TType, any> ? TType : never;
export {};
//# sourceMappingURL=gql.d.ts.map