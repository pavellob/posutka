import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<T extends {
    [key: string]: unknown;
}, K extends keyof T> = {
    [_ in K]?: never;
};
export type Incremental<T> = T | {
    [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
    ID: {
        input: string;
        output: string;
    };
    String: {
        input: string;
        output: string;
    };
    Boolean: {
        input: boolean;
        output: boolean;
    };
    Int: {
        input: number;
        output: number;
    };
    Float: {
        input: number;
        output: number;
    };
    Date: {
        input: any;
        output: any;
    };
    /**
     * A date-time string at UTC, such as `2007-12-03T10:15:30Z`, is compliant with the date-time format outlined
     * in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
     *
     * This scalar is a description of an exact instant on the timeline such as the instant that a user account was created.
     *
     * This scalar ignores leap seconds (thereby assuming that a minute constitutes 59 seconds). In this respect, it diverges from the RFC 3339 profile.
     *
     * Where an RFC 3339 compliant date-time string has a time-zone other than UTC, it is shifted to UTC. For example, the date-time string `2016-01-01T14:10:20+01:00` is shifted to `2016-01-01T13:10:20Z`.
     */
    DateTime: {
        input: any;
        output: any;
    };
    JSON: {
        input: any;
        output: any;
    };
    JSONSchemaObject: {
        input: any;
        output: any;
    };
    SafeInt: {
        input: any;
        output: any;
    };
};
export type ActivateAppDeploymentError = Error & {
    __typename?: 'ActivateAppDeploymentError';
    message: Scalars['String']['output'];
};
export type ActivateAppDeploymentInput = {
    appName: Scalars['String']['input'];
    appVersion: Scalars['String']['input'];
    target?: InputMaybe<TargetReferenceInput>;
};
export type ActivateAppDeploymentOk = {
    __typename?: 'ActivateAppDeploymentOk';
    activatedAppDeployment: AppDeployment;
    /** Whether the app deployment activation was skipped because it is already activated. */
    isSkipped: Scalars['Boolean']['output'];
};
export type ActivateAppDeploymentResult = {
    __typename?: 'ActivateAppDeploymentResult';
    error?: Maybe<ActivateAppDeploymentError>;
    ok?: Maybe<ActivateAppDeploymentOk>;
};
export type AddAlertChannelError = Error & {
    __typename?: 'AddAlertChannelError';
    inputErrors: AddAlertChannelInputErrors;
    message: Scalars['String']['output'];
};
export type AddAlertChannelInput = {
    name: Scalars['String']['input'];
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    slack?: InputMaybe<SlackChannelInput>;
    type: AlertChannelType;
    webhook?: InputMaybe<WebhookChannelInput>;
};
export type AddAlertChannelInputErrors = {
    __typename?: 'AddAlertChannelInputErrors';
    name?: Maybe<Scalars['String']['output']>;
    slackChannel?: Maybe<Scalars['String']['output']>;
    webhookEndpoint?: Maybe<Scalars['String']['output']>;
};
export type AddAlertChannelOk = {
    __typename?: 'AddAlertChannelOk';
    addedAlertChannel: AlertChannel;
    updatedProject: Project;
};
export type AddAlertChannelResult = {
    __typename?: 'AddAlertChannelResult';
    error?: Maybe<AddAlertChannelError>;
    ok?: Maybe<AddAlertChannelOk>;
};
export type AddAlertError = Error & {
    __typename?: 'AddAlertError';
    message: Scalars['String']['output'];
};
export type AddAlertInput = {
    channelId: Scalars['ID']['input'];
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    targetSlug: Scalars['String']['input'];
    type: AlertType;
};
export type AddAlertOk = {
    __typename?: 'AddAlertOk';
    addedAlert: Alert;
    updatedProject: Project;
};
export type AddAlertResult = {
    __typename?: 'AddAlertResult';
    error?: Maybe<AddAlertError>;
    ok?: Maybe<AddAlertOk>;
};
export type AddDocumentsToAppDeploymentError = Error & {
    __typename?: 'AddDocumentsToAppDeploymentError';
    /** Optional details if the error is related to a specific document. */
    details?: Maybe<AddDocumentsToAppDeploymentErrorDetails>;
    message: Scalars['String']['output'];
};
export type AddDocumentsToAppDeploymentErrorDetails = {
    __typename?: 'AddDocumentsToAppDeploymentErrorDetails';
    /** Index of the document sent from the client. */
    index: Scalars['Int']['output'];
    /** Error message for the document at the given index. */
    message: Scalars['String']['output'];
};
export type AddDocumentsToAppDeploymentInput = {
    /** Name of the app. */
    appName: Scalars['String']['input'];
    /** The version of the app */
    appVersion: Scalars['String']['input'];
    /** A list of operations to add to the app deployment. (max 100 per single batch) */
    documents: Array<DocumentInput>;
    target?: InputMaybe<TargetReferenceInput>;
};
export type AddDocumentsToAppDeploymentOk = {
    __typename?: 'AddDocumentsToAppDeploymentOk';
    appDeployment: AppDeployment;
};
export type AddDocumentsToAppDeploymentResult = {
    __typename?: 'AddDocumentsToAppDeploymentResult';
    error?: Maybe<AddDocumentsToAppDeploymentError>;
    ok?: Maybe<AddDocumentsToAppDeploymentOk>;
};
export type AddGitHubIntegrationInput = {
    installationId: Scalars['ID']['input'];
    organizationSlug: Scalars['String']['input'];
};
export type AddSlackIntegrationInput = {
    organizationSlug: Scalars['String']['input'];
    token: Scalars['String']['input'];
};
export type AdminGeneralStats = {
    __typename?: 'AdminGeneralStats';
    operationsOverTime: Array<AdminOperationPoint>;
};
export type AdminOperationPoint = {
    __typename?: 'AdminOperationPoint';
    count: Scalars['SafeInt']['output'];
    date: Scalars['DateTime']['output'];
};
export type AdminOrganizationStats = {
    __typename?: 'AdminOrganizationStats';
    operations: Scalars['SafeInt']['output'];
    organization: Organization;
    persistedOperations: Scalars['Int']['output'];
    projects: Scalars['Int']['output'];
    targets: Scalars['Int']['output'];
    users: Scalars['Int']['output'];
    versions: Scalars['Int']['output'];
};
export type AdminQuery = {
    __typename?: 'AdminQuery';
    stats: AdminStats;
};
export type AdminQueryStatsArgs = {
    period: DateRangeInput;
    resolution: Scalars['Int']['input'];
};
export type AdminStats = {
    __typename?: 'AdminStats';
    general: AdminGeneralStats;
    organizations: Array<AdminOrganizationStats>;
};
export type Alert = {
    __typename?: 'Alert';
    channel: AlertChannel;
    id: Scalars['ID']['output'];
    target: Target;
    type: AlertType;
};
export type AlertChannel = {
    id: Scalars['ID']['output'];
    name: Scalars['String']['output'];
    type: AlertChannelType;
};
export declare enum AlertChannelType {
    MsteamsWebhook = "MSTEAMS_WEBHOOK",
    Slack = "SLACK",
    Webhook = "WEBHOOK"
}
export type AlertSlackChannel = AlertChannel & {
    __typename?: 'AlertSlackChannel';
    channel: Scalars['String']['output'];
    id: Scalars['ID']['output'];
    name: Scalars['String']['output'];
    type: AlertChannelType;
};
export declare enum AlertType {
    SchemaChangeNotifications = "SCHEMA_CHANGE_NOTIFICATIONS"
}
export type AlertWebhookChannel = AlertChannel & {
    __typename?: 'AlertWebhookChannel';
    endpoint: Scalars['String']['output'];
    id: Scalars['ID']['output'];
    name: Scalars['String']['output'];
    type: AlertChannelType;
};
export type AnswerOrganizationTransferRequestError = Error & {
    __typename?: 'AnswerOrganizationTransferRequestError';
    message: Scalars['String']['output'];
};
export type AnswerOrganizationTransferRequestInput = {
    accept: Scalars['Boolean']['input'];
    code: Scalars['String']['input'];
    organizationSlug: Scalars['String']['input'];
};
export type AnswerOrganizationTransferRequestOk = {
    __typename?: 'AnswerOrganizationTransferRequestOk';
    accepted: Scalars['Boolean']['output'];
};
/** @oneOf */
export type AnswerOrganizationTransferRequestResult = {
    __typename?: 'AnswerOrganizationTransferRequestResult';
    error?: Maybe<AnswerOrganizationTransferRequestError>;
    ok?: Maybe<AnswerOrganizationTransferRequestOk>;
};
export type AppDeployment = {
    __typename?: 'AppDeployment';
    documents?: Maybe<GraphQlDocumentConnection>;
    id: Scalars['ID']['output'];
    /** The last time a GraphQL request that used the app deployment was reported. */
    lastUsed?: Maybe<Scalars['DateTime']['output']>;
    name: Scalars['String']['output'];
    status: AppDeploymentStatus;
    totalDocumentCount: Scalars['Int']['output'];
    version: Scalars['String']['output'];
};
export type AppDeploymentDocumentsArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
};
export type AppDeploymentConnection = {
    __typename?: 'AppDeploymentConnection';
    edges: Array<AppDeploymentEdge>;
    pageInfo: PageInfo;
};
export type AppDeploymentEdge = {
    __typename?: 'AppDeploymentEdge';
    cursor: Scalars['String']['output'];
    node: AppDeployment;
};
export type AppDeploymentOperation = {
    /** GraphQL operation body. */
    body: Scalars['String']['input'];
    /** GraphQL operation hash. */
    hash: Scalars['String']['input'];
};
export type AppDeploymentResourceAssignmentInput = {
    appDeployment: Scalars['String']['input'];
};
export declare enum AppDeploymentStatus {
    Active = "active",
    Pending = "pending",
    Retired = "retired"
}
export type ApproveFailedSchemaCheckError = {
    __typename?: 'ApproveFailedSchemaCheckError';
    message: Scalars['String']['output'];
};
export type ApproveFailedSchemaCheckInput = {
    /**
     * Optional comment visible in the schema check.
     * Give a reason why the schema check was approved.
     */
    comment?: InputMaybe<Scalars['String']['input']>;
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    schemaCheckId: Scalars['ID']['input'];
    targetSlug: Scalars['String']['input'];
};
export type ApproveFailedSchemaCheckOk = {
    __typename?: 'ApproveFailedSchemaCheckOk';
    schemaCheck: SchemaCheck;
};
export type ApproveFailedSchemaCheckResult = {
    __typename?: 'ApproveFailedSchemaCheckResult';
    error?: Maybe<ApproveFailedSchemaCheckError>;
    ok?: Maybe<ApproveFailedSchemaCheckOk>;
};
export type AssignMemberRoleInput = {
    member: MemberReferenceInput;
    memberRole: MemberRoleReferenceInput;
    organization: OrganizationReferenceInput;
    resources: ResourceAssignmentInput;
};
/** @oneOf */
export type AssignMemberRoleResult = {
    __typename?: 'AssignMemberRoleResult';
    error?: Maybe<AssignMemberRoleResultError>;
    ok?: Maybe<AssignMemberRoleResultOk>;
};
export type AssignMemberRoleResultError = {
    __typename?: 'AssignMemberRoleResultError';
    message: Scalars['String']['output'];
};
export type AssignMemberRoleResultOk = {
    __typename?: 'AssignMemberRoleResultOk';
    previousMemberRole?: Maybe<MemberRole>;
    updatedMember: Member;
};
export type AuditLogFilter = {
    endDate: Scalars['DateTime']['input'];
    startDate: Scalars['DateTime']['input'];
};
export declare enum AuthProviderType {
    Github = "GITHUB",
    Google = "GOOGLE",
    /** OpenID Connect */
    Oidc = "OIDC",
    /** Username-Password-Authentication */
    UsernamePassword = "USERNAME_PASSWORD"
}
export type BillingConfiguration = {
    __typename?: 'BillingConfiguration';
    billingAddress?: Maybe<BillingDetails>;
    canUpdateSubscription: Scalars['Boolean']['output'];
    hasActiveSubscription: Scalars['Boolean']['output'];
    hasPaymentIssues: Scalars['Boolean']['output'];
    invoices?: Maybe<Array<BillingInvoice>>;
    paymentMethod?: Maybe<BillingPaymentMethod>;
    upcomingInvoice?: Maybe<BillingInvoice>;
};
export type BillingDetails = {
    __typename?: 'BillingDetails';
    city?: Maybe<Scalars['String']['output']>;
    country?: Maybe<Scalars['String']['output']>;
    line1?: Maybe<Scalars['String']['output']>;
    line2?: Maybe<Scalars['String']['output']>;
    postalCode?: Maybe<Scalars['String']['output']>;
    state?: Maybe<Scalars['String']['output']>;
};
export type BillingInvoice = {
    __typename?: 'BillingInvoice';
    amount: Scalars['Float']['output'];
    date: Scalars['DateTime']['output'];
    id: Scalars['ID']['output'];
    pdfLink?: Maybe<Scalars['String']['output']>;
    periodEnd: Scalars['DateTime']['output'];
    periodStart: Scalars['DateTime']['output'];
    status: BillingInvoiceStatus;
};
export declare enum BillingInvoiceStatus {
    Draft = "DRAFT",
    Open = "OPEN",
    Paid = "PAID",
    Uncollectible = "UNCOLLECTIBLE",
    Void = "VOID"
}
export type BillingPaymentMethod = {
    __typename?: 'BillingPaymentMethod';
    brand: Scalars['String']['output'];
    expMonth: Scalars['Int']['output'];
    expYear: Scalars['Int']['output'];
    last4: Scalars['String']['output'];
};
export type BillingPlan = {
    __typename?: 'BillingPlan';
    basePrice?: Maybe<Scalars['Float']['output']>;
    description?: Maybe<Scalars['String']['output']>;
    id: Scalars['ID']['output'];
    includedOperationsLimit?: Maybe<Scalars['SafeInt']['output']>;
    name: Scalars['String']['output'];
    planType: BillingPlanType;
    pricePerOperationsUnit?: Maybe<Scalars['Float']['output']>;
    rateLimit: UsageRateLimitType;
    retentionInDays: Scalars['Int']['output'];
};
export declare enum BillingPlanType {
    Enterprise = "ENTERPRISE",
    Hobby = "HOBBY",
    Pro = "PRO"
}
export declare enum BreakingChangeFormulaType {
    Percentage = "PERCENTAGE",
    RequestCount = "REQUEST_COUNT"
}
export type BreakingChangeMetadataTarget = {
    __typename?: 'BreakingChangeMetadataTarget';
    id: Scalars['ID']['output'];
    slug: Scalars['String']['output'];
    target?: Maybe<Target>;
};
export type CdnAccessToken = {
    __typename?: 'CdnAccessToken';
    alias: Scalars['String']['output'];
    createdAt: Scalars['DateTime']['output'];
    firstCharacters: Scalars['String']['output'];
    id: Scalars['ID']['output'];
    lastCharacters: Scalars['String']['output'];
};
/** @oneOf */
export type CdnAccessTokenCreateResult = {
    __typename?: 'CdnAccessTokenCreateResult';
    error?: Maybe<CdnAccessTokenCreateResultError>;
    ok?: Maybe<CdnAccessTokenCreateResultOk>;
};
export type CdnAccessTokenCreateResultError = {
    __typename?: 'CdnAccessTokenCreateResultError';
    message: Scalars['String']['output'];
};
export type CdnAccessTokenCreateResultOk = {
    __typename?: 'CdnAccessTokenCreateResultOk';
    cdnUrl: Scalars['String']['output'];
    createdCdnAccessToken: CdnAccessToken;
    secretAccessToken: Scalars['String']['output'];
};
export type ChangePlanResult = {
    __typename?: 'ChangePlanResult';
    newPlan: BillingPlanType;
    organization: Organization;
    previousPlan: BillingPlanType;
};
export type ClientNameStatsValues = {
    __typename?: 'ClientNameStatsValues';
    count: Scalars['Float']['output'];
    name: Scalars['String']['output'];
};
export type ClientStats = {
    __typename?: 'ClientStats';
    operations: OperationStatsValuesConnection;
    requestsOverTime: Array<RequestsOverTime>;
    totalRequests: Scalars['SafeInt']['output'];
    totalVersions: Scalars['SafeInt']['output'];
    versions: Array<ClientVersionStatsValues>;
};
export type ClientStatsRequestsOverTimeArgs = {
    resolution: Scalars['Int']['input'];
};
export type ClientStatsVersionsArgs = {
    limit: Scalars['Int']['input'];
};
export type ClientStatsByTargetsInput = {
    organizationSlug: Scalars['String']['input'];
    period: DateRangeInput;
    projectSlug: Scalars['String']['input'];
    targetIds: Array<Scalars['ID']['input']>;
};
export type ClientStatsValues = {
    __typename?: 'ClientStatsValues';
    count: Scalars['Float']['output'];
    name: Scalars['String']['output'];
    percentage: Scalars['Float']['output'];
    versions: Array<ClientVersionStatsValues>;
};
export type ClientStatsValuesConnection = {
    __typename?: 'ClientStatsValuesConnection';
    edges: Array<ClientStatsValuesEdge>;
    pageInfo: PageInfo;
};
export type ClientStatsValuesEdge = {
    __typename?: 'ClientStatsValuesEdge';
    cursor: Scalars['String']['output'];
    node: ClientStatsValues;
};
export type ClientVersionStatsValues = {
    __typename?: 'ClientVersionStatsValues';
    count: Scalars['Float']['output'];
    percentage: Scalars['Float']['output'];
    version: Scalars['String']['output'];
};
export type CodePosition = {
    __typename?: 'CodePosition';
    column: Scalars['Int']['output'];
    line: Scalars['Int']['output'];
};
export type CompositeSchema = {
    __typename?: 'CompositeSchema';
    author: Scalars['String']['output'];
    commit: Scalars['ID']['output'];
    date: Scalars['DateTime']['output'];
    id: Scalars['ID']['output'];
    metadata?: Maybe<Scalars['String']['output']>;
    service?: Maybe<Scalars['String']['output']>;
    source: Scalars['String']['output'];
    url?: Maybe<Scalars['String']['output']>;
};
export type ConditionalBreakingChangeConfiguration = {
    __typename?: 'ConditionalBreakingChangeConfiguration';
    /**
     * Determines which formula is used to determine if a change is considered breaking
     * or not. Only one formula can be used at a time.
     */
    breakingChangeFormula: BreakingChangeFormulaType;
    /** List of client names that are be excluded from the breaking change detection. */
    excludedClients: Array<Scalars['String']['output']>;
    /** Whether conditional breaking change detection is enabled. */
    isEnabled: Scalars['Boolean']['output'];
    /**
     * If TargetValidationSettings.breakingChangeFormula is PERCENTAGE, then this
     * is the percent of the total operations over the TargetValidationSettings.period
     * required for a change to be considered breaking.
     */
    percentage: Scalars['Float']['output'];
    /** The period in days. Operations of the last x days will be used for the conditional breaking change detection. */
    period: Scalars['Int']['output'];
    /**
     * If TargetValidationSettings.breakingChangeFormula is REQUEST_COUNT, then this
     * is the total number of operations over the TargetValidationSettings.period
     * required for a change to be considered breaking.
     */
    requestCount: Scalars['Int']['output'];
    /** List of target within the same project, whose operations are used for the breaking change detection. */
    targets: Array<Target>;
};
/** Fields not provided (omitted) will retain the previous value. */
export type ConditionalBreakingChangeConfigurationInput = {
    /** Whether a percentage or absolute value should be used for the conditional breaking changes treshold. */
    breakingChangeFormula?: InputMaybe<BreakingChangeFormulaType>;
    /** List of client names that are excluded from the breaking change detection. */
    excludedClients?: InputMaybe<Array<Scalars['String']['input']>>;
    /** Update whethe the conditional breaking change detection is enabled or disabled. */
    isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
    /** The percentage value if `UpdateTargetValidationSettingsInput.breakingChangeFormula` is set to `BreakingChangeFormulaType.PERCENTAGE`. */
    percentage?: InputMaybe<Scalars['Float']['input']>;
    /**
     * The period in days. Operations of the last x days will be used for the conditional breaking change detection.
     * The maximum value depends on the organizations data retention limits.
     */
    period?: InputMaybe<Scalars['Int']['input']>;
    /** The request count value if `UpdateTargetValidationSettingsInput.breakingChangeFormula` is set to `BreakingChangeFormulaType.REQUEST_COUNT`. */
    requestCount?: InputMaybe<Scalars['Int']['input']>;
    /** List of target ids within the same project, whose operations are used for the breaking change detection. */
    targetIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};
export type Contract = {
    __typename?: 'Contract';
    /** The URL for accessing this contracts's artifacts via the CDN. */
    cdnUrl: Scalars['String']['output'];
    contractName: Scalars['String']['output'];
    createdAt: Scalars['DateTime']['output'];
    excludeTags?: Maybe<Array<Scalars['String']['output']>>;
    id: Scalars['ID']['output'];
    includeTags?: Maybe<Array<Scalars['String']['output']>>;
    isDisabled: Scalars['Boolean']['output'];
    removeUnreachableTypesFromPublicApiSchema: Scalars['Boolean']['output'];
    target: Target;
    viewerCanDisableContract: Scalars['Boolean']['output'];
};
/** Schema check result for contracts */
export type ContractCheck = {
    __typename?: 'ContractCheck';
    breakingSchemaChanges?: Maybe<SchemaChangeConnection>;
    compositeSchemaSDL?: Maybe<Scalars['String']['output']>;
    contractName: Scalars['String']['output'];
    /** The contract version against this check was performed. */
    contractVersion?: Maybe<ContractVersion>;
    /** Whether this schema check has any schema changes. */
    hasSchemaChanges: Scalars['Boolean']['output'];
    /** Whether this schema check has any composition errors. */
    hasSchemaCompositionErrors: Scalars['Boolean']['output'];
    /** Whether this schema check has any breaking changes. */
    hasUnapprovedBreakingChanges: Scalars['Boolean']['output'];
    id: Scalars['ID']['output'];
    isSuccess: Scalars['Boolean']['output'];
    safeSchemaChanges?: Maybe<SchemaChangeConnection>;
    schemaChanges?: Maybe<SchemaChangeConnection>;
    schemaCompositionErrors?: Maybe<SchemaErrorConnection>;
    supergraphSDL?: Maybe<Scalars['String']['output']>;
};
export type ContractCheckConnection = {
    __typename?: 'ContractCheckConnection';
    edges: Array<ContractCheckEdge>;
    pageInfo: PageInfo;
};
export type ContractCheckEdge = {
    __typename?: 'ContractCheckEdge';
    cursor: Scalars['String']['output'];
    node: ContractCheck;
};
export type ContractConnection = {
    __typename?: 'ContractConnection';
    edges: Array<ContractEdge>;
    pageInfo: PageInfo;
};
export type ContractEdge = {
    __typename?: 'ContractEdge';
    cursor: Scalars['String']['output'];
    node: Contract;
};
export type ContractReferenceInput = {
    byId: Scalars['ID']['input'];
};
export type ContractVersion = {
    __typename?: 'ContractVersion';
    /** Breaking schema changes for this contract version. */
    breakingSchemaChanges?: Maybe<SchemaChangeConnection>;
    compositeSchemaSDL?: Maybe<Scalars['String']['output']>;
    contractName: Scalars['String']['output'];
    createdAt: Scalars['String']['output'];
    /** Whether this contract versions has schema changes. */
    hasSchemaChanges: Scalars['Boolean']['output'];
    id: Scalars['ID']['output'];
    /** Whether this contract version is composable. */
    isComposable: Scalars['Boolean']['output'];
    isFirstComposableVersion: Scalars['Boolean']['output'];
    previousContractVersion?: Maybe<ContractVersion>;
    previousDiffableContractVersion?: Maybe<ContractVersion>;
    /** Safe schema changes for this contract version. */
    safeSchemaChanges?: Maybe<SchemaChangeConnection>;
    schemaChanges?: Maybe<SchemaChangeConnection>;
    schemaCompositionErrors?: Maybe<SchemaErrorConnection>;
    supergraphSDL?: Maybe<Scalars['String']['output']>;
};
export type ContractVersionConnection = {
    __typename?: 'ContractVersionConnection';
    edges: Array<ContractVersionEdge>;
    pageInfo: PageInfo;
};
export type ContractVersionEdge = {
    __typename?: 'ContractVersionEdge';
    cursor: Scalars['String']['output'];
    node: ContractVersion;
};
export type CreateAppDeploymentError = Error & {
    __typename?: 'CreateAppDeploymentError';
    details?: Maybe<CreateAppDeploymentErrorDetails>;
    message: Scalars['String']['output'];
};
export type CreateAppDeploymentErrorDetails = {
    __typename?: 'CreateAppDeploymentErrorDetails';
    /** Error message for the input app name. */
    appName?: Maybe<Scalars['String']['output']>;
    /** Error message for the input app version. */
    appVersion?: Maybe<Scalars['String']['output']>;
};
export type CreateAppDeploymentInput = {
    appName: Scalars['String']['input'];
    appVersion: Scalars['String']['input'];
    target?: InputMaybe<TargetReferenceInput>;
};
export type CreateAppDeploymentOk = {
    __typename?: 'CreateAppDeploymentOk';
    createdAppDeployment: AppDeployment;
};
export type CreateAppDeploymentResult = {
    __typename?: 'CreateAppDeploymentResult';
    error?: Maybe<CreateAppDeploymentError>;
    ok?: Maybe<CreateAppDeploymentOk>;
};
export type CreateCdnAccessTokenInput = {
    /** Alias describing the purpose of the access token. */
    alias: Scalars['String']['input'];
    /** The target for which the access token should be created for. */
    target: TargetReferenceInput;
};
export type CreateContractInput = {
    contractName: Scalars['String']['input'];
    excludeTags?: InputMaybe<Array<Scalars['String']['input']>>;
    includeTags?: InputMaybe<Array<Scalars['String']['input']>>;
    removeUnreachableTypesFromPublicApiSchema: Scalars['Boolean']['input'];
    target: TargetReferenceInput;
};
export type CreateContractInputErrors = {
    __typename?: 'CreateContractInputErrors';
    contractName?: Maybe<Scalars['String']['output']>;
    excludeTags?: Maybe<Scalars['String']['output']>;
    includeTags?: Maybe<Scalars['String']['output']>;
    target?: Maybe<Scalars['String']['output']>;
};
export type CreateContractResult = {
    __typename?: 'CreateContractResult';
    error?: Maybe<CreateContractResultError>;
    ok?: Maybe<CreateContractResultOk>;
};
export type CreateContractResultError = {
    __typename?: 'CreateContractResultError';
    details: CreateContractInputErrors;
    message: Scalars['String']['output'];
};
export type CreateContractResultOk = {
    __typename?: 'CreateContractResultOk';
    createdContract: Contract;
};
export type CreateDocumentCollectionInput = {
    description?: InputMaybe<Scalars['String']['input']>;
    name: Scalars['String']['input'];
};
export type CreateDocumentCollectionOperationInput = {
    collectionId: Scalars['ID']['input'];
    headers?: InputMaybe<Scalars['String']['input']>;
    name: Scalars['String']['input'];
    query: Scalars['String']['input'];
    variables?: InputMaybe<Scalars['String']['input']>;
};
export type CreateMemberRoleInput = {
    /** A description describing the purpose of the member role. */
    description: Scalars['String']['input'];
    /** The name of the member role (must be unique). */
    name: Scalars['String']['input'];
    /** The organization in which the member role should be created. */
    organization: OrganizationReferenceInput;
    /** A list of available permissions can be retrieved via the `Organization.availableMemberPermissionGroups` field. */
    selectedPermissions: Array<Scalars['String']['input']>;
};
export type CreateMemberRoleInputErrors = {
    __typename?: 'CreateMemberRoleInputErrors';
    description?: Maybe<Scalars['String']['output']>;
    name?: Maybe<Scalars['String']['output']>;
};
/** @oneOf */
export type CreateMemberRoleResult = {
    __typename?: 'CreateMemberRoleResult';
    error?: Maybe<CreateMemberRoleResultError>;
    ok?: Maybe<CreateMemberRoleResultOk>;
};
export type CreateMemberRoleResultError = {
    __typename?: 'CreateMemberRoleResultError';
    /** The detailed validation error messages for the input fields. */
    inputErrors?: Maybe<CreateMemberRoleInputErrors>;
    message: Scalars['String']['output'];
};
export type CreateMemberRoleResultOk = {
    __typename?: 'CreateMemberRoleResultOk';
    createdMemberRole: MemberRole;
    updatedOrganization: Organization;
};
export type CreateOidcIntegrationError = Error & {
    __typename?: 'CreateOIDCIntegrationError';
    details: CreateOidcIntegrationErrorDetails;
    message: Scalars['String']['output'];
};
export type CreateOidcIntegrationErrorDetails = {
    __typename?: 'CreateOIDCIntegrationErrorDetails';
    authorizationEndpoint?: Maybe<Scalars['String']['output']>;
    clientId?: Maybe<Scalars['String']['output']>;
    clientSecret?: Maybe<Scalars['String']['output']>;
    tokenEndpoint?: Maybe<Scalars['String']['output']>;
    userinfoEndpoint?: Maybe<Scalars['String']['output']>;
};
export type CreateOidcIntegrationInput = {
    authorizationEndpoint: Scalars['String']['input'];
    clientId: Scalars['ID']['input'];
    clientSecret: Scalars['String']['input'];
    organizationId: Scalars['ID']['input'];
    tokenEndpoint: Scalars['String']['input'];
    userinfoEndpoint: Scalars['String']['input'];
};
export type CreateOidcIntegrationOk = {
    __typename?: 'CreateOIDCIntegrationOk';
    createdOIDCIntegration: OidcIntegration;
    organization: Organization;
};
export type CreateOidcIntegrationResult = {
    __typename?: 'CreateOIDCIntegrationResult';
    error?: Maybe<CreateOidcIntegrationError>;
    ok?: Maybe<CreateOidcIntegrationOk>;
};
export type CreateOrganizationAccessTokenInput = {
    /** Additional description containing information about the purpose of the access token. */
    description?: InputMaybe<Scalars['String']['input']>;
    /** Organization in which the access token should be created. */
    organization: OrganizationReferenceInput;
    /**
     * List of permissions that are assigned to the access token.
     * A list of available permissions can be retrieved via the `Organization.availableOrganizationAccessTokenPermissionGroups` field.
     */
    permissions: Array<Scalars['String']['input']>;
    /**
     * Resources on which the permissions should be granted (project, target, service, and app deployments).
     * Permissions are inherited by sub-resources.
     */
    resources: ResourceAssignmentInput;
    /** Title of the access token. */
    title: Scalars['String']['input'];
};
export type CreateOrganizationAccessTokenResult = {
    __typename?: 'CreateOrganizationAccessTokenResult';
    error?: Maybe<CreateOrganizationAccessTokenResultError>;
    ok?: Maybe<CreateOrganizationAccessTokenResultOk>;
};
export type CreateOrganizationAccessTokenResultError = {
    __typename?: 'CreateOrganizationAccessTokenResultError';
    details?: Maybe<CreateOrganizationAccessTokenResultErrorDetails>;
    message: Scalars['String']['output'];
};
export type CreateOrganizationAccessTokenResultErrorDetails = {
    __typename?: 'CreateOrganizationAccessTokenResultErrorDetails';
    /** Error message for the input description. */
    description?: Maybe<Scalars['String']['output']>;
    /** Error message for the input title. */
    title?: Maybe<Scalars['String']['output']>;
};
export type CreateOrganizationAccessTokenResultOk = {
    __typename?: 'CreateOrganizationAccessTokenResultOk';
    createdOrganizationAccessToken: OrganizationAccessToken;
    privateAccessKey: Scalars['String']['output'];
};
export type CreateOrganizationError = Error & {
    __typename?: 'CreateOrganizationError';
    inputErrors: CreateOrganizationInputErrors;
    message: Scalars['String']['output'];
};
export type CreateOrganizationInput = {
    slug: Scalars['String']['input'];
};
export type CreateOrganizationInputErrors = {
    __typename?: 'CreateOrganizationInputErrors';
    slug?: Maybe<Scalars['String']['output']>;
};
export type CreateOrganizationOk = {
    __typename?: 'CreateOrganizationOk';
    createdOrganizationPayload: OrganizationPayload;
};
/** @oneOf */
export type CreateOrganizationResult = {
    __typename?: 'CreateOrganizationResult';
    error?: Maybe<CreateOrganizationError>;
    ok?: Maybe<CreateOrganizationOk>;
};
export type CreateProjectInput = {
    organization: OrganizationReferenceInput;
    slug: Scalars['String']['input'];
    type: ProjectType;
};
export type CreateProjectInputErrors = {
    __typename?: 'CreateProjectInputErrors';
    slug?: Maybe<Scalars['String']['output']>;
};
export type CreateProjectResult = {
    __typename?: 'CreateProjectResult';
    error?: Maybe<CreateProjectResultError>;
    ok?: Maybe<CreateProjectResultOk>;
};
export type CreateProjectResultError = {
    __typename?: 'CreateProjectResultError';
    inputErrors: CreateProjectInputErrors;
    message: Scalars['String']['output'];
};
export type CreateProjectResultOk = {
    __typename?: 'CreateProjectResultOk';
    createdProject: Project;
    createdTargets: Array<Target>;
    updatedOrganization: Organization;
};
export type CreateTargetInput = {
    /** Reference to the project in which the target should be created in. */
    project: ProjectReferenceInput;
    /** Slug of the target, must be unique per project. */
    slug: Scalars['String']['input'];
};
export type CreateTargetInputErrors = {
    __typename?: 'CreateTargetInputErrors';
    slug?: Maybe<Scalars['String']['output']>;
};
export type CreateTargetResult = {
    __typename?: 'CreateTargetResult';
    error?: Maybe<CreateTargetResultError>;
    ok?: Maybe<CreateTargetResultOk>;
};
export type CreateTargetResultError = {
    __typename?: 'CreateTargetResultError';
    inputErrors: CreateTargetInputErrors;
    message: Scalars['String']['output'];
};
export type CreateTargetResultOk = {
    __typename?: 'CreateTargetResultOk';
    createdTarget: Target;
    selector: TargetSelector;
};
export type CreateTokenError = Error & {
    __typename?: 'CreateTokenError';
    message: Scalars['String']['output'];
};
export type CreateTokenInput = {
    name: Scalars['String']['input'];
    organizationScopes: Array<OrganizationAccessScope>;
    organizationSlug: Scalars['String']['input'];
    projectScopes: Array<ProjectAccessScope>;
    projectSlug: Scalars['String']['input'];
    targetScopes: Array<TargetAccessScope>;
    targetSlug: Scalars['String']['input'];
};
export type CreateTokenOk = {
    __typename?: 'CreateTokenOk';
    createdToken: Token;
    secret: Scalars['String']['output'];
    selector: TargetSelector;
};
export type CreateTokenPayload = {
    __typename?: 'CreateTokenPayload';
    createdToken: Token;
    secret: Scalars['String']['output'];
    selector: TargetSelector;
};
export type CreateTokenResult = {
    __typename?: 'CreateTokenResult';
    error?: Maybe<CreateTokenError>;
    ok?: Maybe<CreateTokenOk>;
};
export declare enum CriticalityLevel {
    /** @deprecated Use 'SeverityLevelType' instead. This field will be removed once it is no longer in use by a client. */
    Breaking = "Breaking",
    /** @deprecated Use 'SeverityLevelType' instead. This field will be removed once it is no longer in use by a client. */
    Dangerous = "Dangerous",
    /** @deprecated Use 'SeverityLevelType' instead. This field will be removed once it is no longer in use by a client. */
    Safe = "Safe"
}
export type DateRange = {
    __typename?: 'DateRange';
    from: Scalars['DateTime']['output'];
    to: Scalars['DateTime']['output'];
};
/** Describes a date range interval. */
export type DateRangeInput = {
    from: Scalars['DateTime']['input'];
    to: Scalars['DateTime']['input'];
};
export type DeleteAlertChannelsError = Error & {
    __typename?: 'DeleteAlertChannelsError';
    message: Scalars['String']['output'];
};
export type DeleteAlertChannelsInput = {
    channelIds: Array<Scalars['ID']['input']>;
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
};
export type DeleteAlertChannelsOk = {
    __typename?: 'DeleteAlertChannelsOk';
    updatedProject: Project;
};
export type DeleteAlertChannelsResult = {
    __typename?: 'DeleteAlertChannelsResult';
    error?: Maybe<DeleteAlertChannelsError>;
    ok?: Maybe<DeleteAlertChannelsOk>;
};
export type DeleteAlertsError = Error & {
    __typename?: 'DeleteAlertsError';
    message: Scalars['String']['output'];
};
export type DeleteAlertsInput = {
    alertIds: Array<Scalars['ID']['input']>;
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
};
export type DeleteAlertsOk = {
    __typename?: 'DeleteAlertsOk';
    updatedProject: Project;
};
export type DeleteAlertsResult = {
    __typename?: 'DeleteAlertsResult';
    error?: Maybe<DeleteAlertsError>;
    ok?: Maybe<DeleteAlertsOk>;
};
export type DeleteCdnAccessTokenInput = {
    cdnAccessTokenId: Scalars['ID']['input'];
    target: TargetReferenceInput;
};
/** @oneOf */
export type DeleteCdnAccessTokenResult = {
    __typename?: 'DeleteCdnAccessTokenResult';
    error?: Maybe<DeleteCdnAccessTokenResultError>;
    ok?: Maybe<DeleteCdnAccessTokenResultOk>;
};
export type DeleteCdnAccessTokenResultError = {
    __typename?: 'DeleteCdnAccessTokenResultError';
    message: Scalars['String']['output'];
};
export type DeleteCdnAccessTokenResultOk = {
    __typename?: 'DeleteCdnAccessTokenResultOk';
    deletedCdnAccessTokenId: Scalars['ID']['output'];
};
export type DeleteDocumentCollectionOkPayload = {
    __typename?: 'DeleteDocumentCollectionOkPayload';
    deletedId: Scalars['ID']['output'];
    updatedTarget: Target;
};
export type DeleteDocumentCollectionOperationOkPayload = {
    __typename?: 'DeleteDocumentCollectionOperationOkPayload';
    deletedId: Scalars['ID']['output'];
    updatedCollection: DocumentCollection;
    updatedTarget: Target;
};
/** @oneOf */
export type DeleteDocumentCollectionOperationResult = {
    __typename?: 'DeleteDocumentCollectionOperationResult';
    error?: Maybe<ModifyDocumentCollectionError>;
    ok?: Maybe<DeleteDocumentCollectionOperationOkPayload>;
};
/** @oneOf */
export type DeleteDocumentCollectionResult = {
    __typename?: 'DeleteDocumentCollectionResult';
    error?: Maybe<ModifyDocumentCollectionError>;
    ok?: Maybe<DeleteDocumentCollectionOkPayload>;
};
export type DeleteGitHubIntegrationResult = {
    __typename?: 'DeleteGitHubIntegrationResult';
    organization: Organization;
};
export type DeleteMemberRoleInput = {
    memberRole: MemberRoleReferenceInput;
};
/** @oneOf */
export type DeleteMemberRoleResult = {
    __typename?: 'DeleteMemberRoleResult';
    error?: Maybe<DeleteMemberRoleResultError>;
    ok?: Maybe<DeleteMemberRoleResultOk>;
};
export type DeleteMemberRoleResultError = {
    __typename?: 'DeleteMemberRoleResultError';
    message: Scalars['String']['output'];
};
export type DeleteMemberRoleResultOk = {
    __typename?: 'DeleteMemberRoleResultOk';
    deletedMemberRoleId: Scalars['ID']['output'];
    updatedOrganization: Organization;
};
export type DeleteOidcIntegrationError = Error & {
    __typename?: 'DeleteOIDCIntegrationError';
    message: Scalars['String']['output'];
};
export type DeleteOidcIntegrationInput = {
    oidcIntegrationId: Scalars['ID']['input'];
};
export type DeleteOidcIntegrationOk = {
    __typename?: 'DeleteOIDCIntegrationOk';
    organization: Organization;
};
export type DeleteOidcIntegrationResult = {
    __typename?: 'DeleteOIDCIntegrationResult';
    error?: Maybe<DeleteOidcIntegrationError>;
    ok?: Maybe<DeleteOidcIntegrationOk>;
};
export type DeleteOrganizationAccessTokenInput = {
    /** The access token that should be deleted. */
    organizationAccessToken: OrganizationAccessTokenReference;
};
export type DeleteOrganizationAccessTokenResult = {
    __typename?: 'DeleteOrganizationAccessTokenResult';
    error?: Maybe<DeleteOrganizationAccessTokenResultError>;
    ok?: Maybe<DeleteOrganizationAccessTokenResultOk>;
};
export type DeleteOrganizationAccessTokenResultError = {
    __typename?: 'DeleteOrganizationAccessTokenResultError';
    message: Scalars['String']['output'];
};
export type DeleteOrganizationAccessTokenResultOk = {
    __typename?: 'DeleteOrganizationAccessTokenResultOk';
    deletedOrganizationAccessTokenId: Scalars['ID']['output'];
};
export type DeleteOrganizationInvitationInput = {
    email: Scalars['String']['input'];
    organization: OrganizationReferenceInput;
};
/** @oneOf */
export type DeleteOrganizationInvitationResult = {
    __typename?: 'DeleteOrganizationInvitationResult';
    error?: Maybe<DeleteOrganizationInvitationResultError>;
    ok?: Maybe<DeleteOrganizationInvitationResultOk>;
};
export type DeleteOrganizationInvitationResultError = {
    __typename?: 'DeleteOrganizationInvitationResultError';
    message: Scalars['String']['output'];
};
export type DeleteOrganizationInvitationResultOk = {
    __typename?: 'DeleteOrganizationInvitationResultOk';
    deletedOrganizationInvitationId: Scalars['ID']['output'];
};
export type DeleteProjectInput = {
    project: ProjectReferenceInput;
};
export type DeleteProjectResult = {
    __typename?: 'DeleteProjectResult';
    error?: Maybe<DeleteProjectResultError>;
    ok?: Maybe<DeleteProjectResultOk>;
};
export type DeleteProjectResultError = {
    __typename?: 'DeleteProjectResultError';
    message: Scalars['String']['output'];
};
export type DeleteProjectResultOk = {
    __typename?: 'DeleteProjectResultOk';
    deletedProjectId: Scalars['ID']['output'];
};
export type DeleteSlackIntegrationResult = {
    __typename?: 'DeleteSlackIntegrationResult';
    organization: Organization;
};
export type DeleteTargetInput = {
    /** Reference to the target that should be deleted. */
    target: TargetReferenceInput;
};
export type DeleteTargetPayload = {
    __typename?: 'DeleteTargetPayload';
    deletedTarget: Target;
    selector: TargetSelector;
};
export type DeleteTargetResult = {
    __typename?: 'DeleteTargetResult';
    error?: Maybe<DeleteTargetResultError>;
    ok?: Maybe<DeleteTargetResultOk>;
};
export type DeleteTargetResultError = {
    __typename?: 'DeleteTargetResultError';
    message: Scalars['String']['output'];
};
export type DeleteTargetResultOk = {
    __typename?: 'DeleteTargetResultOk';
    deletedTargetId: Scalars['ID']['output'];
};
export type DeleteTokensInput = {
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    targetSlug: Scalars['String']['input'];
    tokenIds: Array<Scalars['ID']['input']>;
};
export type DeleteTokensPayload = {
    __typename?: 'DeleteTokensPayload';
    deletedTokens: Array<Scalars['ID']['output']>;
    selector: TargetSelector;
};
export type DeletedSchemaLog = {
    __typename?: 'DeletedSchemaLog';
    date: Scalars['DateTime']['output'];
    /** The name of the service that got deleted. */
    deletedService: Scalars['String']['output'];
    id: Scalars['ID']['output'];
    /** The previous SDL of the full schema or subgraph. */
    previousServiceSdl?: Maybe<Scalars['String']['output']>;
};
export type DeprecatedSchemaExplorer = {
    __typename?: 'DeprecatedSchemaExplorer';
    types: Array<GraphQlNamedType>;
};
export type DeprecatedSchemaExplorerUsageInput = {
    period: DateRangeInput;
};
export type DisableContractInput = {
    contract: ContractReferenceInput;
};
export type DisableContractResult = {
    __typename?: 'DisableContractResult';
    error?: Maybe<DisableContractResultError>;
    ok?: Maybe<DisableContractResultOk>;
};
export type DisableContractResultError = {
    __typename?: 'DisableContractResultError';
    message: Scalars['String']['output'];
};
export type DisableContractResultOk = {
    __typename?: 'DisableContractResultOk';
    disabledContract: Contract;
};
export type DisableExternalSchemaCompositionInput = {
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
};
/** @oneOf */
export type DisableExternalSchemaCompositionResult = {
    __typename?: 'DisableExternalSchemaCompositionResult';
    error?: Maybe<Scalars['String']['output']>;
    ok?: Maybe<Project>;
};
export type DocumentCollection = {
    __typename?: 'DocumentCollection';
    createdAt: Scalars['DateTime']['output'];
    description?: Maybe<Scalars['String']['output']>;
    id: Scalars['ID']['output'];
    name: Scalars['String']['output'];
    operations: DocumentCollectionOperationsConnection;
    updatedAt: Scalars['DateTime']['output'];
};
export type DocumentCollectionOperationsArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
};
export type DocumentCollectionConnection = {
    __typename?: 'DocumentCollectionConnection';
    edges: Array<DocumentCollectionEdge>;
    pageInfo: PageInfo;
};
export type DocumentCollectionEdge = {
    __typename?: 'DocumentCollectionEdge';
    cursor: Scalars['String']['output'];
    node: DocumentCollection;
};
export type DocumentCollectionOperation = {
    __typename?: 'DocumentCollectionOperation';
    collection: DocumentCollection;
    createdAt: Scalars['DateTime']['output'];
    headers?: Maybe<Scalars['String']['output']>;
    id: Scalars['ID']['output'];
    name: Scalars['String']['output'];
    query: Scalars['String']['output'];
    updatedAt: Scalars['DateTime']['output'];
    variables?: Maybe<Scalars['String']['output']>;
};
export type DocumentCollectionOperationEdge = {
    __typename?: 'DocumentCollectionOperationEdge';
    cursor: Scalars['String']['output'];
    node: DocumentCollectionOperation;
};
export type DocumentCollectionOperationsConnection = {
    __typename?: 'DocumentCollectionOperationsConnection';
    edges: Array<DocumentCollectionOperationEdge>;
    pageInfo: PageInfo;
};
export type DocumentInput = {
    /** GraphQL operation body. */
    body: Scalars['String']['input'];
    /** GraphQL operation hash. */
    hash: Scalars['String']['input'];
};
export type DowngradeToHobbyInput = {
    organization: OrganizationSelectorInput;
};
export type DurationOverTime = {
    __typename?: 'DurationOverTime';
    date: Scalars['DateTime']['output'];
    duration: DurationValues;
};
export type DurationValues = {
    __typename?: 'DurationValues';
    avg: Scalars['Int']['output'];
    p75: Scalars['Int']['output'];
    p90: Scalars['Int']['output'];
    p95: Scalars['Int']['output'];
    p99: Scalars['Int']['output'];
};
export type EnableExternalSchemaCompositionError = Error & {
    __typename?: 'EnableExternalSchemaCompositionError';
    /** The detailed validation error messages for the input fields. */
    inputErrors: EnableExternalSchemaCompositionInputErrors;
    message: Scalars['String']['output'];
};
export type EnableExternalSchemaCompositionInput = {
    endpoint: Scalars['String']['input'];
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    secret: Scalars['String']['input'];
};
export type EnableExternalSchemaCompositionInputErrors = {
    __typename?: 'EnableExternalSchemaCompositionInputErrors';
    endpoint?: Maybe<Scalars['String']['output']>;
    secret?: Maybe<Scalars['String']['output']>;
};
/** @oneOf */
export type EnableExternalSchemaCompositionResult = {
    __typename?: 'EnableExternalSchemaCompositionResult';
    error?: Maybe<EnableExternalSchemaCompositionError>;
    ok?: Maybe<Project>;
};
export type Error = {
    message: Scalars['String']['output'];
};
export type Experimental__UpdateTargetSchemaCompositionInput = {
    nativeComposition: Scalars['Boolean']['input'];
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    targetSlug: Scalars['String']['input'];
};
export type ExportOrganizationAuditLogError = Error & {
    __typename?: 'ExportOrganizationAuditLogError';
    message: Scalars['String']['output'];
};
export type ExportOrganizationAuditLogInput = {
    filter: AuditLogFilter;
    selector: OrganizationSelectorInput;
};
export type ExportOrganizationAuditLogPayload = {
    __typename?: 'ExportOrganizationAuditLogPayload';
    url: Scalars['String']['output'];
};
export type ExportOrganizationAuditLogResult = {
    __typename?: 'ExportOrganizationAuditLogResult';
    error?: Maybe<ExportOrganizationAuditLogError>;
    ok?: Maybe<ExportOrganizationAuditLogPayload>;
};
export type ExternalSchemaComposition = {
    __typename?: 'ExternalSchemaComposition';
    endpoint: Scalars['String']['output'];
};
/** A failed schema check. */
export type FailedSchemaCheck = SchemaCheck & {
    __typename?: 'FailedSchemaCheck';
    breakingSchemaChanges?: Maybe<SchemaChangeConnection>;
    /** Whether this schema check can be approved manually. */
    canBeApproved: Scalars['Boolean']['output'];
    /** Whether this schema check can be approved by the viewer. */
    canBeApprovedByViewer: Scalars['Boolean']['output'];
    compositeSchemaSDL?: Maybe<Scalars['String']['output']>;
    compositionErrors?: Maybe<SchemaErrorConnection>;
    /** Conditional breaking change metadata. */
    conditionalBreakingChangeMetadata?: Maybe<SchemaCheckConditionalBreakingChangeMetadata>;
    /** Optional context ID to group schema checks together. */
    contextId?: Maybe<Scalars['String']['output']>;
    /** Results of the contracts */
    contractChecks?: Maybe<ContractCheckConnection>;
    createdAt: Scalars['String']['output'];
    /** The GitHub repository associated with the schema check. */
    githubRepository?: Maybe<Scalars['String']['output']>;
    /** Whether this schema check has any schema changes. */
    hasSchemaChanges: Scalars['Boolean']['output'];
    /** Whether this schema check has any composition errors. */
    hasSchemaCompositionErrors: Scalars['Boolean']['output'];
    /** Whether this schema check has any breaking changes. */
    hasUnapprovedBreakingChanges: Scalars['Boolean']['output'];
    id: Scalars['ID']['output'];
    /** Meta information about the schema check. */
    meta?: Maybe<SchemaCheckMeta>;
    /** The previous schema SDL. For composite schemas this is the service. */
    previousSchemaSDL?: Maybe<Scalars['String']['output']>;
    safeSchemaChanges?: Maybe<SchemaChangeConnection>;
    schemaChanges?: Maybe<SchemaChangeConnection>;
    schemaPolicyErrors?: Maybe<SchemaPolicyWarningConnection>;
    schemaPolicyWarnings?: Maybe<SchemaPolicyWarningConnection>;
    /** The SDL of the schema that was checked. */
    schemaSDL: Scalars['String']['output'];
    /**
     * The schema version against this check was performed.
     * Is null if there is no schema version published yet.
     */
    schemaVersion?: Maybe<SchemaVersion>;
    /** The name of the service that owns the schema. Is null for non composite project types. */
    serviceName?: Maybe<Scalars['String']['output']>;
    supergraphSDL?: Maybe<Scalars['String']['output']>;
    /** The URL of the schema check on the Hive Web App. */
    webUrl?: Maybe<Scalars['String']['output']>;
};
export type FailuresOverTime = {
    __typename?: 'FailuresOverTime';
    date: Scalars['DateTime']['output'];
    value: Scalars['SafeInt']['output'];
};
export type FieldListStatsInput = {
    fields: Array<FieldTypePairInput>;
    operationHash?: InputMaybe<Scalars['String']['input']>;
    organizationSlug: Scalars['String']['input'];
    period: DateRangeInput;
    projectSlug: Scalars['String']['input'];
    targetSlug: Scalars['String']['input'];
};
export type FieldStatsInput = {
    argument?: InputMaybe<Scalars['String']['input']>;
    field: Scalars['String']['input'];
    operationHash?: InputMaybe<Scalars['String']['input']>;
    organizationSlug: Scalars['String']['input'];
    period: DateRangeInput;
    projectSlug: Scalars['String']['input'];
    targetSlug: Scalars['String']['input'];
    type: Scalars['String']['input'];
};
export type FieldStatsValues = {
    __typename?: 'FieldStatsValues';
    argument?: Maybe<Scalars['String']['output']>;
    count: Scalars['SafeInt']['output'];
    field: Scalars['String']['output'];
    percentage: Scalars['Float']['output'];
    type: Scalars['String']['output'];
};
export type FieldTypePairInput = {
    argument?: InputMaybe<Scalars['String']['input']>;
    field: Scalars['String']['input'];
    type: Scalars['String']['input'];
};
export type GitHubIntegration = {
    __typename?: 'GitHubIntegration';
    repositories: Array<GitHubRepository>;
};
export type GitHubRepository = {
    __typename?: 'GitHubRepository';
    nameWithOwner: Scalars['String']['output'];
};
export type GitHubSchemaCheckError = {
    __typename?: 'GitHubSchemaCheckError';
    message: Scalars['String']['output'];
};
export type GitHubSchemaCheckInput = {
    commit: Scalars['String']['input'];
    /** The pull request number of the schema check. */
    pullRequestNumber?: InputMaybe<Scalars['String']['input']>;
    /** The repository name of the schema check. */
    repository?: InputMaybe<Scalars['String']['input']>;
};
export type GitHubSchemaCheckSuccess = {
    __typename?: 'GitHubSchemaCheckSuccess';
    message: Scalars['String']['output'];
};
export type GitHubSchemaPublishError = {
    __typename?: 'GitHubSchemaPublishError';
    message: Scalars['String']['output'];
};
export type GitHubSchemaPublishSuccess = {
    __typename?: 'GitHubSchemaPublishSuccess';
    message: Scalars['String']['output'];
};
export type GraphQlArgument = {
    __typename?: 'GraphQLArgument';
    defaultValue?: Maybe<Scalars['String']['output']>;
    deprecationReason?: Maybe<Scalars['String']['output']>;
    description?: Maybe<Scalars['String']['output']>;
    isDeprecated: Scalars['Boolean']['output'];
    name: Scalars['String']['output'];
    type: Scalars['String']['output'];
    usage: SchemaCoordinateUsage;
};
export type GraphQlDocument = {
    __typename?: 'GraphQLDocument';
    body: Scalars['String']['output'];
    hash: Scalars['String']['output'];
    /** The internal hash as used for insights. */
    insightsHash: Scalars['String']['output'];
    operationName?: Maybe<Scalars['String']['output']>;
};
export type GraphQlDocumentConnection = {
    __typename?: 'GraphQLDocumentConnection';
    edges: Array<GraphQlDocumentEdge>;
    pageInfo: PageInfo;
};
export type GraphQlDocumentEdge = {
    __typename?: 'GraphQLDocumentEdge';
    cursor: Scalars['String']['output'];
    node: GraphQlDocument;
};
export type GraphQlEnumType = {
    __typename?: 'GraphQLEnumType';
    deprecationReason?: Maybe<Scalars['String']['output']>;
    description?: Maybe<Scalars['String']['output']>;
    name: Scalars['String']['output'];
    /**
     * Metadata specific to Apollo Federation Projects.
     * Is null if no meta information is available.
     */
    supergraphMetadata?: Maybe<SupergraphMetadata>;
    usage: SchemaCoordinateUsage;
    values: Array<GraphQlEnumValue>;
};
export type GraphQlEnumValue = {
    __typename?: 'GraphQLEnumValue';
    deprecationReason?: Maybe<Scalars['String']['output']>;
    description?: Maybe<Scalars['String']['output']>;
    isDeprecated: Scalars['Boolean']['output'];
    name: Scalars['String']['output'];
    /**
     * Metadata specific to Apollo Federation Projects.
     * Is null if no meta information is available.
     */
    supergraphMetadata?: Maybe<SupergraphMetadata>;
    usage: SchemaCoordinateUsage;
};
export type GraphQlField = {
    __typename?: 'GraphQLField';
    args: Array<GraphQlArgument>;
    deprecationReason?: Maybe<Scalars['String']['output']>;
    description?: Maybe<Scalars['String']['output']>;
    isDeprecated: Scalars['Boolean']['output'];
    name: Scalars['String']['output'];
    /**
     * Metadata specific to Apollo Federation Projects.
     * Is null if no meta information is available.
     */
    supergraphMetadata?: Maybe<SupergraphMetadata>;
    type: Scalars['String']['output'];
    usage: SchemaCoordinateUsage;
};
export type GraphQlInputField = {
    __typename?: 'GraphQLInputField';
    defaultValue?: Maybe<Scalars['String']['output']>;
    deprecationReason?: Maybe<Scalars['String']['output']>;
    description?: Maybe<Scalars['String']['output']>;
    isDeprecated: Scalars['Boolean']['output'];
    name: Scalars['String']['output'];
    /**
     * Metadata specific to Apollo Federation Projects.
     * Is null if no meta information is available (e.g. this is not an apollo federation project).
     */
    supergraphMetadata?: Maybe<SupergraphMetadata>;
    type: Scalars['String']['output'];
    usage: SchemaCoordinateUsage;
};
export type GraphQlInputObjectType = {
    __typename?: 'GraphQLInputObjectType';
    description?: Maybe<Scalars['String']['output']>;
    fields: Array<GraphQlInputField>;
    name: Scalars['String']['output'];
    /**
     * Metadata specific to Apollo Federation Projects.
     * Is null if no meta information is available (e.g. this is not an apollo federation project).
     */
    supergraphMetadata?: Maybe<SupergraphMetadata>;
    usage: SchemaCoordinateUsage;
};
export type GraphQlInterfaceType = {
    __typename?: 'GraphQLInterfaceType';
    description?: Maybe<Scalars['String']['output']>;
    fields: Array<GraphQlField>;
    interfaces: Array<Scalars['String']['output']>;
    name: Scalars['String']['output'];
    /**
     * Metadata specific to Apollo Federation Projects.
     * Is null if no meta information is available.
     */
    supergraphMetadata?: Maybe<SupergraphMetadata>;
    usage: SchemaCoordinateUsage;
};
export type GraphQlNamedType = GraphQlEnumType | GraphQlInputObjectType | GraphQlInterfaceType | GraphQlObjectType | GraphQlScalarType | GraphQlUnionType;
export type GraphQlObjectType = {
    __typename?: 'GraphQLObjectType';
    description?: Maybe<Scalars['String']['output']>;
    fields: Array<GraphQlField>;
    interfaces: Array<Scalars['String']['output']>;
    name: Scalars['String']['output'];
    /**
     * Metadata specific to Apollo Federation Projects.
     * Is null if no meta information is available (e.g. this is not an apollo federation project).
     */
    supergraphMetadata?: Maybe<SupergraphMetadata>;
    usage: SchemaCoordinateUsage;
};
export declare enum GraphQlOperationType {
    Mutation = "MUTATION",
    Query = "QUERY",
    Subscription = "SUBSCRIPTION"
}
export type GraphQlScalarType = {
    __typename?: 'GraphQLScalarType';
    description?: Maybe<Scalars['String']['output']>;
    name: Scalars['String']['output'];
    /**
     * Metadata specific to Apollo Federation Projects.
     * Is null if no meta information is available (e.g. this is not an apollo federation project).
     */
    supergraphMetadata?: Maybe<SupergraphMetadata>;
    usage: SchemaCoordinateUsage;
};
export type GraphQlUnionType = {
    __typename?: 'GraphQLUnionType';
    description?: Maybe<Scalars['String']['output']>;
    members: Array<GraphQlUnionTypeMember>;
    name: Scalars['String']['output'];
    /**
     * Metadata specific to Apollo Federation Projects.
     * Is null if no meta information is available (e.g. this is not an apollo federation project).
     */
    supergraphMetadata?: Maybe<SupergraphMetadata>;
    usage: SchemaCoordinateUsage;
};
export type GraphQlUnionTypeMember = {
    __typename?: 'GraphQLUnionTypeMember';
    name: Scalars['String']['output'];
    /**
     * Metadata specific to Apollo Federation Projects.
     * Is null if no meta information is available (e.g. this is not an apollo federation project).
     */
    supergraphMetadata?: Maybe<SupergraphMetadata>;
    usage: SchemaCoordinateUsage;
};
export type InviteToOrganizationByEmailInput = {
    email: Scalars['String']['input'];
    memberRoleId?: InputMaybe<Scalars['ID']['input']>;
    organization: OrganizationReferenceInput;
};
export type InviteToOrganizationByEmailInputErrors = {
    __typename?: 'InviteToOrganizationByEmailInputErrors';
    email?: Maybe<Scalars['String']['output']>;
};
/** @oneOf */
export type InviteToOrganizationByEmailResult = {
    __typename?: 'InviteToOrganizationByEmailResult';
    error?: Maybe<InviteToOrganizationByEmailResultError>;
    ok?: Maybe<InviteToOrganizationByEmailResultOk>;
};
export type InviteToOrganizationByEmailResultError = {
    __typename?: 'InviteToOrganizationByEmailResultError';
    /** The detailed validation error messages for the input fields. */
    inputErrors: InviteToOrganizationByEmailInputErrors;
    message: Scalars['String']['output'];
};
export type InviteToOrganizationByEmailResultOk = {
    __typename?: 'InviteToOrganizationByEmailResultOk';
    createdOrganizationInvitation: OrganizationInvitation;
};
export type JoinOrganizationPayload = OrganizationInvitationError | OrganizationPayload;
export type Lab = {
    __typename?: 'Lab';
    mocks?: Maybe<Scalars['JSON']['output']>;
    schema: Scalars['String']['output'];
};
export type LeaveOrganizationError = Error & {
    __typename?: 'LeaveOrganizationError';
    message: Scalars['String']['output'];
};
export type LeaveOrganizationOk = {
    __typename?: 'LeaveOrganizationOk';
    organizationId: Scalars['ID']['output'];
};
/** @oneOf */
export type LeaveOrganizationResult = {
    __typename?: 'LeaveOrganizationResult';
    error?: Maybe<LeaveOrganizationError>;
    ok?: Maybe<LeaveOrganizationOk>;
};
export type Member = {
    __typename?: 'Member';
    canLeaveOrganization: Scalars['Boolean']['output'];
    id: Scalars['ID']['output'];
    isOwner: Scalars['Boolean']['output'];
    resourceAssignment: ResourceAssignment;
    role: MemberRole;
    user: User;
    /** Whether the viewer can remove this member from the organization. */
    viewerCanRemove: Scalars['Boolean']['output'];
};
export type MemberConnection = {
    __typename?: 'MemberConnection';
    edges: Array<MemberEdge>;
    pageInfo: PageInfo;
};
export type MemberEdge = {
    __typename?: 'MemberEdge';
    cursor: Scalars['String']['output'];
    node: Member;
};
export type MemberReferenceInput = {
    byId: Scalars['ID']['input'];
};
export type MemberRole = {
    __typename?: 'MemberRole';
    /** Whether the role can be deleted (based on current user's permissions) */
    canDelete: Scalars['Boolean']['output'];
    /** Whether the role can be used to invite new members (based on current user's permissions) */
    canInvite: Scalars['Boolean']['output'];
    /** Whether the role can be updated (based on current user's permissions) */
    canUpdate: Scalars['Boolean']['output'];
    description: Scalars['String']['output'];
    id: Scalars['ID']['output'];
    /** Whether the role is a built-in role. Built-in roles cannot be deleted or modified. */
    isLocked: Scalars['Boolean']['output'];
    /** Amount of users within the organization that have this role assigned. */
    membersCount: Scalars['Int']['output'];
    name: Scalars['String']['output'];
    /** List of permissions attached to this member role. */
    permissions: Array<Scalars['String']['output']>;
};
export type MemberRoleConnection = {
    __typename?: 'MemberRoleConnection';
    edges: Array<MemberRoleEdge>;
    pageInfo: PageInfo;
};
export type MemberRoleEdge = {
    __typename?: 'MemberRoleEdge';
    cursor: Scalars['String']['output'];
    node: MemberRole;
};
export type MemberRoleReferenceInput = {
    byId: Scalars['ID']['input'];
};
export type MetadataAttribute = {
    __typename?: 'MetadataAttribute';
    name: Scalars['String']['output'];
    values: Array<Scalars['String']['output']>;
};
export type ModifyDocumentCollectionError = Error & {
    __typename?: 'ModifyDocumentCollectionError';
    message: Scalars['String']['output'];
};
export type ModifyDocumentCollectionOkPayload = {
    __typename?: 'ModifyDocumentCollectionOkPayload';
    collection: DocumentCollection;
    updatedTarget: Target;
};
export type ModifyDocumentCollectionOperationOkPayload = {
    __typename?: 'ModifyDocumentCollectionOperationOkPayload';
    collection: DocumentCollection;
    operation: DocumentCollectionOperation;
    updatedTarget: Target;
};
/** @oneOf */
export type ModifyDocumentCollectionOperationResult = {
    __typename?: 'ModifyDocumentCollectionOperationResult';
    error?: Maybe<ModifyDocumentCollectionError>;
    ok?: Maybe<ModifyDocumentCollectionOperationOkPayload>;
};
/** @oneOf */
export type ModifyDocumentCollectionResult = {
    __typename?: 'ModifyDocumentCollectionResult';
    error?: Maybe<ModifyDocumentCollectionError>;
    ok?: Maybe<ModifyDocumentCollectionOkPayload>;
};
export type MonthlyUsage = {
    __typename?: 'MonthlyUsage';
    /** Start of the month in 1992-10-21 format */
    date: Scalars['Date']['output'];
    total: Scalars['SafeInt']['output'];
};
export type Mutation = {
    __typename?: 'Mutation';
    activateAppDeployment: ActivateAppDeploymentResult;
    addAlert: AddAlertResult;
    addAlertChannel: AddAlertChannelResult;
    addDocumentsToAppDeployment: AddDocumentsToAppDeploymentResult;
    addGitHubIntegration: Scalars['Boolean']['output'];
    addSlackIntegration: Scalars['Boolean']['output'];
    answerOrganizationTransferRequest: AnswerOrganizationTransferRequestResult;
    /** Approve a failed schema check with breaking changes. */
    approveFailedSchemaCheck: ApproveFailedSchemaCheckResult;
    assignMemberRole: AssignMemberRoleResult;
    createAppDeployment: CreateAppDeploymentResult;
    /** Create a CDN access token for a target. */
    createCdnAccessToken: CdnAccessTokenCreateResult;
    /** Create a contract for a given target. */
    createContract: CreateContractResult;
    createDocumentCollection: ModifyDocumentCollectionResult;
    /** Create a new member role with permissions. */
    createMemberRole: CreateMemberRoleResult;
    createOIDCIntegration: CreateOidcIntegrationResult;
    createOperationInDocumentCollection: ModifyDocumentCollectionOperationResult;
    createOrganization: CreateOrganizationResult;
    createOrganizationAccessToken: CreateOrganizationAccessTokenResult;
    createProject: CreateProjectResult;
    /** Create a new target within an existing project. */
    createTarget: CreateTargetResult;
    createToken: CreateTokenResult;
    deleteAlertChannels: DeleteAlertChannelsResult;
    deleteAlerts: DeleteAlertsResult;
    /** Delete a CDN access token. */
    deleteCdnAccessToken: DeleteCdnAccessTokenResult;
    deleteDocumentCollection: DeleteDocumentCollectionResult;
    deleteGitHubIntegration: DeleteGitHubIntegrationResult;
    deleteMemberRole: DeleteMemberRoleResult;
    deleteOIDCIntegration: DeleteOidcIntegrationResult;
    deleteOperationInDocumentCollection: DeleteDocumentCollectionOperationResult;
    deleteOrganization: OrganizationPayload;
    deleteOrganizationAccessToken: DeleteOrganizationAccessTokenResult;
    deleteOrganizationInvitation: DeleteOrganizationInvitationResult;
    deleteOrganizationMember: OrganizationPayload;
    deleteProject: DeleteProjectResult;
    deleteSlackIntegration: DeleteSlackIntegrationResult;
    /** Delete a target. */
    deleteTarget: DeleteTargetResult;
    deleteTokens: DeleteTokensPayload;
    /** Disable a contract. */
    disableContract: DisableContractResult;
    disableExternalSchemaComposition: DisableExternalSchemaCompositionResult;
    downgradeToHobby: ChangePlanResult;
    enableExternalSchemaComposition: EnableExternalSchemaCompositionResult;
    enableProjectNameInGithubCheck: Project;
    /**
     * Overwrites project's schema composition library.
     * Works only for Federation projects with native composition enabled.
     * This mutation is temporary and will be removed once no longer needed.
     * It's part of a feature flag called "forceLegacyCompositionInTargets".
     */
    experimental__updateTargetSchemaComposition: Target;
    exportOrganizationAuditLog: ExportOrganizationAuditLogResult;
    generateStripePortalLink: Scalars['String']['output'];
    inviteToOrganizationByEmail: InviteToOrganizationByEmailResult;
    joinOrganization: JoinOrganizationPayload;
    leaveOrganization: LeaveOrganizationResult;
    requestOrganizationTransfer: RequestOrganizationTransferResult;
    retireAppDeployment: RetireAppDeploymentResult;
    schemaCheck: SchemaCheckPayload;
    schemaCompose: SchemaComposePayload;
    schemaDelete: SchemaDeleteResult;
    schemaPublish: SchemaPublishPayload;
    supportTicketCreate: SupportTicketCreateResult;
    supportTicketReply: SupportTicketReplyResult;
    updateBaseSchema: UpdateBaseSchemaResult;
    updateDocumentCollection: ModifyDocumentCollectionResult;
    updateMe: UpdateMeResult;
    updateMemberRole: UpdateMemberRoleResult;
    updateNativeFederation: UpdateNativeFederationResult;
    updateOIDCDefaultMemberRole: UpdateOidcDefaultMemberRoleResult;
    updateOIDCIntegration: UpdateOidcIntegrationResult;
    updateOIDCRestrictions: UpdateOidcRestrictionsResult;
    updateOperationInDocumentCollection: ModifyDocumentCollectionOperationResult;
    updateOrgRateLimit: Organization;
    updateOrganizationSlug: UpdateOrganizationSlugResult;
    updatePreflightScript: PreflightScriptResult;
    updateProjectSlug: UpdateProjectSlugResult;
    updateSchemaPolicyForOrganization: UpdateSchemaPolicyResult;
    updateSchemaPolicyForProject: UpdateSchemaPolicyResult;
    /** Update the conditional breaking change configuration of a target. */
    updateTargetConditionalBreakingChangeConfiguration: UpdateTargetConditionalBreakingChangeConfigurationResult;
    /**
     * Update the targets dangerous change classification settings.
     * This allows dangerous changes fail schema checks.
     */
    updateTargetDangerousChangeClassification: UpdateTargetDangerousChangeClassificationResult;
    /** Updates the target's explorer endpoint url. */
    updateTargetGraphQLEndpointUrl: UpdateTargetGraphQlEndpointUrlResult;
    /** Update the slug of a traget. */
    updateTargetSlug: UpdateTargetSlugResult;
    upgradeToPro: ChangePlanResult;
};
export type MutationActivateAppDeploymentArgs = {
    input: ActivateAppDeploymentInput;
};
export type MutationAddAlertArgs = {
    input: AddAlertInput;
};
export type MutationAddAlertChannelArgs = {
    input: AddAlertChannelInput;
};
export type MutationAddDocumentsToAppDeploymentArgs = {
    input: AddDocumentsToAppDeploymentInput;
};
export type MutationAddGitHubIntegrationArgs = {
    input: AddGitHubIntegrationInput;
};
export type MutationAddSlackIntegrationArgs = {
    input: AddSlackIntegrationInput;
};
export type MutationAnswerOrganizationTransferRequestArgs = {
    input: AnswerOrganizationTransferRequestInput;
};
export type MutationApproveFailedSchemaCheckArgs = {
    input: ApproveFailedSchemaCheckInput;
};
export type MutationAssignMemberRoleArgs = {
    input: AssignMemberRoleInput;
};
export type MutationCreateAppDeploymentArgs = {
    input: CreateAppDeploymentInput;
};
export type MutationCreateCdnAccessTokenArgs = {
    input: CreateCdnAccessTokenInput;
};
export type MutationCreateContractArgs = {
    input: CreateContractInput;
};
export type MutationCreateDocumentCollectionArgs = {
    input: CreateDocumentCollectionInput;
    selector: TargetSelectorInput;
};
export type MutationCreateMemberRoleArgs = {
    input: CreateMemberRoleInput;
};
export type MutationCreateOidcIntegrationArgs = {
    input: CreateOidcIntegrationInput;
};
export type MutationCreateOperationInDocumentCollectionArgs = {
    input: CreateDocumentCollectionOperationInput;
    selector: TargetSelectorInput;
};
export type MutationCreateOrganizationArgs = {
    input: CreateOrganizationInput;
};
export type MutationCreateOrganizationAccessTokenArgs = {
    input: CreateOrganizationAccessTokenInput;
};
export type MutationCreateProjectArgs = {
    input: CreateProjectInput;
};
export type MutationCreateTargetArgs = {
    input: CreateTargetInput;
};
export type MutationCreateTokenArgs = {
    input: CreateTokenInput;
};
export type MutationDeleteAlertChannelsArgs = {
    input: DeleteAlertChannelsInput;
};
export type MutationDeleteAlertsArgs = {
    input: DeleteAlertsInput;
};
export type MutationDeleteCdnAccessTokenArgs = {
    input: DeleteCdnAccessTokenInput;
};
export type MutationDeleteDocumentCollectionArgs = {
    id: Scalars['ID']['input'];
    selector: TargetSelectorInput;
};
export type MutationDeleteGitHubIntegrationArgs = {
    input: OrganizationSelectorInput;
};
export type MutationDeleteMemberRoleArgs = {
    input: DeleteMemberRoleInput;
};
export type MutationDeleteOidcIntegrationArgs = {
    input: DeleteOidcIntegrationInput;
};
export type MutationDeleteOperationInDocumentCollectionArgs = {
    id: Scalars['ID']['input'];
    selector: TargetSelectorInput;
};
export type MutationDeleteOrganizationArgs = {
    selector: OrganizationSelectorInput;
};
export type MutationDeleteOrganizationAccessTokenArgs = {
    input: DeleteOrganizationAccessTokenInput;
};
export type MutationDeleteOrganizationInvitationArgs = {
    input: DeleteOrganizationInvitationInput;
};
export type MutationDeleteOrganizationMemberArgs = {
    input: OrganizationMemberInput;
};
export type MutationDeleteProjectArgs = {
    input: DeleteProjectInput;
};
export type MutationDeleteSlackIntegrationArgs = {
    input: OrganizationSelectorInput;
};
export type MutationDeleteTargetArgs = {
    input: DeleteTargetInput;
};
export type MutationDeleteTokensArgs = {
    input: DeleteTokensInput;
};
export type MutationDisableContractArgs = {
    input: DisableContractInput;
};
export type MutationDisableExternalSchemaCompositionArgs = {
    input: DisableExternalSchemaCompositionInput;
};
export type MutationDowngradeToHobbyArgs = {
    input: DowngradeToHobbyInput;
};
export type MutationEnableExternalSchemaCompositionArgs = {
    input: EnableExternalSchemaCompositionInput;
};
export type MutationEnableProjectNameInGithubCheckArgs = {
    input: ProjectSelectorInput;
};
export type MutationExperimental__UpdateTargetSchemaCompositionArgs = {
    input: Experimental__UpdateTargetSchemaCompositionInput;
};
export type MutationExportOrganizationAuditLogArgs = {
    input: ExportOrganizationAuditLogInput;
};
export type MutationGenerateStripePortalLinkArgs = {
    selector: OrganizationSelectorInput;
};
export type MutationInviteToOrganizationByEmailArgs = {
    input: InviteToOrganizationByEmailInput;
};
export type MutationJoinOrganizationArgs = {
    code: Scalars['String']['input'];
};
export type MutationLeaveOrganizationArgs = {
    input: OrganizationSelectorInput;
};
export type MutationRequestOrganizationTransferArgs = {
    input: RequestOrganizationTransferInput;
};
export type MutationRetireAppDeploymentArgs = {
    input: RetireAppDeploymentInput;
};
export type MutationSchemaCheckArgs = {
    input: SchemaCheckInput;
};
export type MutationSchemaComposeArgs = {
    input: SchemaComposeInput;
};
export type MutationSchemaDeleteArgs = {
    input: SchemaDeleteInput;
};
export type MutationSchemaPublishArgs = {
    input: SchemaPublishInput;
};
export type MutationSupportTicketCreateArgs = {
    input: SupportTicketCreateInput;
};
export type MutationSupportTicketReplyArgs = {
    input: SupportTicketReplyInput;
};
export type MutationUpdateBaseSchemaArgs = {
    input: UpdateBaseSchemaInput;
};
export type MutationUpdateDocumentCollectionArgs = {
    input: UpdateDocumentCollectionInput;
    selector: TargetSelectorInput;
};
export type MutationUpdateMeArgs = {
    input: UpdateMeInput;
};
export type MutationUpdateMemberRoleArgs = {
    input: UpdateMemberRoleInput;
};
export type MutationUpdateNativeFederationArgs = {
    input: UpdateNativeFederationInput;
};
export type MutationUpdateOidcDefaultMemberRoleArgs = {
    input: UpdateOidcDefaultMemberRoleInput;
};
export type MutationUpdateOidcIntegrationArgs = {
    input: UpdateOidcIntegrationInput;
};
export type MutationUpdateOidcRestrictionsArgs = {
    input: UpdateOidcRestrictionsInput;
};
export type MutationUpdateOperationInDocumentCollectionArgs = {
    input: UpdateDocumentCollectionOperationInput;
    selector: TargetSelectorInput;
};
export type MutationUpdateOrgRateLimitArgs = {
    monthlyLimits: RateLimitInput;
    selector: OrganizationSelectorInput;
};
export type MutationUpdateOrganizationSlugArgs = {
    input: UpdateOrganizationSlugInput;
};
export type MutationUpdatePreflightScriptArgs = {
    input: UpdatePreflightScriptInput;
};
export type MutationUpdateProjectSlugArgs = {
    input: UpdateProjectSlugInput;
};
export type MutationUpdateSchemaPolicyForOrganizationArgs = {
    allowOverrides: Scalars['Boolean']['input'];
    policy: SchemaPolicyInput;
    selector: OrganizationSelectorInput;
};
export type MutationUpdateSchemaPolicyForProjectArgs = {
    policy: SchemaPolicyInput;
    selector: ProjectSelectorInput;
};
export type MutationUpdateTargetConditionalBreakingChangeConfigurationArgs = {
    input: UpdateTargetConditionalBreakingChangeConfigurationInput;
};
export type MutationUpdateTargetDangerousChangeClassificationArgs = {
    input: UpdateTargetDangerousChangeClassificationInput;
};
export type MutationUpdateTargetGraphQlEndpointUrlArgs = {
    input: UpdateTargetGraphQlEndpointUrlInput;
};
export type MutationUpdateTargetSlugArgs = {
    input: UpdateTargetSlugInput;
};
export type MutationUpgradeToProArgs = {
    input: UpgradeToProInput;
};
export declare enum NativeFederationCompatibilityStatus {
    Compatible = "COMPATIBLE",
    Incompatible = "INCOMPATIBLE",
    NotApplicable = "NOT_APPLICABLE",
    Unknown = "UNKNOWN"
}
export type OidcIntegration = {
    __typename?: 'OIDCIntegration';
    authorizationEndpoint: Scalars['String']['output'];
    clientId: Scalars['ID']['output'];
    clientSecretPreview: Scalars['String']['output'];
    defaultMemberRole: MemberRole;
    id: Scalars['ID']['output'];
    oidcUserAccessOnly: Scalars['Boolean']['output'];
    organization: Organization;
    tokenEndpoint: Scalars['String']['output'];
    userinfoEndpoint: Scalars['String']['output'];
};
export type OidcIntegrationLogEvent = {
    __typename?: 'OIDCIntegrationLogEvent';
    message: Scalars['String']['output'];
    timestamp: Scalars['DateTime']['output'];
};
export type OidcIntegrationLogSubscriptionInput = {
    oidcIntegrationId: Scalars['ID']['input'];
};
export type Operation = {
    __typename?: 'Operation';
    /** Operation body */
    body: Scalars['String']['output'];
    /** Hash that uniquely identifies the operation. */
    hash: Scalars['ID']['output'];
    /** Name of the operation */
    name?: Maybe<Scalars['String']['output']>;
    /** Operation type */
    type: GraphQlOperationType;
};
export type OperationStatsFilterInput = {
    /** Filter by only showing operations performed by specific clients. */
    clientNames?: InputMaybe<Array<Scalars['String']['input']>>;
    /** Filter by only showing operations with a specific id. */
    operationIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};
export type OperationStatsValues = {
    __typename?: 'OperationStatsValues';
    /** Total number of requests */
    count: Scalars['SafeInt']['output'];
    /** Number of requests that succeeded */
    countOk: Scalars['SafeInt']['output'];
    duration: DurationValues;
    id: Scalars['ID']['output'];
    kind: Scalars['String']['output'];
    name: Scalars['String']['output'];
    operationHash: Scalars['String']['output'];
    percentage: Scalars['Float']['output'];
};
export type OperationStatsValuesConnection = {
    __typename?: 'OperationStatsValuesConnection';
    edges: Array<OperationStatsValuesEdge>;
    pageInfo: PageInfo;
};
export type OperationStatsValuesEdge = {
    __typename?: 'OperationStatsValuesEdge';
    cursor: Scalars['String']['output'];
    node: OperationStatsValues;
};
export type OperationsStats = {
    __typename?: 'OperationsStats';
    clients: ClientStatsValuesConnection;
    duration: DurationValues;
    durationOverTime: Array<DurationOverTime>;
    failuresOverTime: Array<FailuresOverTime>;
    operations: OperationStatsValuesConnection;
    requestsOverTime: Array<RequestsOverTime>;
    totalFailures: Scalars['SafeInt']['output'];
    totalOperations: Scalars['Int']['output'];
    totalRequests: Scalars['SafeInt']['output'];
};
export type OperationsStatsDurationOverTimeArgs = {
    resolution: Scalars['Int']['input'];
};
export type OperationsStatsFailuresOverTimeArgs = {
    resolution: Scalars['Int']['input'];
};
export type OperationsStatsRequestsOverTimeArgs = {
    resolution: Scalars['Int']['input'];
};
export type Organization = {
    __typename?: 'Organization';
    /** Get organization access token by id. */
    accessToken?: Maybe<OrganizationAccessToken>;
    /** Paginated organization access tokens. */
    accessTokens: OrganizationAccessTokenConnection;
    /** List of available permission groups that can be assigned to users. */
    availableMemberPermissionGroups: Array<PermissionGroup>;
    /** List of available permission groups that can be assigned to organization access tokens. */
    availableOrganizationAccessTokenPermissionGroups: Array<PermissionGroup>;
    billingConfiguration: BillingConfiguration;
    /** @deprecated Use the 'slug' field instead. */
    cleanId: Scalars['ID']['output'];
    getStarted: OrganizationGetStarted;
    gitHubIntegration?: Maybe<GitHubIntegration>;
    hasGitHubIntegration: Scalars['Boolean']['output'];
    hasSlackIntegration: Scalars['Boolean']['output'];
    /** Unique UUID of the organization */
    id: Scalars['ID']['output'];
    invitations?: Maybe<OrganizationInvitationConnection>;
    isAppDeploymentsEnabled: Scalars['Boolean']['output'];
    me: Member;
    memberRoles?: Maybe<MemberRoleConnection>;
    members: MemberConnection;
    /** @deprecated Use the 'slug' field instead. */
    name: Scalars['String']['output'];
    oidcIntegration?: Maybe<OidcIntegration>;
    owner: Member;
    plan: BillingPlanType;
    projectBySlug?: Maybe<Project>;
    projects: ProjectConnection;
    rateLimit: RateLimit;
    schemaPolicy?: Maybe<SchemaPolicy>;
    /** The slug of the organization. */
    slug: Scalars['String']['output'];
    supportTicket?: Maybe<SupportTicket>;
    supportTickets?: Maybe<SupportTicketConnection>;
    /** Whether the viewer should be able to access the settings page within the app */
    viewerCanAccessSettings: Scalars['Boolean']['output'];
    /** Whether the viewer can assign roles to users */
    viewerCanAssignUserRoles: Scalars['Boolean']['output'];
    viewerCanCreateProject: Scalars['Boolean']['output'];
    /** Whether the viewer can delete the organization */
    viewerCanDelete: Scalars['Boolean']['output'];
    viewerCanDescribeBilling: Scalars['Boolean']['output'];
    /** The organization's audit logs. This field is only available to members with the Admin role. */
    viewerCanExportAuditLogs: Scalars['Boolean']['output'];
    /** Whether the viewer can manage access tokens. */
    viewerCanManageAccessTokens: Scalars['Boolean']['output'];
    /** Whether the viewer can manage member invites */
    viewerCanManageInvitations: Scalars['Boolean']['output'];
    viewerCanManageOIDCIntegration: Scalars['Boolean']['output'];
    /** Whether the viewer can modify roles of members within the organization */
    viewerCanManageRoles: Scalars['Boolean']['output'];
    viewerCanManageSupportTickets: Scalars['Boolean']['output'];
    viewerCanModifyBilling: Scalars['Boolean']['output'];
    viewerCanModifyGitHubIntegration: Scalars['Boolean']['output'];
    /** Whether the viewer can view and modify the schema policy for this organization */
    viewerCanModifySchemaPolicy: Scalars['Boolean']['output'];
    viewerCanModifySlackIntegration: Scalars['Boolean']['output'];
    /** Whether the viewer can modify the organization slug */
    viewerCanModifySlug: Scalars['Boolean']['output'];
    /** Whether the viewer can see the members within the organization */
    viewerCanSeeMembers: Scalars['Boolean']['output'];
    /** Whether the viewer can transfer ownership of the organization */
    viewerCanTransferOwnership: Scalars['Boolean']['output'];
};
export type OrganizationAccessTokenArgs = {
    id: Scalars['ID']['input'];
};
export type OrganizationAccessTokensArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
};
export type OrganizationInvitationsArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
};
export type OrganizationMemberRolesArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
};
export type OrganizationMembersArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
};
export type OrganizationProjectBySlugArgs = {
    projectSlug: Scalars['String']['input'];
};
export type OrganizationSupportTicketArgs = {
    id: Scalars['ID']['input'];
};
export type OrganizationSupportTicketsArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
};
export declare enum OrganizationAccessScope {
    Delete = "DELETE",
    Integrations = "INTEGRATIONS",
    Members = "MEMBERS",
    Read = "READ",
    Settings = "SETTINGS"
}
export type OrganizationAccessToken = {
    __typename?: 'OrganizationAccessToken';
    createdAt: Scalars['DateTime']['output'];
    description?: Maybe<Scalars['String']['output']>;
    firstCharacters: Scalars['String']['output'];
    id: Scalars['ID']['output'];
    permissions: Array<Scalars['String']['output']>;
    resources: ResourceAssignment;
    title: Scalars['String']['output'];
};
export type OrganizationAccessTokenConnection = {
    __typename?: 'OrganizationAccessTokenConnection';
    edges: Array<OrganizationAccessTokenEdge>;
    pageInfo: PageInfo;
};
export type OrganizationAccessTokenEdge = {
    __typename?: 'OrganizationAccessTokenEdge';
    cursor: Scalars['String']['output'];
    node: OrganizationAccessToken;
};
export type OrganizationAccessTokenReference = {
    byId: Scalars['ID']['input'];
};
export type OrganizationByInviteCodePayload = OrganizationInvitationError | OrganizationInvitationPayload;
export type OrganizationConnection = {
    __typename?: 'OrganizationConnection';
    nodes: Array<Organization>;
    total: Scalars['Int']['output'];
};
export type OrganizationGetStarted = {
    __typename?: 'OrganizationGetStarted';
    checkingSchema: Scalars['Boolean']['output'];
    creatingProject: Scalars['Boolean']['output'];
    enablingUsageBasedBreakingChanges: Scalars['Boolean']['output'];
    invitingMembers: Scalars['Boolean']['output'];
    publishingSchema: Scalars['Boolean']['output'];
    reportingOperations: Scalars['Boolean']['output'];
};
export type OrganizationInvitation = {
    __typename?: 'OrganizationInvitation';
    code: Scalars['String']['output'];
    createdAt: Scalars['DateTime']['output'];
    email: Scalars['String']['output'];
    expiresAt: Scalars['DateTime']['output'];
    id: Scalars['ID']['output'];
    role: MemberRole;
};
export type OrganizationInvitationConnection = {
    __typename?: 'OrganizationInvitationConnection';
    edges: Array<OrganizationInvitationEdge>;
    pageInfo: PageInfo;
};
export type OrganizationInvitationEdge = {
    __typename?: 'OrganizationInvitationEdge';
    cursor: Scalars['String']['output'];
    node: OrganizationInvitation;
};
export type OrganizationInvitationError = {
    __typename?: 'OrganizationInvitationError';
    message: Scalars['String']['output'];
};
export type OrganizationInvitationPayload = {
    __typename?: 'OrganizationInvitationPayload';
    name: Scalars['String']['output'];
};
export type OrganizationMemberInput = {
    organizationSlug: Scalars['String']['input'];
    userId: Scalars['ID']['input'];
};
export type OrganizationPayload = {
    __typename?: 'OrganizationPayload';
    organization: Organization;
    selector: OrganizationSelector;
};
export type OrganizationReferenceInput = {
    byId: Scalars['ID']['input'];
    bySelector?: never;
} | {
    byId?: never;
    bySelector: OrganizationSelectorInput;
};
export type OrganizationSelector = {
    __typename?: 'OrganizationSelector';
    organizationSlug: Scalars['String']['output'];
};
export type OrganizationSelectorInput = {
    organizationSlug: Scalars['String']['input'];
};
export type OrganizationTransfer = {
    __typename?: 'OrganizationTransfer';
    organization: Organization;
};
export type OrganizationTransferRequestSelector = {
    code: Scalars['String']['input'];
    organizationSlug: Scalars['String']['input'];
};
export type PageInfo = {
    __typename?: 'PageInfo';
    endCursor: Scalars['String']['output'];
    hasNextPage: Scalars['Boolean']['output'];
    hasPreviousPage: Scalars['Boolean']['output'];
    startCursor: Scalars['String']['output'];
};
export type Permission = {
    __typename?: 'Permission';
    dependsOnId?: Maybe<Scalars['ID']['output']>;
    description: Scalars['String']['output'];
    id: Scalars['ID']['output'];
    isReadOnly: Scalars['Boolean']['output'];
    level: PermissionLevelType;
    title: Scalars['String']['output'];
    warning?: Maybe<Scalars['String']['output']>;
};
export type PermissionGroup = {
    __typename?: 'PermissionGroup';
    id: Scalars['ID']['output'];
    permissions: Array<Permission>;
    title: Scalars['String']['output'];
};
export declare enum PermissionLevelType {
    AppDeployment = "APP_DEPLOYMENT",
    Organization = "ORGANIZATION",
    Project = "PROJECT",
    Service = "SERVICE",
    Target = "TARGET"
}
export type PreflightScript = {
    __typename?: 'PreflightScript';
    createdAt: Scalars['DateTime']['output'];
    id: Scalars['ID']['output'];
    sourceCode: Scalars['String']['output'];
    updatedAt: Scalars['DateTime']['output'];
};
export type PreflightScriptError = Error & {
    __typename?: 'PreflightScriptError';
    message: Scalars['String']['output'];
};
export type PreflightScriptOk = {
    __typename?: 'PreflightScriptOk';
    preflightScript: PreflightScript;
    updatedTarget: Target;
};
/** @oneOf */
export type PreflightScriptResult = {
    __typename?: 'PreflightScriptResult';
    error?: Maybe<PreflightScriptError>;
    ok?: Maybe<PreflightScriptOk>;
};
export type Project = {
    __typename?: 'Project';
    alertChannels?: Maybe<Array<AlertChannel>>;
    alerts?: Maybe<Array<Alert>>;
    buildUrl?: Maybe<Scalars['String']['output']>;
    /** @deprecated Use the 'slug' field instead. */
    cleanId: Scalars['ID']['output'];
    experimental_nativeCompositionPerTarget: Scalars['Boolean']['output'];
    externalSchemaComposition?: Maybe<ExternalSchemaComposition>;
    id: Scalars['ID']['output'];
    isNativeFederationEnabled: Scalars['Boolean']['output'];
    isProjectNameInGitHubCheckEnabled: Scalars['Boolean']['output'];
    /** @deprecated Use the 'slug' field instead. */
    name: Scalars['String']['output'];
    nativeFederationCompatibility: NativeFederationCompatibilityStatus;
    parentSchemaPolicy?: Maybe<SchemaPolicy>;
    requestsOverTime: Array<RequestsOverTime>;
    schemaPolicy?: Maybe<SchemaPolicy>;
    schemaVersionsCount: Scalars['Int']['output'];
    slug: Scalars['String']['output'];
    targetBySlug?: Maybe<Target>;
    targets: TargetConnection;
    totalRequests: Scalars['SafeInt']['output'];
    type: ProjectType;
    validationUrl?: Maybe<Scalars['String']['output']>;
    /** Whether the viewer can create a new target within this project. */
    viewerCanCreateTarget: Scalars['Boolean']['output'];
    /** Whether the viewer can delete this project. */
    viewerCanDelete: Scalars['Boolean']['output'];
    /** Whether the viewer can view and modify alerts with this project. */
    viewerCanModifyAlerts: Scalars['Boolean']['output'];
    /** Whether the viewer can view and modify the schema policy for this organization */
    viewerCanModifySchemaPolicy: Scalars['Boolean']['output'];
    /** Whether the viewer can access the settings page and modify settings of this project. */
    viewerCanModifySettings: Scalars['Boolean']['output'];
};
export type ProjectRequestsOverTimeArgs = {
    period: DateRangeInput;
    resolution: Scalars['Int']['input'];
};
export type ProjectSchemaVersionsCountArgs = {
    period?: InputMaybe<DateRangeInput>;
};
export type ProjectTargetBySlugArgs = {
    targetSlug: Scalars['String']['input'];
};
export type ProjectTotalRequestsArgs = {
    period: DateRangeInput;
};
export declare enum ProjectAccessScope {
    Alerts = "ALERTS",
    Delete = "DELETE",
    OperationsStoreRead = "OPERATIONS_STORE_READ",
    OperationsStoreWrite = "OPERATIONS_STORE_WRITE",
    Read = "READ",
    Settings = "SETTINGS"
}
export type ProjectConnection = {
    __typename?: 'ProjectConnection';
    edges: Array<ProjectEdge>;
    pageInfo: PageInfo;
};
export type ProjectEdge = {
    __typename?: 'ProjectEdge';
    cursor: Scalars['String']['output'];
    node: Project;
};
export type ProjectReferenceInput = {
    byId: Scalars['ID']['input'];
    bySelector?: never;
} | {
    byId?: never;
    bySelector: ProjectSelectorInput;
};
export type ProjectResourceAssignment = {
    __typename?: 'ProjectResourceAssignment';
    project: Project;
    projectId: Scalars['ID']['output'];
    targets: ProjectTargetsResourceAssignment;
};
export type ProjectResourceAssignmentInput = {
    projectId: Scalars['ID']['input'];
    targets: ProjectTargetsResourceAssignmentInput;
};
export type ProjectSelector = {
    __typename?: 'ProjectSelector';
    organizationSlug: Scalars['String']['output'];
    projectSlug: Scalars['String']['output'];
};
export type ProjectSelectorInput = {
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
};
export type ProjectTargetsResourceAssignment = {
    __typename?: 'ProjectTargetsResourceAssignment';
    mode: ResourceAssignmentModeType;
    targets?: Maybe<Array<TargetResouceAssignment>>;
};
export type ProjectTargetsResourceAssignmentInput = {
    /** Whether the permissions should apply for all targets within the project or only selected ones. */
    mode: ResourceAssignmentModeType;
    /** Specific targets within the projects for which the permissions should be applied. */
    targets?: InputMaybe<Array<TargetResourceAssignmentInput>>;
};
export declare enum ProjectType {
    Federation = "FEDERATION",
    Single = "SINGLE",
    Stitching = "STITCHING"
}
export type PushedSchemaLog = {
    __typename?: 'PushedSchemaLog';
    author: Scalars['String']['output'];
    commit: Scalars['ID']['output'];
    date: Scalars['DateTime']['output'];
    id: Scalars['ID']['output'];
    /** The previous SDL of the pushed schema. Is null for single schema projects. */
    previousServiceSdl?: Maybe<Scalars['String']['output']>;
    /** The name of the service that got published. */
    service?: Maybe<Scalars['String']['output']>;
    /** The serviceSDL of the pushed schema. Is null for single schema projects. */
    serviceSdl?: Maybe<Scalars['String']['output']>;
};
export type Query = {
    __typename?: 'Query';
    admin: AdminQuery;
    billingPlans: Array<BillingPlan>;
    clientStatsByTargets: ClientStatsValuesConnection;
    fieldListStats: Array<FieldStatsValues>;
    fieldStats: FieldStatsValues;
    hasCollectedOperations: Scalars['Boolean']['output'];
    /** Whether the CDN integration in Hive is enabled. */
    isCDNEnabled: Scalars['Boolean']['output'];
    isGitHubIntegrationFeatureEnabled: Scalars['Boolean']['output'];
    lab?: Maybe<Lab>;
    latestValidVersion?: Maybe<SchemaVersion>;
    /** Requires API Token */
    latestVersion?: Maybe<SchemaVersion>;
    me: User;
    monthlyUsage: Array<MonthlyUsage>;
    myDefaultOrganization?: Maybe<OrganizationPayload>;
    organization?: Maybe<Organization>;
    organizationByGitHubInstallationId?: Maybe<Organization>;
    organizationByInviteCode?: Maybe<OrganizationByInviteCodePayload>;
    organizationBySlug?: Maybe<Organization>;
    organizationTransferRequest?: Maybe<OrganizationTransfer>;
    organizations: OrganizationConnection;
    project?: Maybe<Project>;
    schemaPolicyRules: Array<SchemaPolicyRule>;
    schemaVersionForActionId?: Maybe<SchemaVersion>;
    target?: Maybe<Target>;
    targets: TargetConnection;
    testExternalSchemaComposition: TestExternalSchemaCompositionResult;
    tokenInfo: TokenInfoPayload;
    tokens: TokenConnection;
    usageEstimation: UsageEstimation;
};
export type QueryClientStatsByTargetsArgs = {
    selector: ClientStatsByTargetsInput;
};
export type QueryFieldListStatsArgs = {
    selector: FieldListStatsInput;
};
export type QueryFieldStatsArgs = {
    selector: FieldStatsInput;
};
export type QueryHasCollectedOperationsArgs = {
    selector: TargetSelectorInput;
};
export type QueryLabArgs = {
    selector: TargetSelectorInput;
};
export type QueryLatestValidVersionArgs = {
    target?: InputMaybe<TargetReferenceInput>;
};
export type QueryMonthlyUsageArgs = {
    selector: OrganizationSelectorInput;
};
export type QueryMyDefaultOrganizationArgs = {
    previouslyVisitedOrganizationId?: InputMaybe<Scalars['ID']['input']>;
};
export type QueryOrganizationArgs = {
    reference: OrganizationReferenceInput;
};
export type QueryOrganizationByGitHubInstallationIdArgs = {
    installation: Scalars['ID']['input'];
};
export type QueryOrganizationByInviteCodeArgs = {
    code: Scalars['String']['input'];
};
export type QueryOrganizationBySlugArgs = {
    organizationSlug: Scalars['String']['input'];
};
export type QueryOrganizationTransferRequestArgs = {
    selector: OrganizationTransferRequestSelector;
};
export type QueryProjectArgs = {
    reference: ProjectReferenceInput;
};
export type QuerySchemaVersionForActionIdArgs = {
    actionId: Scalars['ID']['input'];
    target?: InputMaybe<TargetReferenceInput>;
};
export type QueryTargetArgs = {
    reference: TargetReferenceInput;
};
export type QueryTargetsArgs = {
    selector: ProjectSelectorInput;
};
export type QueryTestExternalSchemaCompositionArgs = {
    selector: TestExternalSchemaCompositionInput;
};
export type QueryTokensArgs = {
    selector: TargetSelectorInput;
};
export type QueryUsageEstimationArgs = {
    input: UsageEstimationInput;
};
export type RateLimit = {
    __typename?: 'RateLimit';
    limitedForOperations: Scalars['Boolean']['output'];
    operations: Scalars['SafeInt']['output'];
    retentionInDays: Scalars['Int']['output'];
};
export type RateLimitInput = {
    operations: Scalars['SafeInt']['input'];
};
export type RegistryLog = DeletedSchemaLog | PushedSchemaLog;
export type RequestOrganizationTransferError = Error & {
    __typename?: 'RequestOrganizationTransferError';
    message: Scalars['String']['output'];
};
export type RequestOrganizationTransferInput = {
    organizationSlug: Scalars['String']['input'];
    userId: Scalars['ID']['input'];
};
export type RequestOrganizationTransferOk = {
    __typename?: 'RequestOrganizationTransferOk';
    code: Scalars['String']['output'];
    email: Scalars['String']['output'];
};
/** @oneOf */
export type RequestOrganizationTransferResult = {
    __typename?: 'RequestOrganizationTransferResult';
    error?: Maybe<RequestOrganizationTransferError>;
    ok?: Maybe<RequestOrganizationTransferOk>;
};
export type RequestsOverTime = {
    __typename?: 'RequestsOverTime';
    date: Scalars['DateTime']['output'];
    value: Scalars['SafeInt']['output'];
};
export type ResourceAssignment = {
    __typename?: 'ResourceAssignment';
    mode: ResourceAssignmentModeType;
    projects?: Maybe<Array<ProjectResourceAssignment>>;
};
export type ResourceAssignmentInput = {
    /** Whether the permissions should apply for all projects within the organization or only selected ones. */
    mode: ResourceAssignmentModeType;
    /** Specific projects within the organization for which the permissions should be applied. */
    projects?: InputMaybe<Array<ProjectResourceAssignmentInput>>;
};
export declare enum ResourceAssignmentModeType {
    /** Apply to all subresouces of the resource. */
    All = "ALL",
    /** Apply to specific subresouces of the resource. */
    Granular = "GRANULAR"
}
export type RetireAppDeploymentError = Error & {
    __typename?: 'RetireAppDeploymentError';
    message: Scalars['String']['output'];
};
export type RetireAppDeploymentInput = {
    appName: Scalars['String']['input'];
    appVersion: Scalars['String']['input'];
    targetId: Scalars['ID']['input'];
};
export type RetireAppDeploymentOk = {
    __typename?: 'RetireAppDeploymentOk';
    retiredAppDeployment: AppDeployment;
};
export type RetireAppDeploymentResult = {
    __typename?: 'RetireAppDeploymentResult';
    error?: Maybe<RetireAppDeploymentError>;
    ok?: Maybe<RetireAppDeploymentOk>;
};
export declare enum RuleInstanceSeverityLevel {
    Error = "ERROR",
    Off = "OFF",
    Warning = "WARNING"
}
export type Schema = CompositeSchema | SingleSchema;
/** Describes a schema change for either a schema version (`SchemaVersion`) or schema check (`SchemaCheck`). */
export type SchemaChange = {
    __typename?: 'SchemaChange';
    /**
     * Approval metadata for this schema change.
     * This field is populated in case the breaking change was manually approved.
     */
    approval?: Maybe<SchemaChangeApproval>;
    /** @deprecated Use 'SchemaChange.severityLevel' instead. This field will be removed once it is no longer in use by a client. */
    criticality: CriticalityLevel;
    /** @deprecated Use 'SchemaChange.severityReason' instead. This field will be removed once it is no longer in use by a client. */
    criticalityReason?: Maybe<Scalars['String']['output']>;
    /** Whether the breaking change is safe based on usage data. */
    isSafeBasedOnUsage: Scalars['Boolean']['output'];
    /** Message describing the schema change. */
    message: Scalars['String']['output'];
    path?: Maybe<Array<Scalars['String']['output']>>;
    /**
     * The severity level of this schema change.
     * Note: A schema change with the impact `SeverityLevelType.BREAKING` can still be safe based on the usage (`SchemaChange.isSafeBasedOnUsage`).
     */
    severityLevel: SeverityLevelType;
    /** The reason for the schema changes severity level (`SchemaChange.severityLevel`) */
    severityReason?: Maybe<Scalars['String']['output']>;
    /**
     * Usage statistics about the schema change if it is not safe based on usage.
     * The statistics are determined based on the breaking change configuration.
     * The usage statistics are only available for breaking changes and only represent a snapshot of the usage data at the time of the schema check/schema publish.
     */
    usageStatistics?: Maybe<SchemaChangeUsageStatistics>;
};
/** Describes a schema change for either a schema version (`SchemaVersion`) or schema check (`SchemaCheck`). */
export type SchemaChangeMessageArgs = {
    withSafeBasedOnUsageNote?: InputMaybe<Scalars['Boolean']['input']>;
};
export type SchemaChangeApproval = {
    __typename?: 'SchemaChangeApproval';
    /** Date of the schema change approval. */
    approvedAt: Scalars['DateTime']['output'];
    /** User that approved this schema change. */
    approvedBy?: Maybe<User>;
    /** ID of the schema check in which this change was first approved. */
    schemaCheckId: Scalars['ID']['output'];
};
export type SchemaChangeConnection = {
    __typename?: 'SchemaChangeConnection';
    edges: Array<SchemaChangeEdge>;
    /** @deprecated Use 'SchemaChangeConnection.edges' instead. */
    nodes: Array<SchemaChange>;
    pageInfo: PageInfo;
    /** @deprecated This field will be removed in the future. */
    total: Scalars['Int']['output'];
};
export type SchemaChangeEdge = {
    __typename?: 'SchemaChangeEdge';
    cursor: Scalars['String']['output'];
    node: SchemaChange;
};
export type SchemaChangeUsageStatistics = {
    __typename?: 'SchemaChangeUsageStatistics';
    /** List of top clients that are affected by this schema change. */
    topAffectedClients: Array<SchemaChangeUsageStatisticsAffectedClient>;
    /** List of the top operations that are affected by this schema change. */
    topAffectedOperations: Array<SchemaChangeUsageStatisticsAffectedOperation>;
};
export type SchemaChangeUsageStatisticsAffectedClient = {
    __typename?: 'SchemaChangeUsageStatisticsAffectedClient';
    /** The number of times the client called the operation in the period. */
    count: Scalars['Float']['output'];
    /** Human readable count value. */
    countFormatted: Scalars['String']['output'];
    /** Name of the client. */
    name: Scalars['String']['output'];
    /** The percentage share of the client of the total traffic. */
    percentage: Scalars['Float']['output'];
    /** Human readable percentage value. */
    percentageFormatted: Scalars['String']['output'];
};
export type SchemaChangeUsageStatisticsAffectedOperation = {
    __typename?: 'SchemaChangeUsageStatisticsAffectedOperation';
    /** The number of times the operation was called in the period. */
    count: Scalars['Float']['output'];
    /** Human readable count value. */
    countFormatted: Scalars['String']['output'];
    /** Hash of the operation. */
    hash: Scalars['String']['output'];
    /** Name of the operation. */
    name: Scalars['String']['output'];
    /**
     * Get the associated operation.
     * The field is nullable as this data is only stored for the duration of the usage retention period.
     */
    operation?: Maybe<Operation>;
    /** The percentage share of the operation of the total traffic. */
    percentage: Scalars['Float']['output'];
    /** Human readable percentage value. */
    percentageFormatted: Scalars['String']['output'];
};
export type SchemaCheck = {
    breakingSchemaChanges?: Maybe<SchemaChangeConnection>;
    /** Conditional breaking change metadata. */
    conditionalBreakingChangeMetadata?: Maybe<SchemaCheckConditionalBreakingChangeMetadata>;
    /** Optional context ID to group schema checks together. */
    contextId?: Maybe<Scalars['String']['output']>;
    /** Results of the contracts */
    contractChecks?: Maybe<ContractCheckConnection>;
    createdAt: Scalars['String']['output'];
    /** The GitHub repository associated with the schema check. */
    githubRepository?: Maybe<Scalars['String']['output']>;
    /** Whether this schema check has any schema changes. */
    hasSchemaChanges: Scalars['Boolean']['output'];
    /** Whether this schema check has any composition errors. */
    hasSchemaCompositionErrors: Scalars['Boolean']['output'];
    /** Whether this schema check has any breaking changes. */
    hasUnapprovedBreakingChanges: Scalars['Boolean']['output'];
    id: Scalars['ID']['output'];
    /** Meta information about the schema check. */
    meta?: Maybe<SchemaCheckMeta>;
    /** The previous schema SDL. For composite schemas this is the service. */
    previousSchemaSDL?: Maybe<Scalars['String']['output']>;
    safeSchemaChanges?: Maybe<SchemaChangeConnection>;
    schemaChanges?: Maybe<SchemaChangeConnection>;
    schemaPolicyErrors?: Maybe<SchemaPolicyWarningConnection>;
    schemaPolicyWarnings?: Maybe<SchemaPolicyWarningConnection>;
    /** The SDL of the schema that was checked. */
    schemaSDL: Scalars['String']['output'];
    /**
     * The schema version against this check was performed.
     * Is null if there is no schema version published yet.
     */
    schemaVersion?: Maybe<SchemaVersion>;
    /** The name of the service that owns the schema. Is null for non composite project types. */
    serviceName?: Maybe<Scalars['String']['output']>;
    /** The URL of the schema check on the Hive Web App. */
    webUrl?: Maybe<Scalars['String']['output']>;
};
export type SchemaCheckConditionalBreakingChangeMetadata = {
    __typename?: 'SchemaCheckConditionalBreakingChangeMetadata';
    period: DateRange;
    settings: SchemaCheckConditionalBreakingChangeMetadataSettings;
    usage: SchemaCheckConditionalBreakingChangeMetadataUsage;
};
export type SchemaCheckConditionalBreakingChangeMetadataSettings = {
    __typename?: 'SchemaCheckConditionalBreakingChangeMetadataSettings';
    excludedClientNames?: Maybe<Array<Scalars['String']['output']>>;
    percentage: Scalars['Float']['output'];
    retentionInDays: Scalars['Int']['output'];
    targets: Array<BreakingChangeMetadataTarget>;
};
export type SchemaCheckConditionalBreakingChangeMetadataUsage = {
    __typename?: 'SchemaCheckConditionalBreakingChangeMetadataUsage';
    /** Total amount of requests for the settings and period. */
    totalRequestCount: Scalars['Float']['output'];
    /** Total request count human readable. */
    totalRequestCountFormatted: Scalars['String']['output'];
};
export type SchemaCheckConnection = {
    __typename?: 'SchemaCheckConnection';
    edges: Array<SchemaCheckEdge>;
    pageInfo: PageInfo;
};
export type SchemaCheckEdge = {
    __typename?: 'SchemaCheckEdge';
    cursor: Scalars['String']['output'];
    node: SchemaCheck;
};
export type SchemaCheckError = {
    __typename?: 'SchemaCheckError';
    changes?: Maybe<SchemaChangeConnection>;
    errors: SchemaErrorConnection;
    schemaCheck?: Maybe<SchemaCheck>;
    valid: Scalars['Boolean']['output'];
    warnings?: Maybe<SchemaWarningConnection>;
};
export type SchemaCheckInput = {
    /**
     * Optional context ID to group schema checks together.
     * Manually approved breaking changes will be memorized for schema checks with the same context id.
     */
    contextId?: InputMaybe<Scalars['String']['input']>;
    github?: InputMaybe<GitHubSchemaCheckInput>;
    meta?: InputMaybe<SchemaCheckMetaInput>;
    sdl: Scalars['String']['input'];
    service?: InputMaybe<Scalars['ID']['input']>;
    target?: InputMaybe<TargetReferenceInput>;
    /** Optional url if wanting to show subgraph url changes inside checks. */
    url?: InputMaybe<Scalars['String']['input']>;
};
export type SchemaCheckMeta = {
    __typename?: 'SchemaCheckMeta';
    author: Scalars['String']['output'];
    commit: Scalars['String']['output'];
};
export type SchemaCheckMetaInput = {
    author: Scalars['String']['input'];
    commit: Scalars['String']['input'];
};
export type SchemaCheckPayload = GitHubSchemaCheckError | GitHubSchemaCheckSuccess | SchemaCheckError | SchemaCheckSuccess;
export type SchemaCheckSuccess = {
    __typename?: 'SchemaCheckSuccess';
    changes?: Maybe<SchemaChangeConnection>;
    initial: Scalars['Boolean']['output'];
    schemaCheck?: Maybe<SchemaCheck>;
    valid: Scalars['Boolean']['output'];
    warnings?: Maybe<SchemaWarningConnection>;
};
export type SchemaCheckWarning = {
    __typename?: 'SchemaCheckWarning';
    column?: Maybe<Scalars['Int']['output']>;
    line?: Maybe<Scalars['Int']['output']>;
    message: Scalars['String']['output'];
    source?: Maybe<Scalars['String']['output']>;
};
export type SchemaChecksFilter = {
    changed?: InputMaybe<Scalars['Boolean']['input']>;
    failed?: InputMaybe<Scalars['Boolean']['input']>;
};
export type SchemaCompareInput = {
    after: Scalars['ID']['input'];
    before: Scalars['ID']['input'];
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    targetSlug: Scalars['String']['input'];
};
export type SchemaComposeError = Error & {
    __typename?: 'SchemaComposeError';
    message: Scalars['String']['output'];
};
export type SchemaComposeInput = {
    services: Array<SchemaComposeServiceInput>;
    target?: InputMaybe<TargetReferenceInput>;
    /**
     * Whether to use the latest composable version or just latest schema version for the composition.
     * Latest schema version may or may not be composable.
     * It's true by default, which means the latest composable schema version is used.
     */
    useLatestComposableVersion?: InputMaybe<Scalars['Boolean']['input']>;
};
export type SchemaComposePayload = SchemaComposeError | SchemaComposeSuccess;
export type SchemaComposeServiceInput = {
    name: Scalars['String']['input'];
    sdl: Scalars['String']['input'];
    url?: InputMaybe<Scalars['String']['input']>;
};
export type SchemaComposeSuccess = {
    __typename?: 'SchemaComposeSuccess';
    compositionResult: SchemaCompositionResult;
    valid: Scalars['Boolean']['output'];
};
/** @oneOf */
export type SchemaCompositionResult = {
    __typename?: 'SchemaCompositionResult';
    errors?: Maybe<SchemaErrorConnection>;
    supergraphSdl?: Maybe<Scalars['String']['output']>;
};
export type SchemaConnection = {
    __typename?: 'SchemaConnection';
    edges: Array<SchemaEdge>;
    /** @deprecated Use 'SchemaConnection.edges' instead. */
    nodes: Array<Schema>;
    pageInfo: PageInfo;
    /** @deprecated This field will be removed. */
    total: Scalars['Int']['output'];
};
export type SchemaCoordinateStats = {
    __typename?: 'SchemaCoordinateStats';
    clients: ClientStatsValuesConnection;
    operations: OperationStatsValuesConnection;
    requestsOverTime: Array<RequestsOverTime>;
    supergraphMetadata?: Maybe<SupergraphMetadata>;
    totalRequests: Scalars['SafeInt']['output'];
};
export type SchemaCoordinateStatsRequestsOverTimeArgs = {
    resolution: Scalars['Int']['input'];
};
export type SchemaCoordinateUsage = {
    __typename?: 'SchemaCoordinateUsage';
    isUsed: Scalars['Boolean']['output'];
    topOperations: Array<SchemaCoordinateUsageOperation>;
    total: Scalars['Float']['output'];
    /**
     * A list of clients that use this schema coordinate within GraphQL operation documents.
     * Is null if used by none clients.
     */
    usedByClients?: Maybe<Array<Scalars['String']['output']>>;
};
export type SchemaCoordinateUsageTopOperationsArgs = {
    limit: Scalars['Int']['input'];
};
export type SchemaCoordinateUsageOperation = {
    __typename?: 'SchemaCoordinateUsageOperation';
    /** The number of times the operation was called. */
    count: Scalars['Float']['output'];
    hash: Scalars['String']['output'];
    name: Scalars['String']['output'];
};
export type SchemaDeleteError = {
    __typename?: 'SchemaDeleteError';
    errors: SchemaErrorConnection;
    valid: Scalars['Boolean']['output'];
};
export type SchemaDeleteInput = {
    dryRun?: InputMaybe<Scalars['Boolean']['input']>;
    serviceName: Scalars['ID']['input'];
    target?: InputMaybe<TargetReferenceInput>;
};
export type SchemaDeleteResult = SchemaDeleteError | SchemaDeleteSuccess;
export type SchemaDeleteSuccess = {
    __typename?: 'SchemaDeleteSuccess';
    changes?: Maybe<SchemaChangeConnection>;
    errors: SchemaErrorConnection;
    valid: Scalars['Boolean']['output'];
};
export type SchemaEdge = {
    __typename?: 'SchemaEdge';
    cursor: Scalars['String']['output'];
    node: Schema;
};
export type SchemaError = {
    __typename?: 'SchemaError';
    message: Scalars['String']['output'];
    path?: Maybe<Array<Scalars['String']['output']>>;
};
export type SchemaErrorConnection = {
    __typename?: 'SchemaErrorConnection';
    edges: Array<SchemaErrorEdge>;
    /** @deprecated Use 'SchemaErrorConnection.edges' instead. */
    nodes: Array<SchemaError>;
    pageInfo: PageInfo;
    /** @deprecated This field will be removed in the future. */
    total: Scalars['Int']['output'];
};
export type SchemaErrorEdge = {
    __typename?: 'SchemaErrorEdge';
    cursor: Scalars['String']['output'];
    node: SchemaError;
};
export type SchemaExplorer = {
    __typename?: 'SchemaExplorer';
    metadataAttributes?: Maybe<Array<MetadataAttribute>>;
    mutation?: Maybe<GraphQlObjectType>;
    query?: Maybe<GraphQlObjectType>;
    subscription?: Maybe<GraphQlObjectType>;
    type?: Maybe<GraphQlNamedType>;
    types: Array<GraphQlNamedType>;
};
export type SchemaExplorerTypeArgs = {
    name: Scalars['String']['input'];
};
export type SchemaExplorerUsageInput = {
    period: DateRangeInput;
};
export type SchemaMetadata = {
    __typename?: 'SchemaMetadata';
    /** The value of the metadata */
    content: Scalars['String']['output'];
    /** The name or key of the metadata. This may not be unique. */
    name: Scalars['String']['output'];
    /** The schema or subgraph name where this metadata originated from. */
    source?: Maybe<Scalars['String']['output']>;
};
export type SchemaPolicy = {
    __typename?: 'SchemaPolicy';
    allowOverrides: Scalars['Boolean']['output'];
    id: Scalars['ID']['output'];
    rules: Array<SchemaPolicyRuleInstance>;
    updatedAt: Scalars['DateTime']['output'];
};
export type SchemaPolicyInput = {
    rules: Array<SchemaPolicyRuleInstanceInput>;
};
export declare enum SchemaPolicyLevel {
    Organization = "ORGANIZATION",
    Project = "PROJECT"
}
export type SchemaPolicyRule = {
    __typename?: 'SchemaPolicyRule';
    configJsonSchema?: Maybe<Scalars['JSONSchemaObject']['output']>;
    description: Scalars['String']['output'];
    documentationUrl?: Maybe<Scalars['String']['output']>;
    id: Scalars['ID']['output'];
    recommended: Scalars['Boolean']['output'];
};
export type SchemaPolicyRuleInstance = {
    __typename?: 'SchemaPolicyRuleInstance';
    configuration?: Maybe<Scalars['JSON']['output']>;
    rule: SchemaPolicyRule;
    severity: RuleInstanceSeverityLevel;
};
export type SchemaPolicyRuleInstanceInput = {
    configuration?: InputMaybe<Scalars['JSON']['input']>;
    ruleId: Scalars['String']['input'];
    severity: RuleInstanceSeverityLevel;
};
export type SchemaPolicyWarning = {
    __typename?: 'SchemaPolicyWarning';
    end?: Maybe<CodePosition>;
    message: Scalars['String']['output'];
    ruleId?: Maybe<Scalars['String']['output']>;
    start?: Maybe<CodePosition>;
};
export type SchemaPolicyWarningConnection = {
    __typename?: 'SchemaPolicyWarningConnection';
    edges: Array<SchemaPolicyWarningEdge>;
    pageInfo: PageInfo;
};
export type SchemaPolicyWarningEdge = {
    __typename?: 'SchemaPolicyWarningEdge';
    cursor: Scalars['String']['output'];
    node: SchemaPolicyWarning;
};
export type SchemaPublishError = {
    __typename?: 'SchemaPublishError';
    changes?: Maybe<SchemaChangeConnection>;
    errors: SchemaErrorConnection;
    linkToWebsite?: Maybe<Scalars['String']['output']>;
    valid: Scalars['Boolean']['output'];
};
export type SchemaPublishGitHubInput = {
    /** The commit sha. */
    commit: Scalars['String']['input'];
    /** The repository name. */
    repository: Scalars['String']['input'];
};
export type SchemaPublishInput = {
    author: Scalars['String']['input'];
    commit: Scalars['String']['input'];
    /**
     * Accept breaking changes and mark schema as valid (if composable)
     * @deprecated Enabled by default for newly created projects
     */
    experimental_acceptBreakingChanges?: InputMaybe<Scalars['Boolean']['input']>;
    /** @deprecated Enabled by default for newly created projects */
    force?: InputMaybe<Scalars['Boolean']['input']>;
    /** Link GitHub version to a GitHub commit on a repository. */
    gitHub?: InputMaybe<SchemaPublishGitHubInput>;
    /**
     * Talk to GitHub Application and create a check-run
     * @deprecated Use SchemaPublishInput.gitHub instead.
     */
    github?: InputMaybe<Scalars['Boolean']['input']>;
    metadata?: InputMaybe<Scalars['String']['input']>;
    sdl: Scalars['String']['input'];
    service?: InputMaybe<Scalars['ID']['input']>;
    /** Whether the CLI supports retrying the schema publish, in case acquiring the schema publish lock fails due to a busy queue. */
    supportsRetry?: InputMaybe<Scalars['Boolean']['input']>;
    target?: InputMaybe<TargetReferenceInput>;
    url?: InputMaybe<Scalars['String']['input']>;
};
export type SchemaPublishMissingServiceError = {
    __typename?: 'SchemaPublishMissingServiceError';
    message: Scalars['String']['output'];
};
export type SchemaPublishMissingUrlError = {
    __typename?: 'SchemaPublishMissingUrlError';
    message: Scalars['String']['output'];
};
export type SchemaPublishPayload = GitHubSchemaPublishError | GitHubSchemaPublishSuccess | SchemaPublishError | SchemaPublishMissingServiceError | SchemaPublishMissingUrlError | SchemaPublishRetry | SchemaPublishSuccess;
export type SchemaPublishRetry = {
    __typename?: 'SchemaPublishRetry';
    reason: Scalars['String']['output'];
};
export type SchemaPublishSuccess = {
    __typename?: 'SchemaPublishSuccess';
    changes?: Maybe<SchemaChangeConnection>;
    initial: Scalars['Boolean']['output'];
    linkToWebsite?: Maybe<Scalars['String']['output']>;
    message?: Maybe<Scalars['String']['output']>;
    valid: Scalars['Boolean']['output'];
};
export type SchemaVersion = {
    __typename?: 'SchemaVersion';
    baseSchema?: Maybe<Scalars['String']['output']>;
    breakingSchemaChanges?: Maybe<SchemaChangeConnection>;
    /** Contract versions of this schema version. */
    contractVersions?: Maybe<ContractVersionConnection>;
    /** The data on which this schema version was published. */
    date: Scalars['DateTime']['output'];
    deprecatedSchema?: Maybe<DeprecatedSchemaExplorer>;
    /** Experimental: This field is not stable and may change in the future. */
    explorer?: Maybe<SchemaExplorer>;
    /** GitHub metadata associated with the schema version. */
    githubMetadata?: Maybe<SchemaVersionGithubMetadata>;
    /** Whether this schema version has schema changes. */
    hasSchemaChanges: Scalars['Boolean']['output'];
    id: Scalars['ID']['output'];
    /** Whether this schema version is composable. */
    isComposable: Scalars['Boolean']['output'];
    /** Whether this is the first composable schema version. */
    isFirstComposableVersion: Scalars['Boolean']['output'];
    /** A schema version is valid if the composition and contract compositions are successful. */
    isValid: Scalars['Boolean']['output'];
    /**
     * The log that initiated this schema version.
     * For a federation schema this is the published or removed subgraph/service.
     */
    log: RegistryLog;
    /** The schema version against which this schema version was compared to in order to determine schema changes. */
    previousDiffableSchemaVersion?: Maybe<SchemaVersion>;
    safeSchemaChanges?: Maybe<SchemaChangeConnection>;
    /** Schema changes that were introduced in this schema version (compared to the previous version). */
    schemaChanges?: Maybe<SchemaChangeConnection>;
    schemaCompositionErrors?: Maybe<SchemaErrorConnection>;
    /**
     * The schemas that are composed within this schema version.
     * For federation these are the subgraphs/services.
     */
    schemas: SchemaConnection;
    /** The (public) schema SDL. */
    sdl?: Maybe<Scalars['String']['output']>;
    /** The supergraph SDL for a federation schema. */
    supergraph?: Maybe<Scalars['String']['output']>;
    /**
     * List of tags in the schema version. E.g. when using Federation.
     * Tags can be used for filtering the schema via contracts.
     */
    tags?: Maybe<Array<Scalars['String']['output']>>;
    unusedSchema?: Maybe<UnusedSchemaExplorer>;
    /**
     * A schema version is valid if the composition and contract compositions are successful.
     * @deprecated Use 'SchemaVersion.isValid' instead.
     */
    valid: Scalars['Boolean']['output'];
};
export type SchemaVersionDeprecatedSchemaArgs = {
    usage?: InputMaybe<DeprecatedSchemaExplorerUsageInput>;
};
export type SchemaVersionExplorerArgs = {
    usage?: InputMaybe<SchemaExplorerUsageInput>;
};
export type SchemaVersionUnusedSchemaArgs = {
    usage?: InputMaybe<UnusedSchemaExplorerUsageInput>;
};
export type SchemaVersionConnection = {
    __typename?: 'SchemaVersionConnection';
    edges: Array<SchemaVersionEdge>;
    pageInfo: PageInfo;
};
export type SchemaVersionEdge = {
    __typename?: 'SchemaVersionEdge';
    cursor: Scalars['String']['output'];
    node: SchemaVersion;
};
export type SchemaVersionGithubMetadata = {
    __typename?: 'SchemaVersionGithubMetadata';
    commit: Scalars['String']['output'];
    repository: Scalars['String']['output'];
};
export type SchemaVersionUpdateInput = {
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    targetSlug: Scalars['String']['input'];
    valid: Scalars['Boolean']['input'];
    versionId: Scalars['ID']['input'];
};
export type SchemaWarningConnection = {
    __typename?: 'SchemaWarningConnection';
    nodes: Array<SchemaCheckWarning>;
    total: Scalars['Int']['output'];
};
export type ServiceResourceAssignmentInput = {
    serviceName: Scalars['String']['input'];
};
/** Describes the impact of a schema change. */
export declare enum SeverityLevelType {
    /** The change will definetly break GraphQL client users. */
    Breaking = "BREAKING",
    /**
     * The change might break existing clients that do not follow
     * best-practises such as future-proof enums or future-proof interface/union type usages.
     */
    Dangerous = "DANGEROUS",
    /** The change is safe and does not break existing clients. */
    Safe = "SAFE"
}
export type SingleSchema = {
    __typename?: 'SingleSchema';
    author: Scalars['String']['output'];
    commit: Scalars['ID']['output'];
    date: Scalars['DateTime']['output'];
    id: Scalars['ID']['output'];
    metadata?: Maybe<Scalars['String']['output']>;
    source: Scalars['String']['output'];
};
export type SlackChannelInput = {
    channel: Scalars['String']['input'];
};
export type Subscription = {
    __typename?: 'Subscription';
    /**
     * Subscribe to logs from the OIDC provider integration.
     * Helpful for debugging failing logins.
     */
    oidcIntegrationLog: OidcIntegrationLogEvent;
};
export type SubscriptionOidcIntegrationLogArgs = {
    input: OidcIntegrationLogSubscriptionInput;
};
/** A successful schema check. */
export type SuccessfulSchemaCheck = SchemaCheck & {
    __typename?: 'SuccessfulSchemaCheck';
    /** Comment given when the schema check was approved. */
    approvalComment?: Maybe<Scalars['String']['output']>;
    /** The user that approved the schema check. */
    approvedBy?: Maybe<User>;
    /** Breaking changes can exist in an successful schema check if the check was manually approved. */
    breakingSchemaChanges?: Maybe<SchemaChangeConnection>;
    compositeSchemaSDL?: Maybe<Scalars['String']['output']>;
    /** Conditional breaking change metadata. */
    conditionalBreakingChangeMetadata?: Maybe<SchemaCheckConditionalBreakingChangeMetadata>;
    /** Optional context ID to group schema checks together. */
    contextId?: Maybe<Scalars['String']['output']>;
    /** Results of the contracts */
    contractChecks?: Maybe<ContractCheckConnection>;
    createdAt: Scalars['String']['output'];
    /** The GitHub repository associated with the schema check. */
    githubRepository?: Maybe<Scalars['String']['output']>;
    /** Whether this schema check has any schema changes. */
    hasSchemaChanges: Scalars['Boolean']['output'];
    /** Whether this schema check has any composition errors. */
    hasSchemaCompositionErrors: Scalars['Boolean']['output'];
    /** Whether this schema check has any breaking changes. */
    hasUnapprovedBreakingChanges: Scalars['Boolean']['output'];
    id: Scalars['ID']['output'];
    /** Whether the schema check was manually approved. */
    isApproved: Scalars['Boolean']['output'];
    /** Meta information about the schema check. */
    meta?: Maybe<SchemaCheckMeta>;
    /** The previous schema SDL. For composite schemas this is the service. */
    previousSchemaSDL?: Maybe<Scalars['String']['output']>;
    safeSchemaChanges?: Maybe<SchemaChangeConnection>;
    schemaChanges?: Maybe<SchemaChangeConnection>;
    /** Schema policy errors can exist in an successful schema check if the check was manually approved. */
    schemaPolicyErrors?: Maybe<SchemaPolicyWarningConnection>;
    schemaPolicyWarnings?: Maybe<SchemaPolicyWarningConnection>;
    /** The SDL of the schema that was checked. */
    schemaSDL: Scalars['String']['output'];
    /**
     * The schema version against this check was performed.
     * Is null if there is no schema version published yet.
     */
    schemaVersion?: Maybe<SchemaVersion>;
    /** The name of the service that owns the schema. Is null for non composite project types. */
    serviceName?: Maybe<Scalars['String']['output']>;
    supergraphSDL?: Maybe<Scalars['String']['output']>;
    /** The URL of the schema check on the Hive Web App. */
    webUrl?: Maybe<Scalars['String']['output']>;
};
export type SupergraphMetadata = {
    __typename?: 'SupergraphMetadata';
    metadata?: Maybe<Array<SchemaMetadata>>;
    /**
     * List of service names that own the field/type.
     * Resolves to null if the entity (field, type, scalar) does not belong to any service.
     */
    ownedByServiceNames?: Maybe<Array<Scalars['String']['output']>>;
};
export type SupportTicket = {
    __typename?: 'SupportTicket';
    comments?: Maybe<SupportTicketCommentConnection>;
    createdAt: Scalars['DateTime']['output'];
    description: Scalars['String']['output'];
    id: Scalars['ID']['output'];
    priority: SupportTicketPriority;
    status: SupportTicketStatus;
    subject: Scalars['String']['output'];
    updatedAt: Scalars['DateTime']['output'];
};
export type SupportTicketComment = {
    __typename?: 'SupportTicketComment';
    body: Scalars['String']['output'];
    createdAt: Scalars['DateTime']['output'];
    fromSupport: Scalars['Boolean']['output'];
    id: Scalars['ID']['output'];
};
export type SupportTicketCommentConnection = {
    __typename?: 'SupportTicketCommentConnection';
    edges: Array<SupportTicketCommentEdge>;
    pageInfo: PageInfo;
};
export type SupportTicketCommentEdge = {
    __typename?: 'SupportTicketCommentEdge';
    cursor: Scalars['String']['output'];
    node: SupportTicketComment;
};
export type SupportTicketConnection = {
    __typename?: 'SupportTicketConnection';
    edges: Array<SupportTicketEdge>;
    pageInfo: PageInfo;
};
export type SupportTicketCreateInput = {
    description: Scalars['String']['input'];
    organizationSlug: Scalars['String']['input'];
    priority: SupportTicketPriority;
    subject: Scalars['String']['input'];
};
/** @oneOf */
export type SupportTicketCreateResult = {
    __typename?: 'SupportTicketCreateResult';
    error?: Maybe<SupportTicketCreateResultError>;
    ok?: Maybe<SupportTicketCreateResultOk>;
};
export type SupportTicketCreateResultError = Error & {
    __typename?: 'SupportTicketCreateResultError';
    message: Scalars['String']['output'];
};
export type SupportTicketCreateResultOk = {
    __typename?: 'SupportTicketCreateResultOk';
    supportTicketId: Scalars['ID']['output'];
};
export type SupportTicketEdge = {
    __typename?: 'SupportTicketEdge';
    cursor: Scalars['String']['output'];
    node: SupportTicket;
};
export declare enum SupportTicketPriority {
    High = "HIGH",
    Normal = "NORMAL",
    Urgent = "URGENT"
}
export type SupportTicketReplyInput = {
    body: Scalars['String']['input'];
    organizationSlug: Scalars['String']['input'];
    ticketId: Scalars['String']['input'];
};
/** @oneOf */
export type SupportTicketReplyResult = {
    __typename?: 'SupportTicketReplyResult';
    error?: Maybe<SupportTicketReplyResultError>;
    ok?: Maybe<SupportTicketReplyResultOk>;
};
export type SupportTicketReplyResultError = Error & {
    __typename?: 'SupportTicketReplyResultError';
    message: Scalars['String']['output'];
};
export type SupportTicketReplyResultOk = {
    __typename?: 'SupportTicketReplyResultOk';
    supportTicketId: Scalars['ID']['output'];
};
export declare enum SupportTicketStatus {
    Open = "OPEN",
    Solved = "SOLVED"
}
export type Target = {
    __typename?: 'Target';
    /** Get a list of paginated schema contracts that are active for the target. */
    activeContracts: ContractConnection;
    appDeployment?: Maybe<AppDeployment>;
    /** The app deployments for this target. */
    appDeployments?: Maybe<AppDeploymentConnection>;
    baseSchema?: Maybe<Scalars['String']['output']>;
    /** A paginated connection of CDN tokens for accessing this target's artifacts. */
    cdnAccessTokens: TargetCdnAccessTokenConnection;
    /** The URL for accessing this target's artifacts via the CDN. */
    cdnUrl: Scalars['String']['output'];
    /** @deprecated Use the 'slug' field instead. */
    cleanId: Scalars['ID']['output'];
    /** Retrieve statistics for a clients usage. */
    clientStats: ClientStats;
    /** Configuration for conditional breaking change detection. */
    conditionalBreakingChangeConfiguration: ConditionalBreakingChangeConfiguration;
    /** Get a list of paginated schema contracts for the target. */
    contracts: ContractConnection;
    documentCollection?: Maybe<DocumentCollection>;
    documentCollectionOperation?: Maybe<DocumentCollectionOperation>;
    documentCollections: DocumentCollectionConnection;
    experimental_forcedLegacySchemaComposition: Scalars['Boolean']['output'];
    /** Whether a dangerous change fails a schema check and requires a manual approval. */
    failDiffOnDangerousChange: Scalars['Boolean']['output'];
    /**
     * The endpoint url of the target's explorer/laboratory instance.
     * This is the public endpoint configured in target's settings.
     */
    graphqlEndpointUrl?: Maybe<Scalars['String']['output']>;
    /** Whether any subscription operations were reported for this target. */
    hasCollectedSubscriptionOperations: Scalars['Boolean']['output'];
    hasSchema: Scalars['Boolean']['output'];
    id: Scalars['ID']['output'];
    /** The latest (potentially invalid) schema version. */
    latestSchemaVersion?: Maybe<SchemaVersion>;
    /** The latest valid (composable) schema version. */
    latestValidSchemaVersion?: Maybe<SchemaVersion>;
    /** @deprecated Use the 'slug' field instead. */
    name: Scalars['String']['output'];
    /** Retrieve an operation via it's hash. */
    operation?: Maybe<Operation>;
    /** Retrieve an overview of all operation statistics. */
    operationsStats: OperationsStats;
    preflightScript?: Maybe<PreflightScript>;
    project: Project;
    requestsOverTime: Array<RequestsOverTime>;
    /** Get a schema check for the target by ID. */
    schemaCheck?: Maybe<SchemaCheck>;
    /** Get a list of paginated schema checks for a target. */
    schemaChecks: SchemaCheckConnection;
    /** Retrieve statistics over a schema coordinates usage. */
    schemaCoordinateStats: SchemaCoordinateStats;
    /** Retreive a specific schema version in this target by it's id. */
    schemaVersion?: Maybe<SchemaVersion>;
    /** Paginated list of schema versions, ordered from recent to oldest. */
    schemaVersions: SchemaVersionConnection;
    schemaVersionsCount: Scalars['Int']['output'];
    slug: Scalars['String']['output'];
    tokens: TokenConnection;
    totalRequests: Scalars['SafeInt']['output'];
    viewerCanAccessSettings: Scalars['Boolean']['output'];
    viewerCanDelete: Scalars['Boolean']['output'];
    viewerCanModifyCDNAccessToken: Scalars['Boolean']['output'];
    viewerCanModifyLaboratory: Scalars['Boolean']['output'];
    viewerCanModifyPreflightScript: Scalars['Boolean']['output'];
    viewerCanModifySettings: Scalars['Boolean']['output'];
    viewerCanModifyTargetAccessToken: Scalars['Boolean']['output'];
    /** Whether the viewer can access the app deployments within a target. */
    viewerCanViewAppDeployments: Scalars['Boolean']['output'];
    viewerCanViewLaboratory: Scalars['Boolean']['output'];
};
export type TargetActiveContractsArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
};
export type TargetAppDeploymentArgs = {
    appName: Scalars['String']['input'];
    appVersion: Scalars['String']['input'];
};
export type TargetAppDeploymentsArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
};
export type TargetCdnAccessTokensArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
};
export type TargetClientStatsArgs = {
    clientName: Scalars['String']['input'];
    period: DateRangeInput;
};
export type TargetContractsArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
};
export type TargetDocumentCollectionArgs = {
    id: Scalars['ID']['input'];
};
export type TargetDocumentCollectionOperationArgs = {
    id: Scalars['ID']['input'];
};
export type TargetDocumentCollectionsArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
};
export type TargetOperationArgs = {
    hash: Scalars['ID']['input'];
};
export type TargetOperationsStatsArgs = {
    filter?: InputMaybe<OperationStatsFilterInput>;
    period: DateRangeInput;
};
export type TargetRequestsOverTimeArgs = {
    period: DateRangeInput;
    resolution: Scalars['Int']['input'];
};
export type TargetSchemaCheckArgs = {
    id: Scalars['ID']['input'];
};
export type TargetSchemaChecksArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    filters?: InputMaybe<SchemaChecksFilter>;
    first?: InputMaybe<Scalars['Int']['input']>;
};
export type TargetSchemaCoordinateStatsArgs = {
    period: DateRangeInput;
    schemaCoordinate: Scalars['String']['input'];
};
export type TargetSchemaVersionArgs = {
    id: Scalars['ID']['input'];
};
export type TargetSchemaVersionsArgs = {
    after?: InputMaybe<Scalars['String']['input']>;
    first?: InputMaybe<Scalars['Int']['input']>;
};
export type TargetSchemaVersionsCountArgs = {
    period?: InputMaybe<DateRangeInput>;
};
export type TargetTotalRequestsArgs = {
    period: DateRangeInput;
};
export declare enum TargetAccessScope {
    Delete = "DELETE",
    Read = "READ",
    RegistryRead = "REGISTRY_READ",
    RegistryWrite = "REGISTRY_WRITE",
    Settings = "SETTINGS",
    TokensRead = "TOKENS_READ",
    TokensWrite = "TOKENS_WRITE"
}
export type TargetAppDeploymentsResourceAssignment = {
    __typename?: 'TargetAppDeploymentsResourceAssignment';
    appDeployments?: Maybe<Array<Scalars['String']['output']>>;
    mode: ResourceAssignmentModeType;
};
export type TargetAppDeploymentsResourceAssignmentInput = {
    /** Specific app deployments within the target for which the permissions should be applied. */
    appDeployments?: InputMaybe<Array<AppDeploymentResourceAssignmentInput>>;
    /** Whether the permissions should apply for all app deployments within the target. */
    mode: ResourceAssignmentModeType;
};
export type TargetCdnAccessTokenConnection = {
    __typename?: 'TargetCdnAccessTokenConnection';
    edges: Array<TargetCdnAccessTokenEdge>;
    pageInfo: PageInfo;
};
export type TargetCdnAccessTokenEdge = {
    __typename?: 'TargetCdnAccessTokenEdge';
    cursor: Scalars['String']['output'];
    node: CdnAccessToken;
};
export type TargetConnection = {
    __typename?: 'TargetConnection';
    edges: Array<TargetEdge>;
    pageInfo: PageInfo;
};
export type TargetEdge = {
    __typename?: 'TargetEdge';
    cursor: Scalars['String']['output'];
    node: Target;
};
/** Reference to a target. */
export type TargetReferenceInput = 
/** Reference to a target using it's ID (see "Target.id" field). */
{
    byId: Scalars['ID']['input'];
    bySelector?: never;
} | /** Reference to a target using it's slug parts (see "Organization.slug", "Project.slug", "Target.slug"). */ {
    byId?: never;
    bySelector: TargetSelectorInput;
};
export type TargetResouceAssignment = {
    __typename?: 'TargetResouceAssignment';
    appDeployments: TargetAppDeploymentsResourceAssignment;
    services: TargetServicesResourceAssignment;
    target: Target;
    targetId: Scalars['ID']['output'];
};
export type TargetResourceAssignmentInput = {
    appDeployments: TargetAppDeploymentsResourceAssignmentInput;
    services: TargetServicesResourceAssignmentInput;
    targetId: Scalars['ID']['input'];
};
export type TargetSelector = {
    __typename?: 'TargetSelector';
    organizationSlug: Scalars['String']['output'];
    projectSlug: Scalars['String']['output'];
    targetSlug: Scalars['String']['output'];
};
export type TargetSelectorInput = {
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    targetSlug: Scalars['String']['input'];
};
export type TargetServicesResourceAssignment = {
    __typename?: 'TargetServicesResourceAssignment';
    mode: ResourceAssignmentModeType;
    services?: Maybe<Array<Scalars['String']['output']>>;
};
export type TargetServicesResourceAssignmentInput = {
    /** Whether the permissions should apply for all services within the target or only selected ones. */
    mode: ResourceAssignmentModeType;
    /** Specific services within the target for which the permissions should be applied. */
    services?: InputMaybe<Array<ServiceResourceAssignmentInput>>;
};
export type TeamsWebhookChannel = AlertChannel & {
    __typename?: 'TeamsWebhookChannel';
    endpoint: Scalars['String']['output'];
    id: Scalars['ID']['output'];
    name: Scalars['String']['output'];
    type: AlertChannelType;
};
export type TestExternalSchemaCompositionError = Error & {
    __typename?: 'TestExternalSchemaCompositionError';
    message: Scalars['String']['output'];
};
export type TestExternalSchemaCompositionInput = {
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
};
/** @oneOf */
export type TestExternalSchemaCompositionResult = {
    __typename?: 'TestExternalSchemaCompositionResult';
    error?: Maybe<TestExternalSchemaCompositionError>;
    ok?: Maybe<Project>;
};
export type Token = {
    __typename?: 'Token';
    alias: Scalars['String']['output'];
    date: Scalars['DateTime']['output'];
    id: Scalars['ID']['output'];
    lastUsedAt?: Maybe<Scalars['DateTime']['output']>;
    name: Scalars['String']['output'];
};
export type TokenConnection = {
    __typename?: 'TokenConnection';
    nodes: Array<Token>;
    total: Scalars['Int']['output'];
};
export type TokenInfo = {
    __typename?: 'TokenInfo';
    hasOrganizationScope: Scalars['Boolean']['output'];
    hasProjectScope: Scalars['Boolean']['output'];
    hasTargetScope: Scalars['Boolean']['output'];
    organization: Organization;
    project: Project;
    target: Target;
    token: Token;
};
export type TokenInfoHasOrganizationScopeArgs = {
    scope: OrganizationAccessScope;
};
export type TokenInfoHasProjectScopeArgs = {
    scope: ProjectAccessScope;
};
export type TokenInfoHasTargetScopeArgs = {
    scope: TargetAccessScope;
};
export type TokenInfoPayload = TokenInfo | TokenNotFoundError;
export type TokenNotFoundError = {
    __typename?: 'TokenNotFoundError';
    message: Scalars['String']['output'];
};
export type UnusedSchemaExplorer = {
    __typename?: 'UnusedSchemaExplorer';
    types: Array<GraphQlNamedType>;
};
export type UnusedSchemaExplorerUsageInput = {
    period: DateRangeInput;
};
export type UpdateBaseSchemaError = Error & {
    __typename?: 'UpdateBaseSchemaError';
    message: Scalars['String']['output'];
};
export type UpdateBaseSchemaInput = {
    newBase?: InputMaybe<Scalars['String']['input']>;
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    targetSlug: Scalars['String']['input'];
};
export type UpdateBaseSchemaOk = {
    __typename?: 'UpdateBaseSchemaOk';
    updatedTarget: Target;
};
export type UpdateBaseSchemaResult = {
    __typename?: 'UpdateBaseSchemaResult';
    error?: Maybe<UpdateBaseSchemaError>;
    ok?: Maybe<UpdateBaseSchemaOk>;
};
export type UpdateDocumentCollectionInput = {
    collectionId: Scalars['ID']['input'];
    description?: InputMaybe<Scalars['String']['input']>;
    name: Scalars['String']['input'];
};
export type UpdateDocumentCollectionOperationInput = {
    collectionId: Scalars['ID']['input'];
    headers?: InputMaybe<Scalars['String']['input']>;
    name?: InputMaybe<Scalars['String']['input']>;
    operationId: Scalars['ID']['input'];
    query?: InputMaybe<Scalars['String']['input']>;
    variables?: InputMaybe<Scalars['String']['input']>;
};
export type UpdateMeError = Error & {
    __typename?: 'UpdateMeError';
    /** The detailed validation error messages for the input fields. */
    inputErrors: UpdateMeInputErrors;
    message: Scalars['String']['output'];
};
export type UpdateMeInput = {
    displayName: Scalars['String']['input'];
    fullName: Scalars['String']['input'];
};
export type UpdateMeInputErrors = {
    __typename?: 'UpdateMeInputErrors';
    displayName?: Maybe<Scalars['String']['output']>;
    fullName?: Maybe<Scalars['String']['output']>;
};
export type UpdateMeOk = {
    __typename?: 'UpdateMeOk';
    updatedUser: User;
};
/** @oneOf */
export type UpdateMeResult = {
    __typename?: 'UpdateMeResult';
    error?: Maybe<UpdateMeError>;
    ok?: Maybe<UpdateMeOk>;
};
export type UpdateMemberRoleInput = {
    description: Scalars['String']['input'];
    /** The member role that should be udpated. */
    memberRole: MemberRoleReferenceInput;
    name: Scalars['String']['input'];
    selectedPermissions: Array<Scalars['String']['input']>;
};
export type UpdateMemberRoleInputErrors = {
    __typename?: 'UpdateMemberRoleInputErrors';
    description?: Maybe<Scalars['String']['output']>;
    name?: Maybe<Scalars['String']['output']>;
};
/** @oneOf */
export type UpdateMemberRoleResult = {
    __typename?: 'UpdateMemberRoleResult';
    error?: Maybe<UpdateMemberRoleResultError>;
    ok?: Maybe<UpdateMemberRoleResultOk>;
};
export type UpdateMemberRoleResultError = {
    __typename?: 'UpdateMemberRoleResultError';
    /** The detailed validation error messages for the input fields. */
    inputErrors?: Maybe<UpdateMemberRoleInputErrors>;
    message: Scalars['String']['output'];
};
export type UpdateMemberRoleResultOk = {
    __typename?: 'UpdateMemberRoleResultOk';
    updatedRole: MemberRole;
};
export type UpdateNativeFederationError = Error & {
    __typename?: 'UpdateNativeFederationError';
    message: Scalars['String']['output'];
};
export type UpdateNativeFederationInput = {
    enabled: Scalars['Boolean']['input'];
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
};
/** @oneOf */
export type UpdateNativeFederationResult = {
    __typename?: 'UpdateNativeFederationResult';
    error?: Maybe<UpdateNativeFederationError>;
    ok?: Maybe<Project>;
};
export type UpdateOidcDefaultMemberRoleError = Error & {
    __typename?: 'UpdateOIDCDefaultMemberRoleError';
    message: Scalars['String']['output'];
};
export type UpdateOidcDefaultMemberRoleInput = {
    defaultMemberRoleId: Scalars['ID']['input'];
    oidcIntegrationId: Scalars['ID']['input'];
};
export type UpdateOidcDefaultMemberRoleOk = {
    __typename?: 'UpdateOIDCDefaultMemberRoleOk';
    updatedOIDCIntegration: OidcIntegration;
};
/** @oneOf */
export type UpdateOidcDefaultMemberRoleResult = {
    __typename?: 'UpdateOIDCDefaultMemberRoleResult';
    error?: Maybe<UpdateOidcDefaultMemberRoleError>;
    ok?: Maybe<UpdateOidcDefaultMemberRoleOk>;
};
export type UpdateOidcIntegrationError = Error & {
    __typename?: 'UpdateOIDCIntegrationError';
    details: UpdateOidcIntegrationErrorDetails;
    message: Scalars['String']['output'];
};
export type UpdateOidcIntegrationErrorDetails = {
    __typename?: 'UpdateOIDCIntegrationErrorDetails';
    authorizationEndpoint?: Maybe<Scalars['String']['output']>;
    clientId?: Maybe<Scalars['String']['output']>;
    clientSecret?: Maybe<Scalars['String']['output']>;
    tokenEndpoint?: Maybe<Scalars['String']['output']>;
    userinfoEndpoint?: Maybe<Scalars['String']['output']>;
};
export type UpdateOidcIntegrationInput = {
    authorizationEndpoint?: InputMaybe<Scalars['String']['input']>;
    clientId?: InputMaybe<Scalars['ID']['input']>;
    clientSecret?: InputMaybe<Scalars['String']['input']>;
    oidcIntegrationId: Scalars['ID']['input'];
    tokenEndpoint?: InputMaybe<Scalars['String']['input']>;
    userinfoEndpoint?: InputMaybe<Scalars['String']['input']>;
};
export type UpdateOidcIntegrationOk = {
    __typename?: 'UpdateOIDCIntegrationOk';
    updatedOIDCIntegration: OidcIntegration;
};
export type UpdateOidcIntegrationResult = {
    __typename?: 'UpdateOIDCIntegrationResult';
    error?: Maybe<UpdateOidcIntegrationError>;
    ok?: Maybe<UpdateOidcIntegrationOk>;
};
export type UpdateOidcRestrictionsError = Error & {
    __typename?: 'UpdateOIDCRestrictionsError';
    message: Scalars['String']['output'];
};
export type UpdateOidcRestrictionsInput = {
    oidcIntegrationId: Scalars['ID']['input'];
    /**
     * Applies only to newly invited members.
     * Existing members are not affected.
     */
    oidcUserAccessOnly: Scalars['Boolean']['input'];
};
export type UpdateOidcRestrictionsOk = {
    __typename?: 'UpdateOIDCRestrictionsOk';
    updatedOIDCIntegration: OidcIntegration;
};
/** @oneOf */
export type UpdateOidcRestrictionsResult = {
    __typename?: 'UpdateOIDCRestrictionsResult';
    error?: Maybe<UpdateOidcRestrictionsError>;
    ok?: Maybe<UpdateOidcRestrictionsOk>;
};
export type UpdateOrganizationSlugError = Error & {
    __typename?: 'UpdateOrganizationSlugError';
    message: Scalars['String']['output'];
};
export type UpdateOrganizationSlugInput = {
    organizationSlug: Scalars['String']['input'];
    slug: Scalars['String']['input'];
};
export type UpdateOrganizationSlugOk = {
    __typename?: 'UpdateOrganizationSlugOk';
    updatedOrganizationPayload: OrganizationPayload;
};
export type UpdateOrganizationSlugResult = {
    __typename?: 'UpdateOrganizationSlugResult';
    error?: Maybe<UpdateOrganizationSlugError>;
    ok?: Maybe<UpdateOrganizationSlugOk>;
};
export type UpdatePreflightScriptInput = {
    selector: TargetSelectorInput;
    sourceCode: Scalars['String']['input'];
};
export type UpdateProjectGitRepositoryError = Error & {
    __typename?: 'UpdateProjectGitRepositoryError';
    message: Scalars['String']['output'];
};
export type UpdateProjectGitRepositoryInput = {
    gitRepository?: InputMaybe<Scalars['String']['input']>;
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
};
export type UpdateProjectGitRepositoryOk = {
    __typename?: 'UpdateProjectGitRepositoryOk';
    selector: ProjectSelector;
    updatedProject: Project;
};
export type UpdateProjectGitRepositoryResult = {
    __typename?: 'UpdateProjectGitRepositoryResult';
    error?: Maybe<UpdateProjectGitRepositoryError>;
    ok?: Maybe<UpdateProjectGitRepositoryOk>;
};
export type UpdateProjectPayload = {
    __typename?: 'UpdateProjectPayload';
    selector: ProjectSelector;
    updatedProject: Project;
};
export type UpdateProjectSlugError = {
    __typename?: 'UpdateProjectSlugError';
    message: Scalars['String']['output'];
};
export type UpdateProjectSlugInput = {
    project: ProjectReferenceInput;
    slug: Scalars['String']['input'];
};
export type UpdateProjectSlugOk = {
    __typename?: 'UpdateProjectSlugOk';
    updatedProject: Project;
};
export type UpdateProjectSlugResult = {
    __typename?: 'UpdateProjectSlugResult';
    error?: Maybe<UpdateProjectSlugError>;
    ok?: Maybe<UpdateProjectSlugOk>;
};
export type UpdateSchemaPolicyResult = {
    __typename?: 'UpdateSchemaPolicyResult';
    error?: Maybe<Error>;
    ok?: Maybe<UpdateSchemaPolicyResultOk>;
};
export type UpdateSchemaPolicyResultError = Error & {
    __typename?: 'UpdateSchemaPolicyResultError';
    code?: Maybe<Scalars['String']['output']>;
    message: Scalars['String']['output'];
};
export type UpdateSchemaPolicyResultOk = {
    __typename?: 'UpdateSchemaPolicyResultOk';
    organization?: Maybe<Organization>;
    project?: Maybe<Project>;
    updatedPolicy: SchemaPolicy;
};
export type UpdateTargetConditionalBreakingChangeConfigurationInput = {
    /** Updates to the conditional breaking change configuration. */
    conditionalBreakingChangeConfiguration: ConditionalBreakingChangeConfigurationInput;
    /** The target on which the settings are adjusted. */
    target: TargetReferenceInput;
};
export type UpdateTargetConditionalBreakingChangeConfigurationInputErrors = {
    __typename?: 'UpdateTargetConditionalBreakingChangeConfigurationInputErrors';
    percentage?: Maybe<Scalars['String']['output']>;
    period?: Maybe<Scalars['String']['output']>;
    requestCount?: Maybe<Scalars['String']['output']>;
    targetIds?: Maybe<Scalars['String']['output']>;
};
export type UpdateTargetConditionalBreakingChangeConfigurationResult = {
    __typename?: 'UpdateTargetConditionalBreakingChangeConfigurationResult';
    error?: Maybe<UpdateTargetConditionalBreakingChangeConfigurationResultError>;
    ok?: Maybe<UpdateTargetConditionalBreakingChangeConfigurationResultOk>;
};
export type UpdateTargetConditionalBreakingChangeConfigurationResultError = {
    __typename?: 'UpdateTargetConditionalBreakingChangeConfigurationResultError';
    inputErrors: UpdateTargetConditionalBreakingChangeConfigurationInputErrors;
    message: Scalars['String']['output'];
};
export type UpdateTargetConditionalBreakingChangeConfigurationResultOk = {
    __typename?: 'UpdateTargetConditionalBreakingChangeConfigurationResultOk';
    target: Target;
};
export type UpdateTargetDangerousChangeClassificationInput = {
    failDiffOnDangerousChange: Scalars['Boolean']['input'];
    target: TargetReferenceInput;
};
export type UpdateTargetDangerousChangeClassificationResult = {
    __typename?: 'UpdateTargetDangerousChangeClassificationResult';
    error?: Maybe<UpdateTargetDangerousChangeClassificationResultError>;
    ok?: Maybe<UpdateTargetDangerousChangeClassificationResultOk>;
};
export type UpdateTargetDangerousChangeClassificationResultError = {
    __typename?: 'UpdateTargetDangerousChangeClassificationResultError';
    message: Scalars['String']['output'];
};
export type UpdateTargetDangerousChangeClassificationResultOk = {
    __typename?: 'UpdateTargetDangerousChangeClassificationResultOk';
    target: Target;
};
export type UpdateTargetGraphQlEndpointUrlInput = {
    graphqlEndpointUrl?: InputMaybe<Scalars['String']['input']>;
    target: TargetReferenceInput;
};
export type UpdateTargetGraphQlEndpointUrlResult = {
    __typename?: 'UpdateTargetGraphQLEndpointUrlResult';
    error?: Maybe<UpdateTargetGraphQlEndpointUrlResultError>;
    ok?: Maybe<UpdateTargetGraphQlEndpointUrlResultOk>;
};
export type UpdateTargetGraphQlEndpointUrlResultError = {
    __typename?: 'UpdateTargetGraphQLEndpointUrlResultError';
    message: Scalars['String']['output'];
};
export type UpdateTargetGraphQlEndpointUrlResultOk = {
    __typename?: 'UpdateTargetGraphQLEndpointUrlResultOk';
    target: Target;
};
export type UpdateTargetSlugInput = {
    slug: Scalars['String']['input'];
    target: TargetReferenceInput;
};
export type UpdateTargetSlugResult = {
    __typename?: 'UpdateTargetSlugResult';
    error?: Maybe<UpdateTargetSlugResultError>;
    ok?: Maybe<UpdateTargetSlugResultOk>;
};
export type UpdateTargetSlugResultError = {
    __typename?: 'UpdateTargetSlugResultError';
    message: Scalars['String']['output'];
};
export type UpdateTargetSlugResultOk = {
    __typename?: 'UpdateTargetSlugResultOk';
    selector: TargetSelector;
    target: Target;
};
export type UpgradeToProInput = {
    couponCode?: InputMaybe<Scalars['String']['input']>;
    monthlyLimits: RateLimitInput;
    organization: OrganizationSelectorInput;
    paymentMethodId?: InputMaybe<Scalars['String']['input']>;
};
export type UsageEstimation = {
    __typename?: 'UsageEstimation';
    operations: Scalars['SafeInt']['output'];
};
export type UsageEstimationInput = {
    month: Scalars['Int']['input'];
    organizationSlug: Scalars['String']['input'];
    year: Scalars['Int']['input'];
};
export declare enum UsageRateLimitType {
    MonthlyLimited = "MONTHLY_LIMITED",
    MonthlyQuota = "MONTHLY_QUOTA",
    Unlimited = "UNLIMITED"
}
export type User = {
    __typename?: 'User';
    canSwitchOrganization: Scalars['Boolean']['output'];
    displayName: Scalars['String']['output'];
    email: Scalars['String']['output'];
    fullName: Scalars['String']['output'];
    id: Scalars['ID']['output'];
    isAdmin: Scalars['Boolean']['output'];
    provider: AuthProviderType;
};
export type UserConnection = {
    __typename?: 'UserConnection';
    nodes: Array<User>;
    total: Scalars['Int']['output'];
};
export type WebhookChannelInput = {
    endpoint: Scalars['String']['input'];
};
export type CreateAppDeploymentMutationVariables = Exact<{
    input: CreateAppDeploymentInput;
}>;
export type CreateAppDeploymentMutation = {
    __typename?: 'Mutation';
    createAppDeployment: {
        __typename?: 'CreateAppDeploymentResult';
        ok?: {
            __typename?: 'CreateAppDeploymentOk';
            createdAppDeployment: {
                __typename?: 'AppDeployment';
                id: string;
                name: string;
                version: string;
                status: AppDeploymentStatus;
            };
        } | null;
        error?: {
            __typename?: 'CreateAppDeploymentError';
            message: string;
        } | null;
    };
};
export type AddDocumentsToAppDeploymentMutationVariables = Exact<{
    input: AddDocumentsToAppDeploymentInput;
}>;
export type AddDocumentsToAppDeploymentMutation = {
    __typename?: 'Mutation';
    addDocumentsToAppDeployment: {
        __typename?: 'AddDocumentsToAppDeploymentResult';
        ok?: {
            __typename?: 'AddDocumentsToAppDeploymentOk';
            appDeployment: {
                __typename?: 'AppDeployment';
                id: string;
                name: string;
                version: string;
                status: AppDeploymentStatus;
            };
        } | null;
        error?: {
            __typename?: 'AddDocumentsToAppDeploymentError';
            message: string;
            details?: {
                __typename: 'AddDocumentsToAppDeploymentErrorDetails';
                index: number;
                message: string;
            } | null;
        } | null;
    };
};
export type ActivateAppDeploymentMutationVariables = Exact<{
    input: ActivateAppDeploymentInput;
}>;
export type ActivateAppDeploymentMutation = {
    __typename?: 'Mutation';
    activateAppDeployment: {
        __typename?: 'ActivateAppDeploymentResult';
        ok?: {
            __typename?: 'ActivateAppDeploymentOk';
            isSkipped: boolean;
            activatedAppDeployment: {
                __typename?: 'AppDeployment';
                id: string;
                name: string;
                version: string;
                status: AppDeploymentStatus;
            };
        } | null;
        error?: {
            __typename?: 'ActivateAppDeploymentError';
            message: string;
        } | null;
    };
};
export type Cli_SchemaComposeMutationMutationVariables = Exact<{
    input: SchemaComposeInput;
}>;
export type Cli_SchemaComposeMutationMutation = {
    __typename?: 'Mutation';
    schemaCompose: {
        __typename: 'SchemaComposeError';
        message: string;
    } | {
        __typename: 'SchemaComposeSuccess';
        valid: boolean;
        compositionResult: {
            __typename?: 'SchemaCompositionResult';
            supergraphSdl?: string | null;
            errors?: ({
                __typename?: 'SchemaErrorConnection';
            } & {
                ' $fragmentRefs'?: {
                    'RenderErrors_SchemaErrorConnectionFragmentFragment': RenderErrors_SchemaErrorConnectionFragmentFragment;
                };
            }) | null;
        };
    };
};
export type FetchLatestVersionQueryVariables = Exact<{
    target?: InputMaybe<TargetReferenceInput>;
}>;
export type FetchLatestVersionQuery = {
    __typename?: 'Query';
    latestValidVersion?: {
        __typename?: 'SchemaVersion';
        sdl?: string | null;
    } | null;
};
export type SchemaCheckMutationVariables = Exact<{
    input: SchemaCheckInput;
}>;
export type SchemaCheckMutation = {
    __typename?: 'Mutation';
    schemaCheck: {
        __typename: 'GitHubSchemaCheckError';
        message: string;
    } | {
        __typename: 'GitHubSchemaCheckSuccess';
        message: string;
    } | {
        __typename: 'SchemaCheckError';
        valid: boolean;
        changes?: ({
            __typename?: 'SchemaChangeConnection';
            edges: Array<{
                __typename: 'SchemaChangeEdge';
            }>;
        } & {
            ' $fragmentRefs'?: {
                'RenderChanges_SchemaChangesFragment': RenderChanges_SchemaChangesFragment;
            };
        }) | null;
        warnings?: {
            __typename?: 'SchemaWarningConnection';
            total: number;
            nodes: Array<{
                __typename?: 'SchemaCheckWarning';
                message: string;
                source?: string | null;
                line?: number | null;
                column?: number | null;
            }>;
        } | null;
        errors: ({
            __typename?: 'SchemaErrorConnection';
        } & {
            ' $fragmentRefs'?: {
                'RenderErrors_SchemaErrorConnectionFragmentFragment': RenderErrors_SchemaErrorConnectionFragmentFragment;
            };
        });
        schemaCheck?: {
            __typename?: 'FailedSchemaCheck';
            webUrl?: string | null;
        } | {
            __typename?: 'SuccessfulSchemaCheck';
            webUrl?: string | null;
        } | null;
    } | {
        __typename: 'SchemaCheckSuccess';
        valid: boolean;
        initial: boolean;
        warnings?: {
            __typename?: 'SchemaWarningConnection';
            total: number;
            nodes: Array<{
                __typename?: 'SchemaCheckWarning';
                message: string;
                source?: string | null;
                line?: number | null;
                column?: number | null;
            }>;
        } | null;
        changes?: ({
            __typename?: 'SchemaChangeConnection';
            edges: Array<{
                __typename: 'SchemaChangeEdge';
            }>;
        } & {
            ' $fragmentRefs'?: {
                'RenderChanges_SchemaChangesFragment': RenderChanges_SchemaChangesFragment;
            };
        }) | null;
        schemaCheck?: {
            __typename?: 'FailedSchemaCheck';
            webUrl?: string | null;
        } | {
            __typename?: 'SuccessfulSchemaCheck';
            webUrl?: string | null;
        } | null;
    };
};
export type SchemaDeleteMutationVariables = Exact<{
    input: SchemaDeleteInput;
}>;
export type SchemaDeleteMutation = {
    __typename?: 'Mutation';
    schemaDelete: {
        __typename: 'SchemaDeleteError';
        valid: boolean;
        errors: ({
            __typename?: 'SchemaErrorConnection';
        } & {
            ' $fragmentRefs'?: {
                'RenderErrors_SchemaErrorConnectionFragmentFragment': RenderErrors_SchemaErrorConnectionFragmentFragment;
            };
        });
    } | {
        __typename: 'SchemaDeleteSuccess';
        valid: boolean;
        errors: ({
            __typename?: 'SchemaErrorConnection';
        } & {
            ' $fragmentRefs'?: {
                'RenderErrors_SchemaErrorConnectionFragmentFragment': RenderErrors_SchemaErrorConnectionFragmentFragment;
            };
        });
    };
};
export type SchemaVersionForActionIdQueryVariables = Exact<{
    actionId: Scalars['ID']['input'];
    includeSDL: Scalars['Boolean']['input'];
    includeSupergraph: Scalars['Boolean']['input'];
    includeSubgraphs: Scalars['Boolean']['input'];
    target?: InputMaybe<TargetReferenceInput>;
}>;
export type SchemaVersionForActionIdQuery = {
    __typename?: 'Query';
    schemaVersionForActionId?: {
        __typename?: 'SchemaVersion';
        id: string;
        isValid: boolean;
        sdl?: string | null;
        supergraph?: string | null;
        schemas?: {
            __typename?: 'SchemaConnection';
            edges: Array<{
                __typename?: 'SchemaEdge';
                node: {
                    __typename: 'CompositeSchema';
                    id: string;
                    date: any;
                    url?: string | null;
                    service?: string | null;
                } | {
                    __typename: 'SingleSchema';
                    id: string;
                    date: any;
                };
            }>;
        };
    } | null;
};
export type LatestSchemaVersionQueryVariables = Exact<{
    includeSDL: Scalars['Boolean']['input'];
    includeSupergraph: Scalars['Boolean']['input'];
    includeSubgraphs: Scalars['Boolean']['input'];
    target?: InputMaybe<TargetReferenceInput>;
}>;
export type LatestSchemaVersionQuery = {
    __typename?: 'Query';
    latestValidVersion?: {
        __typename?: 'SchemaVersion';
        id: string;
        isValid: boolean;
        sdl?: string | null;
        supergraph?: string | null;
        schemas?: {
            __typename?: 'SchemaConnection';
            edges: Array<{
                __typename?: 'SchemaEdge';
                node: {
                    __typename: 'CompositeSchema';
                    id: string;
                    date: any;
                    url?: string | null;
                    service?: string | null;
                } | {
                    __typename: 'SingleSchema';
                    id: string;
                    date: any;
                };
            }>;
        };
    } | null;
};
export type SchemaPublishMutationVariables = Exact<{
    input: SchemaPublishInput;
    usesGitHubApp: Scalars['Boolean']['input'];
}>;
export type SchemaPublishMutation = {
    __typename?: 'Mutation';
    schemaPublish: {
        __typename: 'GitHubSchemaPublishError';
        message: string;
    } | {
        __typename: 'GitHubSchemaPublishSuccess';
        message: string;
    } | {
        __typename: 'SchemaPublishError';
        valid: boolean;
        linkToWebsite?: string | null;
        changes?: ({
            __typename?: 'SchemaChangeConnection';
            edges: Array<{
                __typename: 'SchemaChangeEdge';
            }>;
        } & {
            ' $fragmentRefs'?: {
                'RenderChanges_SchemaChangesFragment': RenderChanges_SchemaChangesFragment;
            };
        }) | null;
        errors: ({
            __typename?: 'SchemaErrorConnection';
        } & {
            ' $fragmentRefs'?: {
                'RenderErrors_SchemaErrorConnectionFragmentFragment': RenderErrors_SchemaErrorConnectionFragmentFragment;
            };
        });
    } | {
        __typename: 'SchemaPublishMissingServiceError';
        missingServiceError: string;
    } | {
        __typename: 'SchemaPublishMissingUrlError';
        missingUrlError: string;
    } | {
        __typename: 'SchemaPublishRetry';
        reason: string;
    } | {
        __typename: 'SchemaPublishSuccess';
        initial: boolean;
        valid: boolean;
        linkToWebsite?: string | null;
        successMessage?: string | null;
        changes?: ({
            __typename?: 'SchemaChangeConnection';
            edges: Array<{
                __typename: 'SchemaChangeEdge';
            }>;
        } & {
            ' $fragmentRefs'?: {
                'RenderChanges_SchemaChangesFragment': RenderChanges_SchemaChangesFragment;
            };
        }) | null;
    };
};
export type MyTokenInfoQueryVariables = Exact<{
    [key: string]: never;
}>;
export type MyTokenInfoQuery = {
    __typename?: 'Query';
    tokenInfo: {
        __typename: 'TokenInfo';
        canPublishSchema: boolean;
        canCheckSchema: boolean;
        token: {
            __typename?: 'Token';
            name: string;
        };
        organization: {
            __typename?: 'Organization';
            slug: string;
        };
        project: {
            __typename?: 'Project';
            type: ProjectType;
            slug: string;
        };
        target: {
            __typename?: 'Target';
            slug: string;
        };
    } | {
        __typename: 'TokenNotFoundError';
        message: string;
    };
};
export type RenderErrors_SchemaErrorConnectionFragmentFragment = {
    __typename?: 'SchemaErrorConnection';
    edges: Array<{
        __typename?: 'SchemaErrorEdge';
        node: {
            __typename?: 'SchemaError';
            message: string;
        };
    }>;
} & {
    ' $fragmentName'?: 'RenderErrors_SchemaErrorConnectionFragmentFragment';
};
export type RenderChanges_SchemaChangesFragment = {
    __typename?: 'SchemaChangeConnection';
    edges: Array<{
        __typename?: 'SchemaChangeEdge';
        node: {
            __typename?: 'SchemaChange';
            severityLevel: SeverityLevelType;
            isSafeBasedOnUsage: boolean;
            message: string;
            approval?: {
                __typename?: 'SchemaChangeApproval';
                approvedBy?: {
                    __typename?: 'User';
                    displayName: string;
                } | null;
            } | null;
        };
    }>;
} & {
    ' $fragmentName'?: 'RenderChanges_SchemaChangesFragment';
};
export declare const RenderErrors_SchemaErrorConnectionFragmentFragmentDoc: DocumentNode<RenderErrors_SchemaErrorConnectionFragmentFragment, unknown>;
export declare const RenderChanges_SchemaChangesFragmentDoc: DocumentNode<RenderChanges_SchemaChangesFragment, unknown>;
export declare const CreateAppDeploymentDocument: DocumentNode<CreateAppDeploymentMutation, CreateAppDeploymentMutationVariables>;
export declare const AddDocumentsToAppDeploymentDocument: DocumentNode<AddDocumentsToAppDeploymentMutation, AddDocumentsToAppDeploymentMutationVariables>;
export declare const ActivateAppDeploymentDocument: DocumentNode<ActivateAppDeploymentMutation, ActivateAppDeploymentMutationVariables>;
export declare const Cli_SchemaComposeMutationDocument: DocumentNode<Cli_SchemaComposeMutationMutation, Cli_SchemaComposeMutationMutationVariables>;
export declare const FetchLatestVersionDocument: DocumentNode<FetchLatestVersionQuery, FetchLatestVersionQueryVariables>;
export declare const SchemaCheckDocument: DocumentNode<SchemaCheckMutation, SchemaCheckMutationVariables>;
export declare const SchemaDeleteDocument: DocumentNode<SchemaDeleteMutation, SchemaDeleteMutationVariables>;
export declare const SchemaVersionForActionIdDocument: DocumentNode<SchemaVersionForActionIdQuery, SchemaVersionForActionIdQueryVariables>;
export declare const LatestSchemaVersionDocument: DocumentNode<LatestSchemaVersionQuery, LatestSchemaVersionQueryVariables>;
export declare const SchemaPublishDocument: DocumentNode<SchemaPublishMutation, SchemaPublishMutationVariables>;
export declare const MyTokenInfoDocument: DocumentNode<MyTokenInfoQuery, MyTokenInfoQueryVariables>;
//# sourceMappingURL=graphql.d.ts.map