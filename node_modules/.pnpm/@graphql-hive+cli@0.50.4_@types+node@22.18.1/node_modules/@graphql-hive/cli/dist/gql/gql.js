"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.graphql = graphql;
const tslib_1 = require("tslib");
/* eslint-disable */
const types = tslib_1.__importStar(require("./graphql"));
const documents = {
    "\n  mutation CreateAppDeployment($input: CreateAppDeploymentInput!) {\n    createAppDeployment(input: $input) {\n      ok {\n        createdAppDeployment {\n          id\n          name\n          version\n          status\n        }\n      }\n      error {\n        message\n      }\n    }\n  }\n": types.CreateAppDeploymentDocument,
    "\n  mutation AddDocumentsToAppDeployment($input: AddDocumentsToAppDeploymentInput!) {\n    addDocumentsToAppDeployment(input: $input) {\n      ok {\n        appDeployment {\n          id\n          name\n          version\n          status\n        }\n      }\n      error {\n        message\n        details {\n          index\n          message\n          __typename\n        }\n      }\n    }\n  }\n": types.AddDocumentsToAppDeploymentDocument,
    "\n  mutation ActivateAppDeployment($input: ActivateAppDeploymentInput!) {\n    activateAppDeployment(input: $input) {\n      ok {\n        activatedAppDeployment {\n          id\n          name\n          version\n          status\n        }\n        isSkipped\n      }\n      error {\n        message\n      }\n    }\n  }\n": types.ActivateAppDeploymentDocument,
    "\n  mutation CLI_SchemaComposeMutation($input: SchemaComposeInput!) {\n    schemaCompose(input: $input) {\n      __typename\n      ... on SchemaComposeSuccess {\n        valid\n        compositionResult {\n          supergraphSdl\n          errors {\n            ...RenderErrors_SchemaErrorConnectionFragment\n          }\n        }\n      }\n      ... on SchemaComposeError {\n        message\n      }\n    }\n  }\n": types.Cli_SchemaComposeMutationDocument,
    "\n  query fetchLatestVersion($target: TargetReferenceInput) {\n    latestValidVersion(target: $target) {\n      sdl\n    }\n  }\n": types.FetchLatestVersionDocument,
    "\n  mutation schemaCheck($input: SchemaCheckInput!) {\n    schemaCheck(input: $input) {\n      __typename\n      ... on SchemaCheckSuccess {\n        valid\n        initial\n        warnings {\n          nodes {\n            message\n            source\n            line\n            column\n          }\n          total\n        }\n        changes {\n          edges {\n            __typename\n          }\n          ...RenderChanges_schemaChanges\n        }\n        schemaCheck {\n          webUrl\n        }\n      }\n      ... on SchemaCheckError {\n        valid\n        changes {\n          edges {\n            __typename\n          }\n          ...RenderChanges_schemaChanges\n        }\n        warnings {\n          nodes {\n            message\n            source\n            line\n            column\n          }\n          total\n        }\n        errors {\n          ...RenderErrors_SchemaErrorConnectionFragment\n        }\n        schemaCheck {\n          webUrl\n        }\n      }\n      ... on GitHubSchemaCheckSuccess {\n        message\n      }\n      ... on GitHubSchemaCheckError {\n        message\n      }\n    }\n  }\n": types.SchemaCheckDocument,
    "\n  mutation schemaDelete($input: SchemaDeleteInput!) {\n    schemaDelete(input: $input) {\n      __typename\n      ... on SchemaDeleteSuccess {\n        valid\n        errors {\n          ...RenderErrors_SchemaErrorConnectionFragment\n        }\n      }\n      ... on SchemaDeleteError {\n        valid\n        errors {\n          ...RenderErrors_SchemaErrorConnectionFragment\n        }\n      }\n    }\n  }\n": types.SchemaDeleteDocument,
    "\n  query SchemaVersionForActionId(\n    $actionId: ID!\n    $includeSDL: Boolean!\n    $includeSupergraph: Boolean!\n    $includeSubgraphs: Boolean!\n    $target: TargetReferenceInput\n  ) {\n    schemaVersionForActionId(actionId: $actionId, target: $target) {\n      id\n      isValid\n      sdl @include(if: $includeSDL)\n      supergraph @include(if: $includeSupergraph)\n      schemas @include(if: $includeSubgraphs) {\n        edges {\n          node {\n            __typename\n            ... on SingleSchema {\n              id\n              date\n            }\n            ... on CompositeSchema {\n              id\n              date\n              url\n              service\n            }\n          }\n        }\n      }\n    }\n  }\n": types.SchemaVersionForActionIdDocument,
    "\n  query LatestSchemaVersion(\n    $includeSDL: Boolean!\n    $includeSupergraph: Boolean!\n    $includeSubgraphs: Boolean!\n    $target: TargetReferenceInput\n  ) {\n    latestValidVersion(target: $target) {\n      id\n      isValid\n      sdl @include(if: $includeSDL)\n      supergraph @include(if: $includeSupergraph)\n      schemas @include(if: $includeSubgraphs) {\n        edges {\n          node {\n            __typename\n            ... on SingleSchema {\n              id\n              date\n            }\n            ... on CompositeSchema {\n              id\n              date\n              url\n              service\n            }\n          }\n        }\n      }\n    }\n  }\n": types.LatestSchemaVersionDocument,
    "\n  mutation schemaPublish($input: SchemaPublishInput!, $usesGitHubApp: Boolean!) {\n    schemaPublish(input: $input) {\n      __typename\n      ... on SchemaPublishSuccess @skip(if: $usesGitHubApp) {\n        initial\n        valid\n        successMessage: message\n        linkToWebsite\n        changes {\n          edges {\n            __typename\n          }\n          ...RenderChanges_schemaChanges\n        }\n      }\n      ... on SchemaPublishError @skip(if: $usesGitHubApp) {\n        valid\n        linkToWebsite\n        changes {\n          edges {\n            __typename\n          }\n          ...RenderChanges_schemaChanges\n        }\n        errors {\n          ...RenderErrors_SchemaErrorConnectionFragment\n        }\n      }\n      ... on SchemaPublishMissingServiceError @skip(if: $usesGitHubApp) {\n        missingServiceError: message\n      }\n      ... on SchemaPublishMissingUrlError @skip(if: $usesGitHubApp) {\n        missingUrlError: message\n      }\n      ... on GitHubSchemaPublishSuccess @include(if: $usesGitHubApp) {\n        message\n      }\n      ... on GitHubSchemaPublishError @include(if: $usesGitHubApp) {\n        message\n      }\n      ... on SchemaPublishRetry {\n        reason\n      }\n    }\n  }\n": types.SchemaPublishDocument,
    "\n  query myTokenInfo {\n    tokenInfo {\n      __typename\n      ... on TokenInfo {\n        token {\n          name\n        }\n        organization {\n          slug\n        }\n        project {\n          type\n          slug\n        }\n        target {\n          slug\n        }\n        canPublishSchema: hasTargetScope(scope: REGISTRY_WRITE)\n        canCheckSchema: hasTargetScope(scope: REGISTRY_READ)\n      }\n      ... on TokenNotFoundError {\n        message\n      }\n    }\n  }\n": types.MyTokenInfoDocument,
    "\n  fragment RenderErrors_SchemaErrorConnectionFragment on SchemaErrorConnection {\n    edges {\n      node {\n        message\n      }\n    }\n  }\n": types.RenderErrors_SchemaErrorConnectionFragmentFragmentDoc,
    "\n  fragment RenderChanges_schemaChanges on SchemaChangeConnection {\n    edges {\n      node {\n        severityLevel\n        isSafeBasedOnUsage\n        message(withSafeBasedOnUsageNote: false)\n        approval {\n          approvedBy {\n            displayName\n          }\n        }\n      }\n    }\n  }\n": types.RenderChanges_SchemaChangesFragmentDoc,
};
function graphql(source) {
    var _a;
    return (_a = documents[source]) !== null && _a !== void 0 ? _a : {};
}
//# sourceMappingURL=gql.js.map