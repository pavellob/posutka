"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnexpectedError = exports.InvalidSchemaError = exports.SchemaNotFoundError = exports.InvalidTargetError = exports.InvalidFileContentsError = exports.FileMissingError = exports.UnsupportedFileExtensionError = exports.PersistedOperationsMalformedError = exports.InvalidCompositionResultError = exports.RemoteCompositionError = exports.LocalCompositionError = exports.ServiceAndUrlLengthMismatch = exports.InvalidDocumentsError = exports.SchemaPublishMissingUrlError = exports.SchemaPublishMissingServiceError = exports.InvalidSDLError = exports.IntrospectionError = exports.APIError = exports.NetworkError = exports.HTTPError = exports.SchemaPublishFailedError = exports.AuthorRequiredError = exports.GithubRepositoryRequiredError = exports.CommitRequiredError = exports.SchemaFileEmptyError = exports.SchemaFileNotFoundError = exports.MissingEnvironmentError = exports.MissingCdnEndpointError = exports.InvalidCdnKeyError = exports.InvalidRegistryTokenError = exports.MissingEndpointError = exports.MissingCdnKeyError = exports.MissingRegistryTokenError = exports.MissingArgumentsError = exports.InvalidCommandError = exports.InvalidConfigError = exports.HiveCLIError = exports.ExitCode = void 0;
exports.isAggregateError = isAggregateError;
const node_path_1 = require("node:path");
const node_process_1 = require("node:process");
const errors_1 = require("@oclif/core/lib/errors");
const index_1 = require("../gql/index");
const schema_1 = require("./schema");
const texture_1 = require("./texture/texture");
var ExitCode;
(function (ExitCode) {
    // The command execution succeeded.
    ExitCode[ExitCode["SUCCESS"] = 0] = "SUCCESS";
    // The command execution failed with a completion code that signals an error.
    ExitCode[ExitCode["ERROR"] = 1] = "ERROR";
    // The CLI was able to handle the command but it took too long and timed out.
    ExitCode[ExitCode["TIMED_OUT"] = 2] = "TIMED_OUT";
    // Initialization of the CLI failed. E.g. malformed input
    ExitCode[ExitCode["BAD_INIT"] = 3] = "BAD_INIT";
})(ExitCode || (exports.ExitCode = ExitCode = {}));
class HiveCLIError extends errors_1.CLIError {
    constructor(exitCode, code, message) {
        const tip = `> See https://the-guild.dev/graphql/hive/docs/api-reference/cli#errors for a complete list of error codes and recommended fixes.
To disable this message set HIVE_NO_ERROR_TIP=1`;
        super(`${message}  [${code}]${node_process_1.env.HIVE_NO_ERROR_TIP === '1' ? '' : `\n${tip}`}`, {
            exit: exitCode,
        });
        this.exitCode = exitCode;
    }
}
exports.HiveCLIError = HiveCLIError;
/** Categorized by command */
var ErrorCategory;
(function (ErrorCategory) {
    ErrorCategory[ErrorCategory["GENERIC"] = 100] = "GENERIC";
    ErrorCategory[ErrorCategory["SCHEMA_CHECK"] = 200] = "SCHEMA_CHECK";
    ErrorCategory[ErrorCategory["SCHEMA_PUBLISH"] = 300] = "SCHEMA_PUBLISH";
    ErrorCategory[ErrorCategory["APP_CREATE"] = 400] = "APP_CREATE";
    ErrorCategory[ErrorCategory["ARTIFACT_FETCH"] = 500] = "ARTIFACT_FETCH";
    ErrorCategory[ErrorCategory["DEV"] = 600] = "DEV";
    ErrorCategory[ErrorCategory["OPERATIONS_CHECK"] = 700] = "OPERATIONS_CHECK";
})(ErrorCategory || (ErrorCategory = {}));
const errorCode = (category, id) => {
    return category + id;
};
class InvalidConfigError extends HiveCLIError {
    constructor(configName = 'hive.json') {
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.GENERIC, 0), `The provided "${configName}" is invalid.`);
    }
}
exports.InvalidConfigError = InvalidConfigError;
class InvalidCommandError extends HiveCLIError {
    constructor(command) {
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.GENERIC, 1), `The command, "${command}", does not exist.`);
    }
}
exports.InvalidCommandError = InvalidCommandError;
class MissingArgumentsError extends HiveCLIError {
    constructor(...requiredArgs) {
        const argsStr = requiredArgs.map(a => `${a[0].toUpperCase()} \t${a[1]}`).join('\n');
        const message = `Missing ${requiredArgs.length} required argument${requiredArgs.length > 1 ? 's' : ''}:\n${argsStr}`;
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.GENERIC, 2), message);
    }
}
exports.MissingArgumentsError = MissingArgumentsError;
class MissingRegistryTokenError extends HiveCLIError {
    constructor() {
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.GENERIC, 3), `A registry token is required to perform the action. For help generating an access token, see https://the-guild.dev/graphql/hive/docs/management/targets#registry-access-tokens`);
    }
}
exports.MissingRegistryTokenError = MissingRegistryTokenError;
class MissingCdnKeyError extends HiveCLIError {
    constructor() {
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.GENERIC, 4), `A CDN key is required to perform the action. For help generating a CDN key, see https://the-guild.dev/graphql/hive/docs/management/targets#cdn-access-tokens`);
    }
}
exports.MissingCdnKeyError = MissingCdnKeyError;
class MissingEndpointError extends HiveCLIError {
    constructor() {
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.GENERIC, 5), `A registry endpoint is required to perform the action.`);
    }
}
exports.MissingEndpointError = MissingEndpointError;
class InvalidRegistryTokenError extends HiveCLIError {
    constructor() {
        super(ExitCode.ERROR, errorCode(ErrorCategory.GENERIC, 6), `A valid registry token is required to perform the action. The registry token used does not exist or has been revoked.`);
    }
}
exports.InvalidRegistryTokenError = InvalidRegistryTokenError;
class InvalidCdnKeyError extends HiveCLIError {
    constructor() {
        super(ExitCode.ERROR, errorCode(ErrorCategory.GENERIC, 7), `A valid CDN key is required to perform the action. The CDN key used does not exist or has been revoked.`);
    }
}
exports.InvalidCdnKeyError = InvalidCdnKeyError;
class MissingCdnEndpointError extends HiveCLIError {
    constructor() {
        super(ExitCode.ERROR, errorCode(ErrorCategory.GENERIC, 8), `A CDN endpoint is required to perform the action.`);
    }
}
exports.MissingCdnEndpointError = MissingCdnEndpointError;
class MissingEnvironmentError extends HiveCLIError {
    constructor(...requiredVars) {
        const varsStr = requiredVars.map(a => `\t${a[0]} \t${a[1]}`).join('\n');
        const message = `Missing required environment variable${requiredVars.length > 1 ? 's' : ''}:\n${varsStr}`;
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.GENERIC, 9), message);
    }
}
exports.MissingEnvironmentError = MissingEnvironmentError;
class SchemaFileNotFoundError extends HiveCLIError {
    constructor(fileName, reason) {
        const message = reason instanceof Error ? reason.message : reason;
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.SCHEMA_CHECK, 0), `Error reading the schema file "${fileName}"${message ? `: ${message}` : '.'}`);
    }
}
exports.SchemaFileNotFoundError = SchemaFileNotFoundError;
class SchemaFileEmptyError extends HiveCLIError {
    constructor(fileName) {
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.SCHEMA_CHECK, 1), `The schema file "${fileName}" is empty.`);
    }
}
exports.SchemaFileEmptyError = SchemaFileEmptyError;
class CommitRequiredError extends HiveCLIError {
    constructor() {
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.GENERIC, 10), `Couldn't resolve required commit sha. Provide a non-empty author via the '--commit' parameter or execute the command within a git repository.`);
    }
}
exports.CommitRequiredError = CommitRequiredError;
class GithubRepositoryRequiredError extends HiveCLIError {
    constructor() {
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.GENERIC, 11), `Couldn't resolve git repository required for GitHub Application.`);
    }
}
exports.GithubRepositoryRequiredError = GithubRepositoryRequiredError;
class AuthorRequiredError extends HiveCLIError {
    constructor() {
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.GENERIC, 12), `Couldn't resolve required commit author. Provide a non-empty author via the '--author' parameter or execute the command within a git repository.`);
    }
}
exports.AuthorRequiredError = AuthorRequiredError;
class SchemaPublishFailedError extends HiveCLIError {
    constructor() {
        super(ExitCode.ERROR, errorCode(ErrorCategory.SCHEMA_PUBLISH, 0), `Schema publish failed.`);
    }
}
exports.SchemaPublishFailedError = SchemaPublishFailedError;
class HTTPError extends HiveCLIError {
    constructor(endpoint, status, message) {
        const is400 = status >= 400 && status < 500;
        super(ExitCode.ERROR, errorCode(ErrorCategory.GENERIC, 13), `A ${is400 ? 'client' : 'server'} error occurred while performing the action. A call to "${endpoint}" failed with Status: ${status}, Text: ${message}`);
    }
}
exports.HTTPError = HTTPError;
class NetworkError extends HiveCLIError {
    constructor(cause) {
        super(ExitCode.ERROR, errorCode(ErrorCategory.GENERIC, 14), `A network error occurred while performing the action: "${cause instanceof Error ? `${cause.name}: ${cause.message}` : cause}"`);
    }
}
exports.NetworkError = NetworkError;
/** GraphQL Errors returned from an operation. Note that some GraphQL Errors that require specific steps to correct are handled through other error types. */
class APIError extends HiveCLIError {
    constructor(cause, requestId) {
        super(ExitCode.ERROR, errorCode(ErrorCategory.GENERIC, 15), (cause instanceof Error ? `${cause.name}: ${cause.message}` : cause) +
            (requestId ? `  (Request ID: "${requestId}")` : ''));
        this.ref = requestId;
    }
}
exports.APIError = APIError;
class IntrospectionError extends HiveCLIError {
    constructor() {
        super(ExitCode.ERROR, errorCode(ErrorCategory.GENERIC, 16), 'Could not get introspection result from the service. Make sure introspection is enabled by the server.');
    }
}
exports.IntrospectionError = IntrospectionError;
class InvalidSDLError extends HiveCLIError {
    constructor(err) {
        var _a;
        const location = (_a = err.locations) === null || _a === void 0 ? void 0 : _a[0];
        const locationString = location ? ` at line ${location.line}, column ${location.column}` : '';
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.SCHEMA_PUBLISH, 1), `The SDL is not valid${locationString}:\n ${err.message}`);
    }
}
exports.InvalidSDLError = InvalidSDLError;
class SchemaPublishMissingServiceError extends HiveCLIError {
    constructor(message) {
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.SCHEMA_PUBLISH, 2), `${message} Please use the "--service <name>" parameter.`);
    }
}
exports.SchemaPublishMissingServiceError = SchemaPublishMissingServiceError;
class SchemaPublishMissingUrlError extends HiveCLIError {
    constructor(message) {
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.SCHEMA_PUBLISH, 3), `${message} Please use the "--url <url>" parameter.`);
    }
}
exports.SchemaPublishMissingUrlError = SchemaPublishMissingUrlError;
class InvalidDocumentsError extends HiveCLIError {
    constructor(invalidDocuments) {
        const message = invalidDocuments
            .map(doc => {
            return `${texture_1.Texture.failure(doc.source)}\n${doc.errors.map(e => ` - ${texture_1.Texture.boldQuotedWords(e.message)}`).join('\n')}`;
        })
            .join('\n');
        super(ExitCode.ERROR, errorCode(ErrorCategory.OPERATIONS_CHECK, 0), `Invalid operation syntax:\n${message}`);
    }
}
exports.InvalidDocumentsError = InvalidDocumentsError;
class ServiceAndUrlLengthMismatch extends HiveCLIError {
    constructor(services, urls) {
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.DEV, 0), `Not every services has a matching url. Got ${services.length} services and ${urls.length} urls.`);
    }
}
exports.ServiceAndUrlLengthMismatch = ServiceAndUrlLengthMismatch;
class LocalCompositionError extends HiveCLIError {
    constructor(compositionResult) {
        const message = (0, schema_1.renderErrors)((0, index_1.makeFragmentData)({
            edges: compositionResult.errors.map(error => ({
                node: {
                    message: error.message,
                },
            })),
        }, schema_1.RenderErrors_SchemaErrorConnectionFragment));
        super(ExitCode.ERROR, errorCode(ErrorCategory.DEV, 1), `Local composition failed:\n${message}`);
    }
}
exports.LocalCompositionError = LocalCompositionError;
class RemoteCompositionError extends HiveCLIError {
    constructor(errors) {
        const message = (0, schema_1.renderErrors)(errors);
        super(ExitCode.ERROR, errorCode(ErrorCategory.DEV, 2), `Remote composition failed:\n${message}`);
    }
}
exports.RemoteCompositionError = RemoteCompositionError;
class InvalidCompositionResultError extends HiveCLIError {
    /** Compose API spits out the error message */
    constructor(supergraph) {
        super(ExitCode.ERROR, errorCode(ErrorCategory.DEV, 3), `Composition resulted in an invalid supergraph: ${supergraph}`);
    }
}
exports.InvalidCompositionResultError = InvalidCompositionResultError;
class PersistedOperationsMalformedError extends HiveCLIError {
    constructor(file) {
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.APP_CREATE, 0), `Persisted Operations file "${file}" is malformed.`);
    }
}
exports.PersistedOperationsMalformedError = PersistedOperationsMalformedError;
class UnsupportedFileExtensionError extends HiveCLIError {
    constructor(filename, supported) {
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.GENERIC, 17), `Got unsupported file extension: "${(0, node_path_1.extname)(filename)}".${supported ? ` Try using one of the supported extensions: ${supported.join(',')}` : ''}`);
    }
}
exports.UnsupportedFileExtensionError = UnsupportedFileExtensionError;
class FileMissingError extends HiveCLIError {
    constructor(fileName, additionalContext) {
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.GENERIC, 18), `Failed to load file "${fileName}"${additionalContext ? `: ${additionalContext}` : '.'}`);
    }
}
exports.FileMissingError = FileMissingError;
class InvalidFileContentsError extends HiveCLIError {
    constructor(fileName, expectedFormat) {
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.GENERIC, 19), `File "${fileName}" could not be parsed. Please make sure the file is readable and contains a valid ${expectedFormat}.`);
    }
}
exports.InvalidFileContentsError = InvalidFileContentsError;
class InvalidTargetError extends HiveCLIError {
    constructor() {
        super(ExitCode.BAD_INIT, errorCode(ErrorCategory.GENERIC, 20), `Invalid slug or ID provided for option "--target". Must match target slug "$organization_slug/$project_slug/$target_slug" (e.g. "the-guild/graphql-hive/staging") or UUID (e.g. c8164307-0b42-473e-a8c5-2860bb4beff6).`);
    }
}
exports.InvalidTargetError = InvalidTargetError;
class SchemaNotFoundError extends HiveCLIError {
    constructor(actionId) {
        super(ExitCode.ERROR, errorCode(ErrorCategory.ARTIFACT_FETCH, 0), `No schema found${actionId ? ` for action id ${actionId}.` : '.'}`);
    }
}
exports.SchemaNotFoundError = SchemaNotFoundError;
class InvalidSchemaError extends HiveCLIError {
    constructor(actionId) {
        super(ExitCode.ERROR, errorCode(ErrorCategory.ARTIFACT_FETCH, 1), `Schema is invalid${actionId ? ` for action id ${actionId}.` : '.'}`);
    }
}
exports.InvalidSchemaError = InvalidSchemaError;
class UnexpectedError extends HiveCLIError {
    constructor(cause) {
        const message = cause instanceof Error
            ? cause.message
            : typeof cause === 'string'
                ? cause
                : JSON.stringify(cause);
        super(ExitCode.ERROR, errorCode(ErrorCategory.GENERIC, 99), `An unexpected error occurred: ${message}\n> Enable DEBUG=* for more details.`);
    }
}
exports.UnexpectedError = UnexpectedError;
function isAggregateError(error) {
    return !!error && typeof error === 'object' && 'errors' in error && Array.isArray(error.errors);
}
//# sourceMappingURL=errors.js.map