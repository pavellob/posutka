"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Config = exports.graphqlEndpoint = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const zod_1 = require("zod");
const LegacyConfigModel = zod_1.z.object({
    registry: zod_1.z.string().optional(),
    token: zod_1.z.string().optional(),
});
const ConfigModel = zod_1.z.object({
    registry: zod_1.z
        .object({
        endpoint: zod_1.z.string().url().optional(),
        accessToken: zod_1.z.string().optional(),
    })
        .optional(),
    cdn: zod_1.z
        .object({
        endpoint: zod_1.z.string().url().optional(),
        accessToken: zod_1.z.string().optional(),
    })
        .optional(),
});
exports.graphqlEndpoint = 'https://app.graphql-hive.com/graphql';
class Config {
    constructor({ filepath, rootDir }) {
        if (filepath) {
            this.filepath = filepath;
        }
        else {
            this.filepath = path_1.default.join(rootDir, 'hive.json');
        }
    }
    get(key) {
        const map = this.read();
        const parts = key.split('.');
        let current = map;
        for (const part of parts) {
            if (current == null) {
                return null;
            }
            current = current[part];
        }
        return current;
    }
    readSpace(content) {
        // eslint-disable-next-line no-process-env
        const space = process.env.HIVE_SPACE;
        if (space) {
            return content[space];
        }
        if ('default' in content) {
            return content['default'];
        }
        return content;
    }
    read() {
        try {
            if (!this.cache) {
                const space = this.readSpace(JSON.parse(fs_1.default.readFileSync(this.filepath, 'utf-8')));
                const legacyConfig = LegacyConfigModel.safeParse(space);
                if (legacyConfig.success) {
                    this.cache = {
                        registry: {
                            endpoint: legacyConfig.data.registry,
                            accessToken: legacyConfig.data.token,
                        },
                        cdn: {
                            endpoint: undefined,
                            accessToken: undefined,
                        },
                    };
                }
                const config = ConfigModel.safeParse(space);
                // TODO: we should probably print a warning/error in case of an invalid config.
                if (config.success) {
                    this.cache = config.data;
                }
                else {
                    throw new Error('Invalid config.');
                }
            }
        }
        catch (error) {
            this.cache = {
                registry: {
                    endpoint: undefined,
                    accessToken: undefined,
                },
                cdn: {
                    endpoint: undefined,
                    accessToken: undefined,
                },
            };
        }
        return this.cache;
    }
}
exports.Config = Config;
//# sourceMappingURL=config.js.map