"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadGraphQLHTTPSubgraph = loadGraphQLHTTPSubgraph;
const graphql_1 = require("graphql");
const string_interpolation_1 = require("@graphql-mesh/string-interpolation");
const utils_1 = require("@graphql-mesh/utils");
const utils_2 = require("@graphql-tools/utils");
const promise_helpers_1 = require("@whatwg-node/promise-helpers");
function fixExtends(node) {
    return (0, graphql_1.visit)(node, {
        [graphql_1.Kind.DIRECTIVE](node) {
            if (node.name.value === 'link') {
                const url = node.arguments?.find(arg => arg.name.value === 'url')?.value;
                if (url?.kind === graphql_1.Kind.STRING &&
                    url.value.startsWith('https://specs.apollo.dev/federation/v2.')) {
                    const imports = node.arguments?.find(arg => arg.name.value === 'import')?.value;
                    if (imports?.kind === graphql_1.Kind.LIST) {
                        // @ts-expect-error - We can modify it
                        imports.values.push({
                            kind: graphql_1.Kind.STRING,
                            value: '@extends',
                        });
                    }
                }
            }
        },
        [graphql_1.Kind.OBJECT_TYPE_EXTENSION](node) {
            return {
                ...node,
                directives: [
                    ...(node.directives || []),
                    {
                        kind: graphql_1.Kind.DIRECTIVE,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            value: 'extends',
                        },
                    },
                ],
                kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
            };
        },
        [graphql_1.Kind.INTERFACE_TYPE_EXTENSION](node) {
            return {
                ...node,
                directives: [
                    ...(node.directives || []),
                    {
                        kind: graphql_1.Kind.DIRECTIVE,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            value: 'extends',
                        },
                    },
                ],
                kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
            };
        },
        [graphql_1.Kind.UNION_TYPE_EXTENSION](node) {
            return {
                ...node,
                directives: [
                    ...(node.directives || []),
                    {
                        kind: graphql_1.Kind.DIRECTIVE,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            value: 'extends',
                        },
                    },
                ],
                kind: graphql_1.Kind.UNION_TYPE_DEFINITION,
            };
        },
        [graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION](node) {
            return {
                ...node,
                directives: [
                    ...(node.directives || []),
                    {
                        kind: graphql_1.Kind.DIRECTIVE,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            value: 'extends',
                        },
                    },
                ],
                kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
            };
        },
        [graphql_1.Kind.ENUM_TYPE_EXTENSION](node) {
            return {
                ...node,
                directives: [
                    ...(node.directives || []),
                    {
                        kind: graphql_1.Kind.DIRECTIVE,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            value: 'extends',
                        },
                    },
                ],
                kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,
            };
        },
        [graphql_1.Kind.SCALAR_TYPE_EXTENSION](node) {
            return {
                ...node,
                directives: [
                    ...(node.directives || []),
                    {
                        kind: graphql_1.Kind.DIRECTIVE,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            value: 'extends',
                        },
                    },
                ],
                kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION,
            };
        },
    });
}
function loadGraphQLHTTPSubgraph(subgraphName, { endpoint, method, useGETForQueries, operationHeaders, credentials, retry, timeout, source, schemaHeaders, federation = false, transportKind = 'http', }) {
    return (ctx) => {
        let schema$;
        const interpolationData = {
            env: process.env,
        };
        const interpolatedEndpoint = string_interpolation_1.stringInterpolator.parse(endpoint, interpolationData);
        const interpolatedSource = string_interpolation_1.stringInterpolator.parse(source, interpolationData);
        function handleFetchedSchema(schema) {
            return addAnnotations({
                kind: transportKind,
                subgraph: subgraphName,
                location: endpoint,
                headers: operationHeaders ? Object.entries(operationHeaders) : undefined,
                options: {
                    method,
                    useGETForQueries,
                    credentials,
                    retry,
                    timeout,
                },
            }, schema);
        }
        if (interpolatedSource) {
            schema$ = (0, promise_helpers_1.handleMaybePromise)(() => {
                let source$;
                if ((0, utils_1.isUrl)(interpolatedSource)) {
                    source$ = (0, promise_helpers_1.handleMaybePromise)(() => ctx.fetch(interpolatedSource, {
                        headers: schemaHeaders,
                    }), res => res.text());
                }
                else if ((0, utils_2.isValidPath)(interpolatedSource)) {
                    source$ = (0, utils_1.readFile)(interpolatedSource, {
                        allowUnknownExtensions: true,
                        cwd: ctx.cwd,
                        fetch: ctx.fetch,
                        importFn: (p) => Promise.resolve(`${p}`).then(s => __importStar(require(s))),
                        logger: ctx.logger,
                    });
                }
                return source$;
            }, sdl => (0, graphql_1.buildASTSchema)(fixExtends((0, graphql_1.parse)(sdl, { noLocation: true })), {
                assumeValidSDL: true,
                assumeValid: true,
            }));
        }
        else {
            const fetchAsRegular = () => (0, promise_helpers_1.handleMaybePromise)(() => ctx.fetch(interpolatedEndpoint, {
                method: method || (useGETForQueries ? 'GET' : 'POST'),
                headers: {
                    'Content-Type': 'application/json',
                    ...schemaHeaders,
                },
                body: JSON.stringify({
                    query: (0, graphql_1.getIntrospectionQuery)(),
                }),
            }), res => {
                assertResponseOk(res);
                return (0, promise_helpers_1.handleMaybePromise)(() => res.json(), (result) => {
                    if (result.errors) {
                        throw new AggregateError(result.errors.map(err => (0, utils_2.createGraphQLError)(err.message, err)), 'Introspection Query Failed');
                    }
                    const schema = (0, graphql_1.buildClientSchema)(result.data, {
                        assumeValid: true,
                    });
                    const queryType = schema.getQueryType();
                    const queryFields = queryType?.getFields();
                    if (queryFields._service) {
                        const serviceType = (0, graphql_1.getNamedType)(queryFields._service.type);
                        if ((0, graphql_1.isObjectType)(serviceType)) {
                            const serviceTypeFields = serviceType.getFields();
                            if (serviceTypeFields.sdl) {
                                return fetchAsFederation();
                            }
                        }
                    }
                    return schema;
                });
            });
            const fetchAsFederation = () => (0, promise_helpers_1.handleMaybePromise)(() => ctx.fetch(interpolatedEndpoint, {
                method: method || (useGETForQueries ? 'GET' : 'POST'),
                headers: {
                    'Content-Type': 'application/json',
                    ...schemaHeaders,
                },
                body: JSON.stringify({
                    query: federationIntrospectionQuery,
                }),
            }), res => {
                assertResponseOk(res);
                return (0, promise_helpers_1.handleMaybePromise)(() => res.json(), (result) => {
                    if (result.errors) {
                        throw new AggregateError(result.errors.map(err => (0, utils_2.createGraphQLError)(err.message, err)), 'Introspection Query Failed');
                    }
                    if (!result.data?._service?.sdl) {
                        throw new Error('Federation subgraph does not provide SDL');
                    }
                    // Replace "extend" keyword with "@extends"
                    return (0, graphql_1.buildASTSchema)(fixExtends((0, graphql_1.parse)(result.data._service.sdl, { noLocation: true })), {
                        assumeValidSDL: true,
                        assumeValid: true,
                    });
                });
            });
            schema$ = federation ? fetchAsFederation() : fetchAsRegular();
        }
        schema$ = (0, promise_helpers_1.handleMaybePromise)(() => schema$, handleFetchedSchema);
        return {
            name: subgraphName,
            schema$,
        };
    };
}
const transportDirective = new graphql_1.GraphQLDirective({
    name: 'transport',
    isRepeatable: true,
    locations: [graphql_1.DirectiveLocation.SCHEMA],
    args: {
        kind: { type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString) },
        subgraph: { type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString) },
        location: { type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString) },
        headers: { type: new graphql_1.GraphQLList(new graphql_1.GraphQLList(graphql_1.GraphQLString)) },
        options: { type: new graphql_1.GraphQLScalarType({ name: 'TransportOptions' }) },
    },
});
function addAnnotations(transportEntry, schema) {
    const schemaExtensions = (schema.extensions ||= {});
    schemaExtensions.directives ||= {};
    schemaExtensions.directives.transport = transportEntry;
    if (schema.getDirective('transport')) {
        return schema;
    }
    const schemaConfig = schema.toConfig();
    return new graphql_1.GraphQLSchema({
        ...schemaConfig,
        directives: [...schemaConfig.directives, transportDirective],
    });
}
const federationIntrospectionQuery = /* GraphQL */ `
  query GetFederationInfo {
    _service {
      sdl
    }
  }
`;
function assertResponseOk(response) {
    if (!response.ok) {
        throw new Error(`Failed to load GraphQL HTTP subgraph: ${response.statusText}`);
    }
}
