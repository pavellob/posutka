"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamingConventionMap = void 0;
exports.createNamingConventionTransform = createNamingConventionTransform;
exports.upperCase = upperCase;
exports.lowerCase = lowerCase;
const tslib_1 = require("tslib");
const change_case_1 = require("change-case");
const graphql_1 = require("graphql");
const graphql_scalars_1 = require("graphql-scalars");
const utils_1 = require("@graphql-tools/utils");
function isFromGraphQLScalars(name) {
    return Object.keys(graphql_scalars_1.resolvers).includes(name);
}
// TODO: For backwards compatibility; remove this in the next major
exports.NamingConventionMap = {
    camelCase: change_case_1.camelCase,
    capitalCase: change_case_1.capitalCase,
    constantCase: change_case_1.constantCase,
    dotCase: change_case_1.dotCase,
    headerCase: change_case_1.headerCase,
    noCase: change_case_1.noCase,
    paramCase: change_case_1.paramCase,
    pascalCase: change_case_1.pascalCase,
    pathCase: change_case_1.pathCase,
    sentenceCase: change_case_1.sentenceCase,
    snakeCase: change_case_1.snakeCase,
    upperCase,
    lowerCase,
};
function createNamingConventionTransform(config) {
    const typeNamesFn = typeof config.typeNames === 'string' ? exports.NamingConventionMap[config.typeNames] : config.typeNames;
    const fieldNamesFn = typeof config.fieldNames === 'string'
        ? exports.NamingConventionMap[config.fieldNames]
        : config.fieldNames;
    const enumValuesFn = typeof config.enumValues === 'string'
        ? exports.NamingConventionMap[config.enumValues]
        : config.enumValues;
    const fieldArgumentNamesFn = typeof config.fieldArgumentNames === 'string'
        ? exports.NamingConventionMap[config.fieldArgumentNames]
        : config.fieldArgumentNames;
    const schemaMapper = {};
    if (typeNamesFn) {
        schemaMapper[utils_1.MapperKind.TYPE] = type => {
            if ((0, graphql_1.isSpecifiedScalarType)(type) || isFromGraphQLScalars(type.name)) {
                return type;
            }
            return new (Object.getPrototypeOf(type).constructor)({
                ...type.toConfig(),
                name: typeNamesFn(type.name),
            });
        };
    }
    if (fieldNamesFn || fieldArgumentNamesFn || enumValuesFn) {
        schemaMapper[utils_1.MapperKind.FIELD] = (fieldConfig, fieldName) => {
            const newFieldName = fieldNamesFn?.(fieldName) || fieldName;
            if (!fieldArgumentNamesFn && !enumValuesFn) {
                return [newFieldName, fieldConfig];
            }
            if ('args' in fieldConfig && fieldConfig.args && (fieldArgumentNamesFn || enumValuesFn)) {
                const newArgs = {};
                for (const argName in fieldConfig.args) {
                    const newArgName = fieldArgumentNamesFn?.(argName) || argName;
                    const argConfig = fieldConfig.args[argName];
                    if (!argConfig.defaultValue || !enumValuesFn) {
                        newArgs[newArgName] = argConfig;
                        continue;
                    }
                    const namedArgType = (0, graphql_1.getNamedType)(argConfig.type);
                    if (!(0, graphql_1.isEnumType)(namedArgType)) {
                        newArgs[newArgName] = argConfig;
                        continue;
                    }
                    const newDefaultValue = enumValuesFn(argConfig.defaultValue.toString());
                    newArgs[newArgName] = {
                        ...argConfig,
                        defaultValue: newDefaultValue,
                    };
                }
                return [
                    newFieldName,
                    {
                        ...fieldConfig,
                        args: newArgs,
                    },
                ];
            }
            return [newFieldName, fieldConfig];
        };
    }
    if (enumValuesFn) {
        schemaMapper[utils_1.MapperKind.ENUM_VALUE] = (valueConfig, _typeName, _schema, externalValue) => {
            const newExternalValue = enumValuesFn(externalValue);
            return [newExternalValue, valueConfig];
        };
    }
    return function namingConventionTransform(schema) {
        return (0, utils_1.mapSchema)(schema, schemaMapper);
    };
}
tslib_1.__exportStar(require("change-case"), exports);
function upperCase(str) {
    return str.toUpperCase();
}
function lowerCase(str) {
    return str.toLowerCase();
}
