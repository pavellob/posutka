import { extendSchema, isOutputType, parse, parseType, typeFromAST } from 'graphql';
import { MapperKind, mapSchema } from '@graphql-tools/utils';
import { TransformValidationError } from './transforms/utils.js';
export function createTypeReplaceTransform(replacerFn) {
    return function typeReplaceTransform(schema) {
        return mapSchema(schema, {
            [MapperKind.FIELD]: (fieldConfig, fieldName, typeName) => {
                const newTypeName = replacerFn(typeName, fieldName, fieldConfig.type);
                if (typeof newTypeName === 'string' && newTypeName !== fieldConfig.type.toString()) {
                    const newType = typeFromAST(schema, parseType(newTypeName));
                    if (!newType) {
                        throw new TransformValidationError(`No type found for ${newTypeName} in the schema, use a type instance instead such as GraphQLString from 'graphql'`);
                    }
                    return [fieldName, { ...fieldConfig, type: newType }];
                }
                if (isOutputType(newTypeName)) {
                    return [fieldName, { ...fieldConfig, type: newTypeName }];
                }
                return undefined;
            },
        });
    };
}
export function createExtendTransform(typeDefs) {
    const typeDefsDoc = typeof typeDefs === 'string' ? parse(typeDefs, { noLocation: true }) : typeDefs;
    return function extendTransform(schema) {
        return extendSchema(schema, typeDefsDoc, {
            assumeValid: true,
            assumeValidSDL: true,
        });
    };
}
export * from './transforms/filter-schema.js';
export * from './transforms/naming-convention.js';
export * from './transforms/prefix.js';
export * from './transforms/rename.js';
export * from './transforms/encapsulate.js';
export * from './transforms/prune.js';
export * from './transforms/hoist-field.js';
export * from './transforms/federation.js';
