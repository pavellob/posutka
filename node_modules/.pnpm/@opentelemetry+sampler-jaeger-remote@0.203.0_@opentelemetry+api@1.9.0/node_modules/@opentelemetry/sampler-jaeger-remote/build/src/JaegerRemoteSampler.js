"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.JaegerRemoteSampler = void 0;
const api_1 = require("@opentelemetry/api");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const axios = require("axios");
const PerOperationSampler_1 = require("./PerOperationSampler");
const types_1 = require("./types");
/** JaegerRemoteSampler */
class JaegerRemoteSampler {
    _endpoint;
    _serviceName;
    _poolingInterval;
    _sampler;
    _syncingConfig;
    constructor(config) {
        this._endpoint = config.endpoint;
        this._serviceName = config.serviceName;
        this._poolingInterval = config.poolingInterval;
        this._sampler = config.initialSampler;
        this._syncingConfig = false;
        setInterval(async () => {
            if (this._syncingConfig) {
                return;
            }
            this._syncingConfig = true;
            try {
                await this.getAndUpdateSampler();
            }
            catch (err) {
                api_1.diag.warn('Could not update sampler', err);
            }
            finally {
                this._syncingConfig = false;
            }
        }, this._poolingInterval);
    }
    shouldSample(context, traceId, spanName, spanKind, attributes, links) {
        return this._sampler.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    }
    toString() {
        return `JaegerRemoteSampler{endpoint=${this._endpoint},${this._serviceName && ` serviceName=${this._serviceName},`} poolingInterval=${this._poolingInterval}, sampler=${this._sampler}}`;
    }
    async getAndUpdateSampler() {
        const newConfig = await this.getSamplerConfig(this._serviceName);
        this._sampler = await this.convertSamplingResponseToSampler(newConfig);
    }
    convertSamplingResponseToSampler(newConfig) {
        const perOperationStrategies = newConfig.operationSampling?.perOperationStrategies;
        if (newConfig.operationSampling &&
            perOperationStrategies &&
            perOperationStrategies.length > 0) {
            const defaultSampler = new sdk_trace_base_1.TraceIdRatioBasedSampler(newConfig.operationSampling.defaultSamplingProbability);
            return new sdk_trace_base_1.ParentBasedSampler({
                root: new PerOperationSampler_1.PerOperationSampler({
                    defaultSampler,
                    perOperationStrategies,
                }),
            });
        }
        switch (newConfig.strategyType) {
            case types_1.StrategyType.PROBABILISTIC:
                return new sdk_trace_base_1.ParentBasedSampler({
                    root: new sdk_trace_base_1.TraceIdRatioBasedSampler(newConfig.probabilisticSampling.samplingRate),
                });
            default:
                api_1.diag.warn(`Strategy ${newConfig.strategyType} not supported.`);
                return this._sampler;
        }
    }
    async getSamplerConfig(serviceName) {
        const response = await axios.get(`${this._endpoint}/sampling?service=${serviceName ?? ''}`);
        return response.data;
    }
}
exports.JaegerRemoteSampler = JaegerRemoteSampler;
//# sourceMappingURL=JaegerRemoteSampler.js.map