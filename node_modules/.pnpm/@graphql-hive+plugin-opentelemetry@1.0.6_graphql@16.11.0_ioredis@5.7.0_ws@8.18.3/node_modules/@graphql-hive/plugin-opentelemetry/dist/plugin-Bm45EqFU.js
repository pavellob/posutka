import { isRetryExecutionRequest as isRetryExecutionRequest$1, getRetryInfo as getRetryInfo$1, Logger } from '@graphql-hive/gateway-runtime';
import { getHeadersObj } from '@graphql-mesh/utils';
import { getOperationASTFromDocument, isAsyncIterable, fakePromise } from '@graphql-tools/utils';
import { unfakePromise } from '@whatwg-node/promise-helpers';
import { hive } from './api.js';
import { trace, SpanStatusCode, context, ROOT_CONTEXT, SpanKind, DiagLogLevel, diag, propagation } from '@opentelemetry/api';
import { hashOperation } from '@graphql-hive/core';
import { defaultPrintFn } from '@graphql-mesh/transport-common';
import { SEMATTRS_EXCEPTION_STACKTRACE, SEMATTRS_EXCEPTION_MESSAGE, SEMATTRS_EXCEPTION_TYPE, SEMATTRS_HTTP_METHOD, SEMATTRS_HTTP_URL, SEMATTRS_NET_HOST_NAME, SEMATTRS_HTTP_HOST, SEMATTRS_HTTP_ROUTE, SEMATTRS_HTTP_SCHEME, SEMATTRS_HTTP_STATUS_CODE, SEMATTRS_HTTP_USER_AGENT, SEMATTRS_HTTP_CLIENT_IP } from '@opentelemetry/semantic-conventions';
import { printSchema, TypeInfo } from 'graphql';

class OtelContextStack {
  #root;
  #current;
  constructor(root) {
    this.#root = { ctx: root };
    this.#current = this.#root;
  }
  get current() {
    return this.#current.ctx;
  }
  get root() {
    return this.#root.ctx;
  }
  push = (ctx) => {
    this.#current = { ctx, previous: this.#current };
  };
  pop = () => {
    this.#current = this.#current.previous ?? this.#root;
  };
  toString() {
    let node = this.#current;
    const names = [];
    while (node != void 0) {
      names.push(trace.getSpan(node.ctx).name);
      node = node.previous;
    }
    return names.join(" -> ");
  }
}

function withState(pluginFactory) {
  const states = {};
  function getProp(scope, key) {
    return {
      get() {
        if (!states[scope]) states[scope] = /* @__PURE__ */ new WeakMap();
        let value = states[scope].get(key);
        if (!value) states[scope].set(key, value = {});
        return value;
      },
      enumerable: true
    };
  }
  function getState(payload) {
    let { executionRequest, context, request } = payload;
    const state = {};
    const defineState = (scope, key) => Object.defineProperty(state, scope, getProp(scope, key));
    if (executionRequest) {
      defineState("forSubgraphExecution", executionRequest);
      if (executionRequest.context?.params) context = executionRequest.context;
    }
    if (context) {
      defineState("forOperation", context);
      if (context.request) request = context.request;
    }
    if (request) {
      defineState("forRequest", request);
    }
    return state;
  }
  function addStateGetters(src) {
    const result = {};
    const properties = Object.entries(Object.getOwnPropertyDescriptors(src));
    for (const [hookName, descriptor] of properties) {
      const hook = descriptor.value;
      if (typeof hook !== "function") {
        descriptor.get &&= () => src[hookName];
        descriptor.set &&= (value) => {
          src[hookName] = value;
        };
        Object.defineProperty(result, hookName, descriptor);
      } else {
        result[hookName] = {
          [hook.name](payload, ...args) {
            return hook(
              {
                ...payload,
                get state() {
                  return getState(payload);
                }
              },
              ...args
            );
          }
        }[hook.name];
      }
    }
    return result;
  }
  const plugin = pluginFactory(getState);
  const pluginWithState = addStateGetters(plugin);
  pluginWithState.instrumentation = addStateGetters(plugin.instrumentation);
  return pluginWithState;
}
function getMostSpecificState(state = {}) {
  const { forOperation, forRequest, forSubgraphExecution } = state;
  return forSubgraphExecution ?? forOperation ?? forRequest;
}

const RETRY_SYMBOL = Symbol.for("@hive-gateway/runtime/upstreamRetry");
function isRetryExecutionRequest(executionRequest) {
  return !!executionRequest?.[RETRY_SYMBOL];
}
function getRetryInfo(executionRequest) {
  return executionRequest[RETRY_SYMBOL];
}

const SEMATTRS_GRAPHQL_DOCUMENT = "graphql.document";
const SEMATTRS_GRAPHQL_OPERATION_TYPE = "graphql.operation.type";
const SEMATTRS_GRAPHQL_OPERATION_NAME = "graphql.operation.name";
const SEMATTRS_HIVE_GRAPHQL_OPERATION_HASH = "hive.graphql.operation.hash";
const SEMATTRS_HIVE_GRAPHQL_ERROR_COUNT = "hive.graphql.error.count";
const SEMATTRS_HIVE_GRAPHQL_ERROR_CODES = "hive.graphql.error.codes";
const SEMATTRS_HIVE_GATEWAY_UPSTREAM_SUBGRAPH_NAME = "hive.gateway.upstream.subgraph.name";
const SEMATTRS_HIVE_GATEWAY_OPERATION_SUBGRAPH_NAMES = "hive.gateway.operation.subgraph.names";

function createHttpSpan(input) {
  const { url, request, tracer } = input;
  const span = tracer.startSpan(
    `${request.method || "GET"} ${url.pathname}`,
    {
      attributes: {
        [SEMATTRS_HTTP_METHOD]: request.method || "GET",
        [SEMATTRS_HTTP_URL]: request.url,
        [SEMATTRS_HTTP_ROUTE]: url.pathname,
        [SEMATTRS_HTTP_SCHEME]: url.protocol,
        [SEMATTRS_NET_HOST_NAME]: url.hostname || url.host || request.headers.get("host") || "localhost",
        [SEMATTRS_HTTP_HOST]: url.host || request.headers.get("host") || void 0,
        [SEMATTRS_HTTP_CLIENT_IP]: request.headers.get("x-forwarded-for")?.split(",")[0],
        [SEMATTRS_HTTP_USER_AGENT]: request.headers.get("user-agent") || void 0,
        "hive.client.name": request.headers.get("x-graphql-client-name") || void 0,
        "hive.client.version": request.headers.get("x-graphql-client-version") || void 0
      },
      kind: SpanKind.SERVER
    },
    input.ctx
  );
  return {
    ctx: trace.setSpan(input.ctx, span)
  };
}
function setResponseAttributes(ctx, response) {
  const span = trace.getSpan(ctx);
  if (span) {
    span.setAttribute(SEMATTRS_HTTP_STATUS_CODE, response.status);
    span.setAttribute(
      "gateway.cache.response_cache",
      response.status === 304 && response.headers.get("ETag") ? "hit" : "miss"
    );
    span.setStatus({
      code: response.ok ? SpanStatusCode.OK : SpanStatusCode.ERROR,
      message: response.ok ? void 0 : response.statusText
    });
  }
}
function createGraphQLSpan(input) {
  const span = input.tracer.startSpan(
    `graphql.operation`,
    { kind: SpanKind.INTERNAL },
    input.ctx
  );
  return trace.setSpan(input.ctx, span);
}
function setParamsAttributes(input) {
  const { ctx, params } = input;
  const span = trace.getSpan(ctx);
  if (!span) {
    return;
  }
  span.setAttribute(SEMATTRS_GRAPHQL_DOCUMENT, params.query ?? "<undefined>");
  if (params.operationName) {
    span.setAttribute(SEMATTRS_GRAPHQL_OPERATION_NAME, params.operationName);
  }
}
const typeInfos = /* @__PURE__ */ new WeakMap();
const defaultOperationHashingFn = (input) => {
  if (!typeInfos.has(input.schema)) {
    typeInfos.set(input.schema, new TypeInfo(input.schema));
  }
  const typeInfo = typeInfos.get(input.schema);
  return hashOperation({
    documentNode: input.document,
    operationName: input.operationName ?? null,
    schema: input.schema,
    variables: null,
    // Unstable feature, not using it for now
    typeInfo
  });
};
function setExecutionAttributesOnOperationSpan(input) {
  const { hashOperationFn = defaultOperationHashingFn, args, ctx } = input;
  const span = trace.getSpan(ctx);
  if (span) {
    const operation = getOperationASTFromDocument(
      args.document,
      args.operationName || void 0
    );
    span.setAttribute(SEMATTRS_GRAPHQL_OPERATION_TYPE, operation.operation);
    const document = defaultPrintFn(args.document);
    span.setAttribute(SEMATTRS_GRAPHQL_DOCUMENT, document);
    const hash = hashOperationFn?.({ ...args });
    if (hash) {
      span.setAttribute(SEMATTRS_HIVE_GRAPHQL_OPERATION_HASH, hash);
    }
    const operationName = operation.name?.value;
    if (operationName) {
      span.setAttribute(SEMATTRS_GRAPHQL_OPERATION_NAME, operationName);
      span.updateName(`graphql.operation ${operationName}`);
    }
  }
}
function createGraphqlContextBuildingSpan(input) {
  const span = input.tracer.startSpan(
    "graphql.context",
    { kind: SpanKind.INTERNAL },
    input.ctx
  );
  return trace.setSpan(input.ctx, span);
}
function createGraphQLParseSpan(input) {
  const span = input.tracer.startSpan(
    "graphql.parse",
    {
      kind: SpanKind.INTERNAL
    },
    input.ctx
  );
  return trace.setSpan(input.ctx, span);
}
function setGraphQLParseAttributes(input) {
  const span = trace.getSpan(input.ctx);
  if (!span) {
    return;
  }
  if (input.query) {
    span.setAttribute(SEMATTRS_GRAPHQL_DOCUMENT, input.query);
  }
  if (input.operationName) {
    span.setAttribute(SEMATTRS_GRAPHQL_OPERATION_NAME, input.operationName);
  }
  if (input.result instanceof Error) {
    span.setAttribute(SEMATTRS_HIVE_GRAPHQL_ERROR_COUNT, 1);
  }
}
function createGraphQLValidateSpan(input) {
  const span = input.tracer.startSpan(
    "graphql.validate",
    {
      attributes: {
        [SEMATTRS_GRAPHQL_DOCUMENT]: input.query,
        [SEMATTRS_GRAPHQL_OPERATION_NAME]: input.operationName
      },
      kind: SpanKind.INTERNAL
    },
    input.ctx
  );
  return trace.setSpan(input.ctx, span);
}
function setGraphQLValidateAttributes(input) {
  const { result, ctx } = input;
  const span = trace.getSpan(ctx);
  if (!span) {
    return;
  }
  if (result instanceof Error) {
    span.setStatus({
      code: SpanStatusCode.ERROR,
      message: result.message
    });
  } else if (Array.isArray(result) && result.length > 0) {
    span.setAttribute(SEMATTRS_HIVE_GRAPHQL_ERROR_COUNT, result.length);
    span.setStatus({
      code: SpanStatusCode.ERROR,
      message: result.map((e) => e.message).join(", ")
    });
    for (const error of result) {
      span.recordException(error);
    }
  }
}
function createGraphQLExecuteSpan(input) {
  const span = input.tracer.startSpan(
    "graphql.execute",
    { kind: SpanKind.INTERNAL },
    input.ctx
  );
  return trace.setSpan(input.ctx, span);
}
function setGraphQLExecutionAttributes(input) {
  const { ctx, args } = input;
  const span = trace.getSpan(ctx);
  if (!span) {
    return;
  }
  const operation = getOperationASTFromDocument(
    args.document,
    args.operationName || void 0
  );
  span.setAttribute(SEMATTRS_GRAPHQL_OPERATION_TYPE, operation.operation);
  const operationName = operation.name?.value;
  if (operationName) {
    span.setAttribute(SEMATTRS_GRAPHQL_OPERATION_NAME, operationName);
  }
  const document = defaultPrintFn(input.args.document);
  span.setAttribute(SEMATTRS_GRAPHQL_DOCUMENT, document);
}
function setGraphQLExecutionResultAttributes(input) {
  const { ctx, result } = input;
  const span = trace.getSpan(ctx);
  if (!span) {
    return;
  }
  if (input.subgraphNames?.length) {
    span.setAttribute(
      SEMATTRS_HIVE_GATEWAY_OPERATION_SUBGRAPH_NAMES,
      input.subgraphNames
    );
  }
  if (!isAsyncIterable(result) && // FIXME: Handle async iterable too
  result.errors && result.errors.length > 0) {
    span.setAttribute(SEMATTRS_HIVE_GRAPHQL_ERROR_COUNT, result.errors.length);
    span.setStatus({
      code: SpanStatusCode.ERROR,
      message: result.errors.map((e) => e.message).join(", ")
    });
    const codes = [];
    for (const error of result.errors) {
      span.recordException(error);
      if (error.extensions["code"]) {
        codes.push(`${error.extensions["code"]}`);
      }
    }
    if (codes.length > 0) {
      span.setAttribute(SEMATTRS_HIVE_GRAPHQL_ERROR_CODES, codes);
    }
  }
}
function createSubgraphExecuteSpan(input) {
  const operation = getOperationASTFromDocument(
    input.executionRequest.document,
    input.executionRequest.operationName
  );
  const span = input.tracer.startSpan(
    `subgraph.execute (${input.subgraphName})`,
    {
      attributes: {
        [SEMATTRS_GRAPHQL_OPERATION_NAME]: operation.name?.value,
        [SEMATTRS_GRAPHQL_DOCUMENT]: defaultPrintFn(
          input.executionRequest.document
        ),
        [SEMATTRS_GRAPHQL_OPERATION_TYPE]: operation.operation,
        [SEMATTRS_HIVE_GATEWAY_UPSTREAM_SUBGRAPH_NAME]: input.subgraphName
      },
      kind: SpanKind.CLIENT
    },
    input.ctx
  );
  return trace.setSpan(input.ctx, span);
}
function createUpstreamHttpFetchSpan(input) {
  const span = input.tracer.startSpan(
    "http.fetch",
    {
      attributes: {},
      kind: SpanKind.CLIENT
    },
    input.ctx
  );
  return trace.setSpan(input.ctx, span);
}
function setUpstreamFetchAttributes(input) {
  const { ctx, url, options: fetchOptions } = input;
  const span = trace.getSpan(ctx);
  if (!span) {
    return;
  }
  const urlObj = new URL(input.url);
  span.setAttribute(SEMATTRS_HTTP_METHOD, fetchOptions.method ?? "GET");
  span.setAttribute(SEMATTRS_HTTP_URL, url);
  span.setAttribute(SEMATTRS_NET_HOST_NAME, urlObj.hostname);
  span.setAttribute(SEMATTRS_HTTP_HOST, urlObj.host);
  span.setAttribute(SEMATTRS_HTTP_ROUTE, urlObj.pathname);
  span.setAttribute(SEMATTRS_HTTP_SCHEME, urlObj.protocol);
  if (input.executionRequest && isRetryExecutionRequest(input.executionRequest)) {
    const { attempt } = getRetryInfo(input.executionRequest);
    if (attempt > 0) {
      span.setAttribute("http.request.resend_count", attempt);
    }
  }
}
function setUpstreamFetchResponseAttributes(input) {
  const { ctx, response } = input;
  const span = trace.getSpan(ctx);
  if (!span) {
    return;
  }
  span.setAttribute(SEMATTRS_HTTP_STATUS_CODE, response.status);
  span.setStatus({
    code: response.ok ? SpanStatusCode.OK : SpanStatusCode.ERROR,
    message: response.ok ? void 0 : response.statusText
  });
}
function recordCacheEvent(event, payload) {
  trace.getActiveSpan()?.addEvent("gateway.cache." + event, {
    "gateway.cache.key": payload.key,
    "gateway.cache.ttl": payload.ttl
  });
}
function recordCacheError(action, error, payload) {
  trace.getActiveSpan()?.addEvent("gateway.cache.error", {
    "gateway.cache.key": payload.key,
    "gateway.cache.ttl": payload.ttl,
    "gateway.cache.action": action,
    [SEMATTRS_EXCEPTION_TYPE]: "code" in error ? error.code : error.message,
    [SEMATTRS_EXCEPTION_MESSAGE]: error.message,
    [SEMATTRS_EXCEPTION_STACKTRACE]: error.stack
  });
}
const responseCacheSymbol = Symbol.for("servedFromResponseCache");
function setExecutionResultAttributes(input) {
  const span = trace.getSpan(input.ctx);
  if (input.result && span) {
    span.setAttribute(
      "gateway.cache.response_cache",
      input.result[responseCacheSymbol] ? "hit" : "miss"
    );
  }
}
function createSchemaLoadingSpan(inputs) {
  const span = inputs.tracer.startSpan(
    "gateway.schema",
    { attributes: { "gateway.schema.changed": false } },
    inputs.ctx
  );
  const currentContext = context.active();
  if (currentContext !== inputs.ctx) {
    const currentSpan = trace.getActiveSpan();
    currentSpan?.addLink({ context: span.spanContext() });
  }
  return trace.setSpan(ROOT_CONTEXT, span);
}
function setSchemaAttributes(inputs) {
  const span = trace.getActiveSpan();
  if (!span) {
    return;
  }
  span.setAttribute("gateway.schema.changed", true);
  span.setAttribute("graphql.schema", printSchema(inputs.schema));
}
function registerException(ctx, error) {
  const span = ctx && trace.getSpan(ctx);
  if (!span) {
    return;
  }
  const message = error?.message?.toString() ?? error?.toString();
  span.setStatus({ code: SpanStatusCode.ERROR, message });
  span.recordException(error);
}

function getEnvStr(key, opts = {}) {
  const globalThat = opts.globalThis ?? globalThis;
  let variable = globalThat.process?.env?.[key] || // @ts-expect-error can exist in wrangler and maybe other runtimes
  globalThat.env?.[key] || // @ts-expect-error can exist in deno
  globalThat.Deno?.env?.get(key) || // @ts-expect-error could be
  globalThat[key];
  if (variable != null) {
    variable += "";
  } else {
    variable = void 0;
  }
  return variable?.trim();
}
function getEnvBool(key, opts = {}) {
  return strToBool(getEnvStr(key, opts));
}
function strToBool(str) {
  return ["1", "t", "true", "y", "yes", "on", "enabled"].includes(
    (str || "").toLowerCase()
  );
}

function isContextManagerCompatibleWithAsync() {
  const symbol = Symbol();
  const root = context.active();
  return context.with(root.setValue(symbol, true), () => {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(context.active().getValue(symbol) || false);
      });
    });
  });
}
const logLevelMap = {
  ALL: [DiagLogLevel.ALL, "trace"],
  VERBOSE: [DiagLogLevel.VERBOSE, "trace"],
  DEBUG: [DiagLogLevel.DEBUG, "debug"],
  INFO: [DiagLogLevel.INFO, "info"],
  WARN: [DiagLogLevel.WARN, "warn"],
  ERROR: [DiagLogLevel.ERROR, "error"],
  NONE: [DiagLogLevel.NONE, null]
};
function diagLogLevelFromEnv() {
  const value = getEnvStr("OTEL_LOG_LEVEL");
  if (value == null) {
    return void 0;
  }
  const resolvedLogLevel = logLevelMap[value.toUpperCase()];
  if (resolvedLogLevel == null) {
    diag.warn(
      `Unknown log level "${value}", expected one of ${Object.keys(logLevelMap)}, using default`
    );
    return logLevelMap["INFO"];
  }
  return resolvedLogLevel;
}

const initializationTime = "performance" in globalThis ? performance.now() : void 0;
const otelCtxForRequestId = /* @__PURE__ */ new Map();
const HeadersTextMapGetter = {
  keys(carrier) {
    return [...carrier.keys()];
  },
  get(carrier, key) {
    return carrier.get(key) || void 0;
  }
};
function useOpenTelemetry(options) {
  const inheritContext = options.inheritContext ?? true;
  const propagateContext = options.propagateContext ?? true;
  let useContextManager;
  const traces = typeof options.traces === "object" ? options.traces : {};
  let tracer;
  let initSpan;
  let pluginLogger = options.log && options.log.child("[OpenTelemetry] ");
  pluginLogger?.info("Enabled");
  function isParentEnabled(state) {
    const parentState = getMostSpecificState(state);
    return !parentState || !!parentState.otel;
  }
  function getContext(state) {
    const specificState = getMostSpecificState(state)?.otel;
    if (initSpan && !specificState) {
      return initSpan;
    }
    if (useContextManager) {
      return context.active();
    }
    return specificState?.current ?? ROOT_CONTEXT;
  }
  let preparation$ = init();
  preparation$.then(() => {
    preparation$ = fakePromise();
  });
  async function init() {
    if (options.useContextManager !== false && !await isContextManagerCompatibleWithAsync()) {
      useContextManager = false;
      if (options.useContextManager === true) {
        throw new Error(
          "[OTEL] Context Manager usage is enabled, but the registered one is not compatible with async calls. Please use another context manager, such as `AsyncLocalStorageContextManager`."
        );
      }
    } else {
      useContextManager = options.useContextManager ?? true;
    }
    pluginLogger?.info("Initializing");
    tracer = traces.tracer || trace.getTracer("gateway");
    initSpan = trace.setSpan(
      context.active(),
      tracer.startSpan("gateway.initialization", {
        startTime: initializationTime
      })
    );
    if (!useContextManager) {
      if (traces.spans?.schema) {
        pluginLogger?.warn(
          "Schema loading spans are disabled because no context manager is available"
        );
      }
      traces.spans = traces.spans ?? {};
      traces.spans.schema = false;
    }
  }
  const plugin = withState((getState) => {
    hive.setPluginUtils({
      get tracer() {
        return tracer;
      },
      getActiveContext: (matcher) => getContext(getState(matcher)),
      getHttpContext: (request) => getState({ request }).forRequest.otel?.root,
      getOperationContext: (context2) => getState({ context: context2 }).forOperation.otel?.root,
      getExecutionRequestContext: (executionRequest) => getState({ executionRequest }).forSubgraphExecution.otel?.root
    });
    return {
      get tracer() {
        return tracer;
      },
      instrumentation: {
        request({ state: { forRequest }, request }, wrapped) {
          if (!shouldTrace(traces.spans?.http, { request })) {
            return wrapped();
          }
          const url = getURL(request);
          return unfakePromise(
            preparation$.then(() => {
              const ctx = inheritContext ? propagation.extract(
                context.active(),
                request.headers,
                HeadersTextMapGetter
              ) : context.active();
              forRequest.otel = new OtelContextStack(
                createHttpSpan({ ctx, request, tracer, url }).ctx
              );
              if (useContextManager) {
                wrapped = context.bind(forRequest.otel.current, wrapped);
              }
              return wrapped();
            }).catch((error) => {
              registerException(forRequest.otel?.current, error);
              throw error;
            }).finally(() => {
              const ctx = forRequest.otel?.root;
              ctx && trace.getSpan(ctx)?.end();
            })
          );
        },
        operation({ context: gqlCtx, state: { forOperation, ...parentState } }, wrapped) {
          if (!isParentEnabled(parentState) || !shouldTrace(traces.spans?.graphql, { context: gqlCtx })) {
            return wrapped();
          }
          return unfakePromise(
            preparation$.then(() => {
              const ctx = getContext(parentState);
              forOperation.otel = new OtelContextStack(
                createGraphQLSpan({ tracer, ctx })
              );
              if (useContextManager) {
                wrapped = context.bind(forOperation.otel.current, wrapped);
              }
              return fakePromise().then(wrapped).catch((err) => {
                registerException(forOperation.otel?.current, err);
                throw err;
              }).finally(
                () => trace.getSpan(forOperation.otel.current)?.end()
              );
            })
          );
        },
        context({ state, context: gqlCtx }, wrapped) {
          if (!isParentEnabled(state) || !shouldTrace(traces.spans?.graphqlContextBuilding, {
            context: gqlCtx
          })) {
            return wrapped();
          }
          const { forOperation } = state;
          const ctx = getContext(state);
          forOperation.otel.push(
            createGraphqlContextBuildingSpan({ ctx, tracer })
          );
          if (useContextManager) {
            wrapped = context.bind(forOperation.otel.current, wrapped);
          }
          try {
            wrapped();
          } catch (err) {
            registerException(forOperation.otel?.current, err);
            throw err;
          } finally {
            trace.getSpan(forOperation.otel.current)?.end();
            forOperation.otel.pop();
          }
        },
        parse({ state, context: gqlCtx }, wrapped) {
          if (!isParentEnabled(state) || !shouldTrace(traces.spans?.graphqlParse, { context: gqlCtx })) {
            return wrapped();
          }
          const ctx = getContext(state);
          const { forOperation } = state;
          forOperation.otel.push(createGraphQLParseSpan({ ctx, tracer }));
          if (useContextManager) {
            wrapped = context.bind(forOperation.otel.current, wrapped);
          }
          try {
            wrapped();
          } catch (err) {
            registerException(forOperation.otel.current, err);
            throw err;
          } finally {
            trace.getSpan(forOperation.otel.current)?.end();
            forOperation.otel.pop();
          }
        },
        validate({ state, context: gqlCtx }, wrapped) {
          if (!isParentEnabled(state) || !shouldTrace(traces.spans?.graphqlValidate, { context: gqlCtx })) {
            return wrapped();
          }
          const { forOperation } = state;
          forOperation.otel.push(
            createGraphQLValidateSpan({
              ctx: getContext(state),
              tracer,
              query: gqlCtx.params.query?.trim(),
              operationName: gqlCtx.params.operationName
            })
          );
          if (useContextManager) {
            wrapped = context.bind(forOperation.otel.current, wrapped);
          }
          try {
            wrapped();
          } catch (err) {
            registerException(forOperation.otel?.current, err);
            throw err;
          } finally {
            trace.getSpan(forOperation.otel.current)?.end();
            forOperation.otel.pop();
          }
        },
        execute({ state, context: gqlCtx }, wrapped) {
          if (!isParentEnabled(state) || !shouldTrace(traces.spans?.graphqlExecute, { context: gqlCtx })) {
            state.forOperation.skipExecuteSpan = true;
            return wrapped();
          }
          const ctx = getContext(state);
          const { forOperation } = state;
          forOperation.otel?.push(createGraphQLExecuteSpan({ ctx, tracer }));
          if (useContextManager) {
            wrapped = context.bind(forOperation.otel.current, wrapped);
          }
          return unfakePromise(
            fakePromise().then(wrapped).catch((err) => {
              registerException(forOperation.otel.current, err);
              throw err;
            }).finally(() => {
              trace.getSpan(forOperation.otel.current)?.end();
              forOperation.otel.pop();
            })
          );
        },
        subgraphExecute({
          state: { forSubgraphExecution, ...parentState },
          executionRequest,
          subgraphName
        }, wrapped) {
          const isIntrospection = !executionRequest.context.params;
          if (!isParentEnabled(parentState) || parentState.forOperation?.skipExecuteSpan || !shouldTrace(
            isIntrospection ? traces.spans?.schema : traces.spans?.subgraphExecute,
            {
              subgraphName,
              executionRequest
            }
          )) {
            return wrapped();
          }
          const parentContext = isIntrospection ? context.active() : getContext(parentState);
          forSubgraphExecution.otel = new OtelContextStack(
            createSubgraphExecuteSpan({
              ctx: parentContext,
              tracer,
              executionRequest,
              subgraphName
            })
          );
          if (useContextManager) {
            wrapped = context.bind(forSubgraphExecution.otel.current, wrapped);
          }
          return unfakePromise(
            fakePromise().then(wrapped).catch((err) => {
              registerException(forSubgraphExecution.otel.current, err);
              throw err;
            }).finally(() => {
              trace.getSpan(forSubgraphExecution.otel.current)?.end();
              forSubgraphExecution.otel.pop();
            })
          );
        },
        fetch({ state, executionRequest }, wrapped) {
          if (isRetryExecutionRequest$1(executionRequest)) {
            state = getState(getRetryInfo$1(executionRequest));
          }
          if (!isParentEnabled(state) || !shouldTrace(traces.spans?.upstreamFetch, { executionRequest })) {
            return wrapped();
          }
          return unfakePromise(
            preparation$.then(() => {
              const { forSubgraphExecution } = state;
              const ctx = createUpstreamHttpFetchSpan({
                ctx: getContext(state),
                tracer
              });
              forSubgraphExecution?.otel.push(ctx);
              if (useContextManager) {
                wrapped = context.bind(ctx, wrapped);
              }
              return fakePromise().then(wrapped).catch((err) => {
                registerException(ctx, err);
                throw err;
              }).finally(() => {
                trace.getSpan(ctx)?.end();
                forSubgraphExecution?.otel.pop();
              });
            })
          );
        },
        schema(_, wrapped) {
          if (!shouldTrace(traces.spans?.schema, null)) {
            return wrapped();
          }
          return unfakePromise(
            preparation$.then(() => {
              const ctx = createSchemaLoadingSpan({
                ctx: initSpan ?? ROOT_CONTEXT,
                tracer
              });
              return fakePromise().then(() => context.with(ctx, wrapped)).catch((err) => {
                trace.getSpan(ctx)?.recordException(err);
              }).finally(() => {
                trace.getSpan(ctx)?.end();
              });
            })
          );
        }
      },
      onYogaInit({ yoga }) {
        pluginLogger ??= new Logger({
          writers: [
            {
              write(level, attrs, msg) {
                level = level === "trace" ? "debug" : level;
                yoga.logger[level](msg, attrs);
              }
            }
          ]
        }).child("[OpenTelemetry] ");
        pluginLogger.debug(
          `Context manager is ${useContextManager ? "enabled" : "disabled"}`
        );
      },
      onRequest({ state, serverContext }) {
        if (!useContextManager) {
          const requestId = (
            // TODO: serverContext.log will not be available in Yoga, this will be fixed when Hive Logger is integrated into Yoga
            serverContext.log?.attrs?.[
              // @ts-expect-error even if the attrs is an array this will work
              "requestId"
            ]
          );
          if (typeof requestId === "string") {
            otelCtxForRequestId.set(requestId, getContext(state));
          }
        }
      },
      onEnveloped({ state, extendContext }) {
        extendContext({
          openTelemetry: {
            tracer,
            getHttpContext: (request) => {
              const { forRequest } = request ? getState({ request }) : state;
              return forRequest.otel?.root;
            },
            getOperationContext: (context2) => {
              const { forOperation } = context2 ? getState({ context: context2 }) : state;
              return forOperation.otel?.root;
            },
            getExecutionRequestContext: (executionRequest) => {
              return getState({ executionRequest }).forSubgraphExecution.otel?.root;
            },
            getActiveContext: (contextMatcher) => getContext(contextMatcher ? getState(contextMatcher) : state)
          }
        });
      },
      onCacheGet: (payload) => shouldTrace(traces.events?.cache, { key: payload.key, action: "read" }) ? {
        onCacheMiss: () => recordCacheEvent("miss", payload),
        onCacheHit: () => recordCacheEvent("hit", payload),
        onCacheGetError: ({ error }) => recordCacheError("read", error, payload)
      } : void 0,
      onCacheSet: (payload) => shouldTrace(traces.events?.cache, { key: payload.key, action: "write" }) ? {
        onCacheSetDone: () => recordCacheEvent("write", payload),
        onCacheSetError: ({ error }) => recordCacheError("write", error, payload)
      } : void 0,
      onResponse({ response, state, serverContext }) {
        state.forRequest.otel && setResponseAttributes(state.forRequest.otel.root, response);
        if (!useContextManager) {
          const requestId = (
            // TODO: serverContext.log will not be available in Yoga, this will be fixed when Hive Logger is integrated into Yoga
            serverContext.log?.attrs?.[
              // @ts-expect-error even if the attrs is an array this will work
              "requestId"
            ]
          );
          if (typeof requestId === "string") {
            otelCtxForRequestId.delete(requestId);
          }
        }
      },
      onParams({ state, context: gqlCtx, params }) {
        if (!isParentEnabled(state) || !shouldTrace(traces.spans?.graphql, { context: gqlCtx })) {
          return;
        }
        const ctx = getContext(state);
        setParamsAttributes({ ctx, params });
      },
      onExecutionResult({ result, context: gqlCtx, state }) {
        if (!isParentEnabled(state) || !shouldTrace(traces.spans?.graphql, { context: gqlCtx })) {
          return;
        }
        setExecutionResultAttributes({ ctx: getContext(state), result });
      },
      onParse({ state, context: gqlCtx }) {
        if (!isParentEnabled(state) || !shouldTrace(traces.spans?.graphqlParse, { context: gqlCtx })) {
          return;
        }
        return ({ result }) => {
          setGraphQLParseAttributes({
            ctx: getContext(state),
            operationName: gqlCtx.params.operationName,
            query: gqlCtx.params.query?.trim(),
            result
          });
        };
      },
      onValidate({ state, context: gqlCtx }) {
        if (!isParentEnabled(state) || !shouldTrace(traces.spans?.graphqlValidate, { context: gqlCtx })) {
          return;
        }
        return ({ result }) => {
          setGraphQLValidateAttributes({ ctx: getContext(state), result });
        };
      },
      onExecute({ state, args }) {
        if (!isParentEnabled(state)) {
          return;
        }
        setExecutionAttributesOnOperationSpan({
          ctx: state.forOperation.otel.root,
          args,
          hashOperationFn: options.hashOperation
        });
        if (state.forOperation.skipExecuteSpan) {
          return;
        }
        const ctx = getContext(state);
        setGraphQLExecutionAttributes({ ctx, args });
        state.forOperation.subgraphNames = [];
        return {
          onExecuteDone({ result }) {
            setGraphQLExecutionResultAttributes({
              ctx,
              result,
              subgraphNames: state.forOperation.subgraphNames
            });
          }
        };
      },
      onSubgraphExecute({ subgraphName, state }) {
        state.forOperation?.subgraphNames?.push(subgraphName);
      },
      onFetch(payload) {
        const { url, setFetchFn, fetchFn, executionRequest } = payload;
        let { state } = payload;
        if (executionRequest && isRetryExecutionRequest$1(executionRequest)) {
          state = getState(getRetryInfo$1(executionRequest));
        }
        if (propagateContext) {
          setFetchFn((url2, options2, ...args) => {
            const reqHeaders = getHeadersObj(options2?.headers || {});
            propagation.inject(getContext(state), reqHeaders);
            return fetchFn(url2, { ...options2, headers: reqHeaders }, ...args);
          });
        }
        if (!isParentEnabled(state) || !shouldTrace(traces.spans?.upstreamFetch, { executionRequest })) {
          return;
        }
        const ctx = getContext(state);
        setUpstreamFetchAttributes({
          ctx,
          url,
          options: payload.options,
          executionRequest
        });
        return ({ response }) => {
          setUpstreamFetchResponseAttributes({ ctx, response });
        };
      },
      onSchemaChange(payload) {
        setSchemaAttributes(payload);
        if (initSpan) {
          trace.getSpan(initSpan)?.end();
          initSpan = null;
        }
      },
      onDispose() {
        if (options.flushOnDispose !== false) {
          const flushMethod = options.flushOnDispose ?? "forceFlush";
          const provider = trace.getTracerProvider();
          if (flushMethod in provider && typeof provider[flushMethod] === "function") {
            return provider[flushMethod]();
          }
        }
      }
    };
  });
  plugin.getActiveContext = hive.getActiveContext;
  plugin.getHttpContext = hive.getHttpContext;
  plugin.getOperationContext = hive.getOperationContext;
  plugin.getExecutionRequestContext = hive.getExecutionRequestContext;
  Object.defineProperty(plugin, "tracer", {
    enumerable: true,
    get: () => tracer
  });
  return plugin;
}
function shouldTrace(value, args) {
  if (value == null) {
    return true;
  }
  if (typeof value === "function") {
    return value(args);
  }
  return value;
}
function getURL(request) {
  if ("parsedUrl" in request) {
    return request.parsedUrl;
  }
  return new URL(request.url, "http://localhost");
}

export { SEMATTRS_GRAPHQL_DOCUMENT as S, SEMATTRS_GRAPHQL_OPERATION_TYPE as a, SEMATTRS_GRAPHQL_OPERATION_NAME as b, SEMATTRS_HIVE_GRAPHQL_OPERATION_HASH as c, SEMATTRS_HIVE_GRAPHQL_ERROR_COUNT as d, SEMATTRS_HIVE_GRAPHQL_ERROR_CODES as e, SEMATTRS_HIVE_GATEWAY_UPSTREAM_SUBGRAPH_NAME as f, SEMATTRS_HIVE_GATEWAY_OPERATION_SUBGRAPH_NAMES as g, getEnvBool as h, diagLogLevelFromEnv as i, getEnvStr as j, otelCtxForRequestId as o, useOpenTelemetry as u };
