import { buildASTSchema, buildClientSchema, DirectiveLocation, getIntrospectionQuery, getNamedType, GraphQLDirective, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLSchema, GraphQLString, isObjectType, Kind, parse, visit, } from 'graphql';
import { stringInterpolator } from '@graphql-mesh/string-interpolation';
import { isUrl, readFile } from '@graphql-mesh/utils';
import { createGraphQLError, isValidPath, } from '@graphql-tools/utils';
import { handleMaybePromise } from '@whatwg-node/promise-helpers';
function fixExtends(node) {
    return visit(node, {
        [Kind.DIRECTIVE](node) {
            if (node.name.value === 'link') {
                const url = node.arguments?.find(arg => arg.name.value === 'url')?.value;
                if (url?.kind === Kind.STRING &&
                    url.value.startsWith('https://specs.apollo.dev/federation/v2.')) {
                    const imports = node.arguments?.find(arg => arg.name.value === 'import')?.value;
                    if (imports?.kind === Kind.LIST) {
                        // @ts-expect-error - We can modify it
                        imports.values.push({
                            kind: Kind.STRING,
                            value: '@extends',
                        });
                    }
                }
            }
        },
        [Kind.OBJECT_TYPE_EXTENSION](node) {
            return {
                ...node,
                directives: [
                    ...(node.directives || []),
                    {
                        kind: Kind.DIRECTIVE,
                        name: {
                            kind: Kind.NAME,
                            value: 'extends',
                        },
                    },
                ],
                kind: Kind.OBJECT_TYPE_DEFINITION,
            };
        },
        [Kind.INTERFACE_TYPE_EXTENSION](node) {
            return {
                ...node,
                directives: [
                    ...(node.directives || []),
                    {
                        kind: Kind.DIRECTIVE,
                        name: {
                            kind: Kind.NAME,
                            value: 'extends',
                        },
                    },
                ],
                kind: Kind.INTERFACE_TYPE_DEFINITION,
            };
        },
        [Kind.UNION_TYPE_EXTENSION](node) {
            return {
                ...node,
                directives: [
                    ...(node.directives || []),
                    {
                        kind: Kind.DIRECTIVE,
                        name: {
                            kind: Kind.NAME,
                            value: 'extends',
                        },
                    },
                ],
                kind: Kind.UNION_TYPE_DEFINITION,
            };
        },
        [Kind.INPUT_OBJECT_TYPE_EXTENSION](node) {
            return {
                ...node,
                directives: [
                    ...(node.directives || []),
                    {
                        kind: Kind.DIRECTIVE,
                        name: {
                            kind: Kind.NAME,
                            value: 'extends',
                        },
                    },
                ],
                kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
            };
        },
        [Kind.ENUM_TYPE_EXTENSION](node) {
            return {
                ...node,
                directives: [
                    ...(node.directives || []),
                    {
                        kind: Kind.DIRECTIVE,
                        name: {
                            kind: Kind.NAME,
                            value: 'extends',
                        },
                    },
                ],
                kind: Kind.ENUM_TYPE_DEFINITION,
            };
        },
        [Kind.SCALAR_TYPE_EXTENSION](node) {
            return {
                ...node,
                directives: [
                    ...(node.directives || []),
                    {
                        kind: Kind.DIRECTIVE,
                        name: {
                            kind: Kind.NAME,
                            value: 'extends',
                        },
                    },
                ],
                kind: Kind.SCALAR_TYPE_DEFINITION,
            };
        },
    });
}
export function loadGraphQLHTTPSubgraph(subgraphName, { endpoint, method, useGETForQueries, operationHeaders, credentials, retry, timeout, source, schemaHeaders, federation = false, transportKind = 'http', }) {
    return (ctx) => {
        let schema$;
        const interpolationData = {
            env: process.env,
        };
        const interpolatedEndpoint = stringInterpolator.parse(endpoint, interpolationData);
        const interpolatedSource = stringInterpolator.parse(source, interpolationData);
        function handleFetchedSchema(schema) {
            return addAnnotations({
                kind: transportKind,
                subgraph: subgraphName,
                location: endpoint,
                headers: operationHeaders ? Object.entries(operationHeaders) : undefined,
                options: {
                    method,
                    useGETForQueries,
                    credentials,
                    retry,
                    timeout,
                },
            }, schema);
        }
        if (interpolatedSource) {
            schema$ = handleMaybePromise(() => {
                let source$;
                if (isUrl(interpolatedSource)) {
                    source$ = handleMaybePromise(() => ctx.fetch(interpolatedSource, {
                        headers: schemaHeaders,
                    }), res => res.text());
                }
                else if (isValidPath(interpolatedSource)) {
                    source$ = readFile(interpolatedSource, {
                        allowUnknownExtensions: true,
                        cwd: ctx.cwd,
                        fetch: ctx.fetch,
                        importFn: (p) => import(p),
                        logger: ctx.logger,
                    });
                }
                return source$;
            }, sdl => buildASTSchema(fixExtends(parse(sdl, { noLocation: true })), {
                assumeValidSDL: true,
                assumeValid: true,
            }));
        }
        else {
            const fetchAsRegular = () => handleMaybePromise(() => ctx.fetch(interpolatedEndpoint, {
                method: method || (useGETForQueries ? 'GET' : 'POST'),
                headers: {
                    'Content-Type': 'application/json',
                    ...schemaHeaders,
                },
                body: JSON.stringify({
                    query: getIntrospectionQuery(),
                }),
            }), res => {
                assertResponseOk(res);
                return handleMaybePromise(() => res.json(), (result) => {
                    if (result.errors) {
                        throw new AggregateError(result.errors.map(err => createGraphQLError(err.message, err)), 'Introspection Query Failed');
                    }
                    const schema = buildClientSchema(result.data, {
                        assumeValid: true,
                    });
                    const queryType = schema.getQueryType();
                    const queryFields = queryType?.getFields();
                    if (queryFields._service) {
                        const serviceType = getNamedType(queryFields._service.type);
                        if (isObjectType(serviceType)) {
                            const serviceTypeFields = serviceType.getFields();
                            if (serviceTypeFields.sdl) {
                                return fetchAsFederation();
                            }
                        }
                    }
                    return schema;
                });
            });
            const fetchAsFederation = () => handleMaybePromise(() => ctx.fetch(interpolatedEndpoint, {
                method: method || (useGETForQueries ? 'GET' : 'POST'),
                headers: {
                    'Content-Type': 'application/json',
                    ...schemaHeaders,
                },
                body: JSON.stringify({
                    query: federationIntrospectionQuery,
                }),
            }), res => {
                assertResponseOk(res);
                return handleMaybePromise(() => res.json(), (result) => {
                    if (result.errors) {
                        throw new AggregateError(result.errors.map(err => createGraphQLError(err.message, err)), 'Introspection Query Failed');
                    }
                    if (!result.data?._service?.sdl) {
                        throw new Error('Federation subgraph does not provide SDL');
                    }
                    // Replace "extend" keyword with "@extends"
                    return buildASTSchema(fixExtends(parse(result.data._service.sdl, { noLocation: true })), {
                        assumeValidSDL: true,
                        assumeValid: true,
                    });
                });
            });
            schema$ = federation ? fetchAsFederation() : fetchAsRegular();
        }
        schema$ = handleMaybePromise(() => schema$, handleFetchedSchema);
        return {
            name: subgraphName,
            schema$,
        };
    };
}
const transportDirective = new GraphQLDirective({
    name: 'transport',
    isRepeatable: true,
    locations: [DirectiveLocation.SCHEMA],
    args: {
        kind: { type: new GraphQLNonNull(GraphQLString) },
        subgraph: { type: new GraphQLNonNull(GraphQLString) },
        location: { type: new GraphQLNonNull(GraphQLString) },
        headers: { type: new GraphQLList(new GraphQLList(GraphQLString)) },
        options: { type: new GraphQLScalarType({ name: 'TransportOptions' }) },
    },
});
function addAnnotations(transportEntry, schema) {
    const schemaExtensions = (schema.extensions ||= {});
    schemaExtensions.directives ||= {};
    schemaExtensions.directives.transport = transportEntry;
    if (schema.getDirective('transport')) {
        return schema;
    }
    const schemaConfig = schema.toConfig();
    return new GraphQLSchema({
        ...schemaConfig,
        directives: [...schemaConfig.directives, transportDirective],
    });
}
const federationIntrospectionQuery = /* GraphQL */ `
  query GetFederationInfo {
    _service {
      sdl
    }
  }
`;
function assertResponseOk(response) {
    if (!response.ok) {
        throw new Error(`Failed to load GraphQL HTTP subgraph: ${response.statusText}`);
    }
}
