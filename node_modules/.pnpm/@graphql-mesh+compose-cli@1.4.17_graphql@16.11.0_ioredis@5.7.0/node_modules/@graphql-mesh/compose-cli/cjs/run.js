"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = run;
const tslib_1 = require("tslib");
require("dotenv/config"); // inject dotenv options to process.env
// eslint-disable-next-line import/no-nodejs-modules
const node_console_1 = require("node:console");
// eslint-disable-next-line import/no-nodejs-modules
const node_fs_1 = require("node:fs");
// eslint-disable-next-line import/no-nodejs-modules
const node_module_1 = tslib_1.__importDefault(require("node:module"));
// eslint-disable-next-line import/no-nodejs-modules
const node_path_1 = require("node:path");
// eslint-disable-next-line import/no-nodejs-modules
const node_url_1 = require("node:url");
const graphql_1 = require("graphql");
const extra_typings_1 = require("@commander-js/extra-typings");
const utils_1 = require("@graphql-mesh/utils");
const getComposedSchemaFromConfig_js_1 = require("./getComposedSchemaFromConfig.js");
/** Default config paths sorted by priority. */
const defaultConfigPaths = [
    'mesh.config.ts',
    'mesh.config.mts',
    'mesh.config.cts',
    'mesh.config.js',
    'mesh.config.mjs',
    'mesh.config.cjs',
];
let program = new extra_typings_1.Command()
    .addOption(new extra_typings_1.Option('-c, --config-path <path>', `path to the configuration file. defaults to the following files respectively in the current working directory: ${defaultConfigPaths.join(', ')}`).env('CONFIG_PATH'))
    .option('--subgraph <name>', 'name of the subgraph to compose')
    .option('-o, --output <path>', 'path to the output file');
async function run({ log: rootLog = new utils_1.DefaultLogger(undefined, undefined, undefined, new node_console_1.Console(process.stderr)), productName = 'Mesh Compose', productDescription = 'compose a GraphQL federated schema from any API service(s)', binName = 'mesh-compose', version, }) {
    node_module_1.default.register('@graphql-mesh/include/hooks', 
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore bob will complain when bundling for cjs
    require('node:url').pathToFileURL(__filename));
    program = program.name(binName).description(productDescription);
    if (version)
        program = program.version(version);
    if (process.env.NODE_ENV === 'test')
        program = program.allowUnknownOption().allowExcessArguments();
    const opts = program.parse().opts();
    const log = rootLog.child(productName);
    let importedConfig;
    if (!opts.configPath) {
        log.debug(`Searching for default config files`);
        for (const configPath of defaultConfigPaths) {
            const absoluteConfigPath = (0, node_path_1.join)(process.cwd(), configPath);
            const exists = await node_fs_1.promises
                .lstat(absoluteConfigPath)
                .then(() => true)
                .catch(() => false);
            if (exists) {
                log.info(`Found default config file ${absoluteConfigPath}`);
                const importUrl = (0, node_url_1.pathToFileURL)(absoluteConfigPath).toString();
                const module = await Promise.resolve(`${importUrl}`).then(s => tslib_1.__importStar(require(s)));
                importedConfig = Object(module).composeConfig;
                if (!importedConfig) {
                    throw new Error(`No "composeConfig" exported from default config at ${configPath}`);
                }
                break;
            }
        }
        if (!importedConfig) {
            throw new Error(`Cannot find default config file at ${defaultConfigPaths.join(' or ')} in the current working directory`);
        }
    }
    else {
        // using user-provided config
        const configPath = (0, node_path_1.isAbsolute)(opts.configPath)
            ? opts.configPath
            : (0, node_path_1.join)(process.cwd(), opts.configPath);
        log.debug(`Loading config file at path ${configPath}`);
        const exists = await node_fs_1.promises
            .lstat(configPath)
            .then(() => true)
            .catch(() => false);
        if (!exists) {
            throw new Error(`Cannot find config file at ${configPath}`);
        }
        const importUrl = (0, node_url_1.pathToFileURL)(configPath).toString();
        const module = await Promise.resolve(`${importUrl}`).then(s => tslib_1.__importStar(require(s)));
        importedConfig = Object(module).composeConfig;
        if (!importedConfig) {
            throw new Error(`No "composeConfig" exported from config at ${configPath}`);
        }
    }
    log.info('Loaded config');
    const config = {
        ...importedConfig,
        ...opts,
    };
    log.info('Composing');
    const supergraphSdl = await (0, getComposedSchemaFromConfig_js_1.getComposedSchemaFromConfig)(config, log);
    let output = config.output;
    if (!output) {
        if (typeof process === 'object') {
            process.stdout.write(supergraphSdl + '\n');
        }
        else {
            console.log(supergraphSdl);
        }
        log.info('Done!');
        return;
    }
    log.info(`Writing schema to ${output}`);
    output = (0, node_path_1.isAbsolute)(output) ? output : (0, node_path_1.join)(process.cwd(), output);
    let writtenData;
    if (output.endsWith('.json')) {
        writtenData = JSON.stringify((0, graphql_1.parse)(supergraphSdl, { noLocation: true }), null, 2);
    }
    else if (output.endsWith('.graphql') ||
        output.endsWith('.gql') ||
        output.endsWith('.graphqls') ||
        output.endsWith('.gqls')) {
        writtenData = supergraphSdl;
    }
    else if (output.endsWith('.ts') ||
        output.endsWith('.cts') ||
        output.endsWith('.mts') ||
        output.endsWith('.js') ||
        output.endsWith('.cjs') ||
        output.endsWith('.mjs')) {
        writtenData = `export default ${JSON.stringify(supergraphSdl)}`;
    }
    else {
        throw new Error(`Unsupported file extension for ${output}`);
    }
    await node_fs_1.promises.writeFile(output, writtenData, 'utf8');
    log.info('Done!');
}
