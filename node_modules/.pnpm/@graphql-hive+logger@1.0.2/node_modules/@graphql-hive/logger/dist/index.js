import { g as getDefaultExportFromCjs, a as getEnvBool, j as jsonStringify, b as getEnvStr, J as JSONLogWriter, f as fastSafeStringify } from './json-Bv_tOStG.js';

function createDeferredPromise() {
    if (Promise.withResolvers) {
        return Promise.withResolvers();
    }
    let resolveFn;
    let rejectFn;
    const promise = new Promise(function deferredPromiseExecutor(resolve, reject) {
        resolveFn = resolve;
        rejectFn = reject;
    });
    return {
        promise,
        get resolve() {
            return resolveFn;
        },
        get reject() {
            return rejectFn;
        },
    };
}

const DisposableSymbols = {
    get asyncDispose() {
        return Symbol.asyncDispose || Symbol.for('asyncDispose');
    },
};

function tryStringify (o) {
  try { return JSON.stringify(o) } catch(e) { return '"[Circular]"' }
}

var quickFormatUnescaped = format;

function format(f, args, opts) {
  var ss = (opts && opts.stringify) || tryStringify;
  var offset = 1;
  if (typeof f === 'object' && f !== null) {
    var len = args.length + offset;
    if (len === 1) return f
    var objects = new Array(len);
    objects[0] = ss(f);
    for (var index = 1; index < len; index++) {
      objects[index] = ss(args[index]);
    }
    return objects.join(' ')
  }
  if (typeof f !== 'string') {
    return f
  }
  var argLen = args.length;
  if (argLen === 0) return f
  var str = '';
  var a = 1 - offset;
  var lastPos = -1;
  var flen = (f && f.length) || 0;
  for (var i = 0; i < flen;) {
    if (f.charCodeAt(i) === 37 && i + 1 < flen) {
      lastPos = lastPos > -1 ? lastPos : 0;
      switch (f.charCodeAt(i + 1)) {
        case 100: // 'd'
        case 102: // 'f'
          if (a >= argLen)
            break
          if (args[a] == null)  break
          if (lastPos < i)
            str += f.slice(lastPos, i);
          str += Number(args[a]);
          lastPos = i + 2;
          i++;
          break
        case 105: // 'i'
          if (a >= argLen)
            break
          if (args[a] == null)  break
          if (lastPos < i)
            str += f.slice(lastPos, i);
          str += Math.floor(Number(args[a]));
          lastPos = i + 2;
          i++;
          break
        case 79: // 'O'
        case 111: // 'o'
        case 106: // 'j'
          if (a >= argLen)
            break
          if (args[a] === undefined) break
          if (lastPos < i)
            str += f.slice(lastPos, i);
          var type = typeof args[a];
          if (type === 'string') {
            str += '\'' + args[a] + '\'';
            lastPos = i + 2;
            i++;
            break
          }
          if (type === 'function') {
            str += args[a].name || '<anonymous>';
            lastPos = i + 2;
            i++;
            break
          }
          str += ss(args[a]);
          lastPos = i + 2;
          i++;
          break
        case 115: // 's'
          if (a >= argLen)
            break
          if (lastPos < i)
            str += f.slice(lastPos, i);
          str += String(args[a]);
          lastPos = i + 2;
          i++;
          break
        case 37: // '%'
          if (lastPos < i)
            str += f.slice(lastPos, i);
          str += '%';
          lastPos = i + 2;
          i++;
          a--;
          break
      }
      ++a;
    }
    ++i;
  }
  if (lastPos === -1)
    return f
  else if (lastPos < flen) {
    str += f.slice(lastPos);
  }

  return str
}

var format$1 = /*@__PURE__*/getDefaultExportFromCjs(quickFormatUnescaped);

const logLevel = {
  trace: 0,
  debug: 1,
  info: 2,
  warn: 3,
  error: 4
};
function shouldLog(setLevel, loggingLevel) {
  setLevel = typeof setLevel === "function" ? setLevel() : setLevel;
  return setLevel !== false && // logging is not disabled
  logLevel[setLevel] <= logLevel[loggingLevel];
}
function logLevelToString(level) {
  switch (level) {
    case "trace":
      return "TRC";
    case "debug":
      return "DBG";
    case "info":
      return "INF";
    case "warn":
      return "WRN";
    case "error":
      return "ERR";
    default:
      throw new Error(`Unknown log level "${level}"`);
  }
}
function isPromise(val) {
  const obj = Object(val);
  return typeof obj.then === "function" && typeof obj.catch === "function" && typeof obj.finally === "function";
}
function parseAttrs(attrs, functionUnwrapDepth = 0) {
  if (functionUnwrapDepth > 3) {
    throw new Error("Too much recursion while unwrapping function attributes");
  }
  if (!attrs) {
    return void 0;
  }
  if (typeof attrs === "function") {
    return parseAttrs(attrs(), functionUnwrapDepth + 1);
  }
  if (Array.isArray(attrs)) {
    return attrs.map((val) => unwrapAttrVal(val));
  }
  if (isPlainObject(attrs)) {
    const unwrapped = {};
    for (const key of Object.keys(attrs)) {
      const val = attrs[key];
      unwrapped[key] = unwrapAttrVal(val);
    }
    return unwrapped;
  }
  return objectifyClass(attrs);
}
function unwrapAttrVal(attr, visited = /* @__PURE__ */ new WeakSet()) {
  if (!attr) {
    return attr;
  }
  if (isPrimitive(attr)) {
    return attr;
  }
  if (typeof attr === "function") {
    return `[Function: ${attr.name || "(anonymous)"}]`;
  }
  if (visited.has(attr)) {
    return "[Circular]";
  }
  visited.add(attr);
  if (Array.isArray(attr)) {
    return attr.map((val) => unwrapAttrVal(val));
  }
  if (isPlainObject(attr)) {
    const unwrapped = {};
    for (const key of Object.keys(attr)) {
      const val = attr[key];
      unwrapped[key] = unwrapAttrVal(val, visited);
    }
    return unwrapped;
  }
  return objectifyClass(attr);
}
function isPrimitive(val) {
  return val !== Object(val);
}
const nodejsCustomInspectSy = Symbol.for("nodejs.util.inspect.custom");
function objectifyClass(val) {
  if (
    // simply empty
    !val || // Object.create(null)
    Object(val).__proto__ == null
  ) {
    return {};
  }
  if (typeof val === "object" && "toJSON" in val && typeof val.toJSON === "function") {
    return val.toJSON();
  }
  if (typeof val === "object" && nodejsCustomInspectSy in val && typeof val[nodejsCustomInspectSy] === "function") {
    return {
      [nodejsCustomInspectSy.toString()]: unwrapAttrVal(
        val[nodejsCustomInspectSy](Infinity, {})
      ),
      class: val.constructor.name
    };
  }
  const props = {};
  for (const propName of Object.getOwnPropertyNames(val)) {
    props[propName] = unwrapAttrVal(val[propName]);
  }
  for (const protoPropName of Object.getOwnPropertyNames(
    Object.getPrototypeOf(val)
  )) {
    const propVal = val[protoPropName];
    if (typeof propVal === "function") {
      continue;
    }
    props[protoPropName] = unwrapAttrVal(propVal);
  }
  return {
    ...props,
    class: val.constructor.name
  };
}
function shallowMergeAttributes(target, source) {
  switch (true) {
    case (Array.isArray(source) && Array.isArray(target)):
      return [...target, ...source];
    case Array.isArray(source):
      return target ? [target, ...source] : source;
    case Array.isArray(target):
      return source ? [...target, source] : target;
    case !!(target || source):
      return { ...target, ...source };
    default:
      return void 0;
  }
}
function isPlainObject(val) {
  return Object(val).constructor === Object && Object.getPrototypeOf(val) === Object.prototype;
}

const asciMap = {
  timestamp: "\x1B[90m",
  // bright black
  trace: "\x1B[36m",
  // cyan
  debug: "\x1B[90m",
  // bright black
  info: "\x1B[32m",
  // green
  warn: "\x1B[33m",
  // yellow
  error: "\x1B[41;39m",
  // red; white
  message: "\x1B[1m",
  // bold
  key: "\x1B[35m",
  // magenta
  reset: "\x1B[0m"
  // reset
};
class ConsoleLogWriter {
  #console;
  #noColor;
  #noTimestamp;
  #async;
  constructor(opts = {}) {
    const {
      console = globalThis.console,
      // no color if we're running in browser-like (edge) environments
      noColor = typeof process === "undefined" || // or no color if https://no-color.org/
      getEnvBool("NO_COLOR"),
      noTimestamp = false,
      async = false
    } = opts;
    this.#console = console;
    this.#noColor = noColor;
    this.#noTimestamp = noTimestamp;
    this.#async = async;
  }
  color(style, text) {
    if (!text) {
      return text;
    }
    if (this.#noColor) {
      return text;
    }
    return asciMap[style] + text + asciMap.reset;
  }
  #writeToConsole(level, attrs, msg) {
    this.#console[level === "trace" ? "debug" : level](
      [
        !this.#noTimestamp && this.color("timestamp", (/* @__PURE__ */ new Date()).toISOString()),
        this.color(level, logLevelToString(level)),
        this.color("message", msg),
        attrs && this.stringifyAttrs(attrs)
      ].filter(Boolean).join(" ")
    );
  }
  write(level, attrs, msg) {
    if (this.#async) {
      const { promise, resolve } = createDeferredPromise();
      setTimeout(() => {
        this.#writeToConsole(level, attrs, msg);
        resolve();
      }, 0);
      return promise;
    }
    this.#writeToConsole(level, attrs, msg);
  }
  stringifyAttrs(attrs) {
    let log = "\n";
    for (const line of jsonStringify(attrs, true).split("\n")) {
      if (line === "{" || line === "}" || line === "[" || line === "]") {
        continue;
      }
      let formattedLine = line;
      formattedLine = formattedLine.replace(
        /"([^"]+)":/,
        this.color("key", "$1:")
      );
      let indentationSize = line.match(/^\s*/)?.[0]?.length || 0;
      if (indentationSize) indentationSize++;
      formattedLine = formattedLine.replaceAll(
        /\\n/g,
        "\n" + [...Array(indentationSize)].join(" ")
      );
      formattedLine = formattedLine.replace(/,$/, "");
      formattedLine = formattedLine.replace(
        /(\[|\{|\]|\})$/,
        this.color("key", "$1")
      );
      log += formattedLine + "\n";
    }
    log = log.slice(0, -1);
    return log;
  }
}

class MemoryLogWriter {
  logs = [];
  write(level, attrs, msg) {
    this.logs.push({
      level,
      ...msg ? { msg } : {},
      ...attrs ? { attrs } : {}
    });
  }
}

class Logger {
  #level;
  #prefix;
  #attrs;
  #writers;
  #pendingWrites;
  constructor(opts = {}) {
    let logLevelEnv = getEnvStr("LOG_LEVEL");
    if (logLevelEnv && !(logLevelEnv in logLevel)) {
      throw new Error(
        `Invalid LOG_LEVEL environment variable "${logLevelEnv}". Must be one of: ${[...Object.keys(logLevel), "false"].join(",  ")}`
      );
    }
    this.#level = opts.level ?? logLevelEnv ?? (getEnvBool("DEBUG") ? "debug" : "info");
    this.#prefix = opts.prefix;
    this.#attrs = opts.attrs;
    this.#writers = opts.writers ?? (getEnvBool("LOG_JSON") ? [new JSONLogWriter()] : [new ConsoleLogWriter()]);
  }
  /** The prefix that's prepended to each log message. */
  get prefix() {
    return this.#prefix;
  }
  /**
   * The attributes that are added to each log. If the log itself contains
   * attributes with keys existing in {@link attrs}, the log's attributes will
   * override.
   */
  get attrs() {
    return this.#attrs;
  }
  /** The current {@link LogLevel} of the logger. You can change the level using the {@link setLevel} method. */
  get level() {
    return typeof this.#level === "function" ? this.#level() : this.#level;
  }
  /**
   * Sets the new {@link LogLevel} of the logger. All subsequent logs, and {@link child child loggers} whose
   * level did not change, will respect the new level.
   */
  setLevel(level) {
    this.#level = level;
  }
  write(level, attrs, msg) {
    for (const w of this.#writers) {
      const write$ = w.write(level, attrs, msg);
      if (isPromise(write$)) {
        this.#pendingWrites ??= /* @__PURE__ */ new Set();
        this.#pendingWrites.add(write$);
        write$.then(() => {
          this.#pendingWrites.delete(write$);
        }).catch((e) => {
          console.error("Failed to write async log", e);
        });
      }
    }
  }
  flush() {
    const writerFlushes = this.#writers.map((w) => w.flush).filter((f) => !!f);
    if (this.#pendingWrites?.size || writerFlushes.length) {
      const errs = [];
      return Promise.allSettled([
        ...Array.from(this.#pendingWrites || []).map(
          (w) => w.catch((err) => errs.push(err))
        ),
        ...Array.from(writerFlushes || []).map(async (f) => {
          try {
            await f();
          } catch (err) {
            errs.push(err);
          }
        })
      ]).then(() => {
        this.#pendingWrites?.clear();
        if (errs.length === 1) {
          throw new Error("Failed to flush", { cause: errs[0] });
        } else if (errs.length) {
          throw new AggregateError(
            errs,
            `Failed to flush with ${errs.length} errors`
          );
        }
      });
    }
    return;
  }
  async [DisposableSymbols.asyncDispose]() {
    return this.flush();
  }
  child(prefixOrAttrs, prefix) {
    if (typeof prefixOrAttrs === "string") {
      return new Logger({
        level: () => this.level,
        // inherits the parent level (yet can be changed on child only when using setLevel)
        prefix: (this.#prefix || "") + prefixOrAttrs,
        attrs: this.#attrs,
        writers: this.#writers
      });
    }
    return new Logger({
      level: () => this.level,
      // inherits the parent level (yet can be changed on child only when using setLevel)
      prefix: (this.#prefix || "") + (prefix || "") || void 0,
      attrs: shallowMergeAttributes(this.#attrs, prefixOrAttrs),
      writers: this.#writers
    });
  }
  log(level, maybeAttrsOrMsg, ...rest) {
    if (!shouldLog(this.#level, level)) {
      return;
    }
    let msg;
    let attrs;
    if (typeof maybeAttrsOrMsg === "string") {
      msg = maybeAttrsOrMsg;
    } else if (maybeAttrsOrMsg) {
      attrs = maybeAttrsOrMsg;
      if (typeof rest[0] === "string") {
        msg = rest.shift();
      }
    }
    if (this.#prefix) {
      msg = `${this.#prefix}${msg || ""}`.trim();
    }
    attrs = shallowMergeAttributes(parseAttrs(this.#attrs), parseAttrs(attrs));
    msg = msg && rest.length ? format$1(msg, rest, { stringify: fastSafeStringify }) : msg;
    this.write(level, attrs, msg);
    if (getEnvBool("LOG_TRACE_LOGS")) {
      console.trace("\u{1F446}");
    }
  }
  trace(...args) {
    this.log(
      "trace",
      ...args
    );
  }
  debug(...args) {
    this.log(
      "debug",
      ...args
    );
  }
  info(...args) {
    this.log(
      "info",
      ...args
    );
  }
  warn(...args) {
    this.log(
      "warn",
      ...args
    );
  }
  error(...args) {
    this.log(
      "error",
      ...args
    );
  }
}

class LegacyLogger {
  #logger;
  constructor(logger) {
    this.#logger = logger;
  }
  static from(logger) {
    return new LegacyLogger(logger);
  }
  #log(level, ...[maybeMsgOrArg, ...restArgs]) {
    if (typeof maybeMsgOrArg === "string") {
      if (restArgs.length) {
        this.#logger.log(level, restArgs, maybeMsgOrArg);
      } else {
        this.#logger.log(level, maybeMsgOrArg);
      }
    } else {
      if (restArgs.length) {
        this.#logger.log(level, [maybeMsgOrArg, ...restArgs]);
      } else {
        this.#logger.log(level, maybeMsgOrArg);
      }
    }
  }
  log(...args) {
    this.#log("info", ...args);
  }
  warn(...args) {
    this.#log("warn", ...args);
  }
  info(...args) {
    this.#log("info", ...args);
  }
  error(...args) {
    this.#log("error", ...args);
  }
  debug(...lazyArgs) {
    if (!shouldLog(this.#logger.level, "debug")) {
      return;
    }
    this.#log("debug", ...handleLazyMessage(lazyArgs));
  }
  child(name) {
    name = stringifyName(name) + // append space if object is strigified to space out the prefix
    (typeof name === "object" ? " " : "");
    if (this.#logger.prefix === name) {
      return this;
    }
    return LegacyLogger.from(this.#logger.child(name));
  }
  addPrefix(prefix) {
    prefix = stringifyName(prefix);
    if (this.#logger.prefix?.includes(prefix)) {
      return this;
    }
    return LegacyLogger.from(this.#logger.child(prefix));
  }
}
function stringifyName(name) {
  if (typeof name === "string" || typeof name === "number") {
    return `${name}`;
  }
  const names = [];
  for (const [key, value] of Object.entries(name)) {
    names.push(`${key}=${value}`);
  }
  return `${names.join(", ")}`;
}
function handleLazyMessage(lazyArgs) {
  return lazyArgs.flat(Infinity).flatMap((arg) => {
    if (typeof arg === "function") {
      return arg();
    }
    return arg;
  });
}

export { ConsoleLogWriter, JSONLogWriter, LegacyLogger, Logger, MemoryLogWriter, jsonStringify };
