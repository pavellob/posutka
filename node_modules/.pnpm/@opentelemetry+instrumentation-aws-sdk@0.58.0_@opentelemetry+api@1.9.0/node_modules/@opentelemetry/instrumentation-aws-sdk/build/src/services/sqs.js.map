{"version":3,"file":"sqs.js","sourceRoot":"","sources":["../../../src/services/sqs.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  Tracer,\n  SpanKind,\n  Span,\n  propagation,\n  trace,\n  ROOT_CONTEXT,\n  Attributes,\n} from '@opentelemetry/api';\nimport { RequestMetadata, ServiceExtension } from './ServiceExtension';\nimport type { SQS } from '../aws-sdk.types';\nimport {\n  AwsSdkInstrumentationConfig,\n  NormalizedRequest,\n  NormalizedResponse,\n} from '../types';\nimport {\n  ATTR_URL_FULL,\n  SEMATTRS_MESSAGING_SYSTEM,\n} from '@opentelemetry/semantic-conventions';\nimport {\n  ATTR_MESSAGING_BATCH_MESSAGE_COUNT,\n  ATTR_MESSAGING_DESTINATION_NAME,\n  ATTR_MESSAGING_MESSAGE_ID,\n  ATTR_MESSAGING_OPERATION_TYPE,\n} from '../semconv';\nimport {\n  contextGetter,\n  extractPropagationContext,\n  injectPropagationContext,\n  addPropagationFieldsToAttributeNames,\n} from './MessageAttributes';\n\nexport class SqsServiceExtension implements ServiceExtension {\n  requestPreSpanHook(\n    request: NormalizedRequest,\n    _config: AwsSdkInstrumentationConfig\n  ): RequestMetadata {\n    const queueUrl = this.extractQueueUrl(request.commandInput);\n    const queueName = this.extractQueueNameFromUrl(queueUrl);\n    let spanKind: SpanKind = SpanKind.CLIENT;\n    let spanName: string | undefined;\n\n    const spanAttributes: Attributes = {\n      [SEMATTRS_MESSAGING_SYSTEM]: 'aws_sqs',\n      [ATTR_MESSAGING_DESTINATION_NAME]: queueName,\n      [ATTR_URL_FULL]: queueUrl,\n    };\n\n    let isIncoming = false;\n\n    switch (request.commandName) {\n      case 'ReceiveMessage':\n        {\n          isIncoming = true;\n          spanKind = SpanKind.CONSUMER;\n          spanName = `${queueName} receive`;\n          spanAttributes[ATTR_MESSAGING_OPERATION_TYPE] = 'receive';\n\n          request.commandInput.MessageAttributeNames =\n            addPropagationFieldsToAttributeNames(\n              request.commandInput.MessageAttributeNames,\n              propagation.fields()\n            );\n        }\n        break;\n\n      case 'SendMessage':\n      case 'SendMessageBatch':\n        spanKind = SpanKind.PRODUCER;\n        spanName = `${queueName} send`;\n        break;\n    }\n\n    return {\n      isIncoming,\n      spanAttributes,\n      spanKind,\n      spanName,\n    };\n  }\n\n  requestPostSpanHook = (request: NormalizedRequest) => {\n    switch (request.commandName) {\n      case 'SendMessage':\n        {\n          const origMessageAttributes =\n            request.commandInput['MessageAttributes'] ?? {};\n          if (origMessageAttributes) {\n            request.commandInput['MessageAttributes'] =\n              injectPropagationContext(origMessageAttributes);\n          }\n        }\n        break;\n\n      case 'SendMessageBatch':\n        {\n          const entries = request.commandInput?.Entries;\n          if (Array.isArray(entries)) {\n            entries.forEach(\n              (messageParams: {\n                MessageAttributes: SQS.MessageBodyAttributeMap;\n              }) => {\n                messageParams.MessageAttributes = injectPropagationContext(\n                  messageParams.MessageAttributes ?? {}\n                );\n              }\n            );\n          }\n        }\n        break;\n    }\n  };\n\n  responseHook = (\n    response: NormalizedResponse,\n    span: Span,\n    _tracer: Tracer,\n    config: AwsSdkInstrumentationConfig\n  ) => {\n    switch (response.request.commandName) {\n      case 'SendMessage':\n        span.setAttribute(ATTR_MESSAGING_MESSAGE_ID, response?.data?.MessageId);\n        break;\n\n      case 'SendMessageBatch':\n        // TODO: How should this be handled?\n        break;\n\n      case 'ReceiveMessage': {\n        const messages: SQS.Message[] = response?.data?.Messages || [];\n\n        span.setAttribute(ATTR_MESSAGING_BATCH_MESSAGE_COUNT, messages.length);\n\n        for (const message of messages) {\n          const propagatedContext = propagation.extract(\n            ROOT_CONTEXT,\n            extractPropagationContext(\n              message,\n              config.sqsExtractContextPropagationFromPayload\n            ),\n            contextGetter\n          );\n\n          const spanContext = trace.getSpanContext(propagatedContext);\n\n          if (spanContext) {\n            span.addLink({\n              context: spanContext,\n              attributes: {\n                [ATTR_MESSAGING_MESSAGE_ID]: message.MessageId,\n              },\n            });\n          }\n        }\n        break;\n      }\n    }\n  };\n\n  extractQueueUrl = (commandInput: Record<string, any>): string => {\n    return commandInput?.QueueUrl;\n  };\n\n  extractQueueNameFromUrl = (queueUrl: string): string | undefined => {\n    if (!queueUrl) return undefined;\n\n    const segments = queueUrl.split('/');\n    if (segments.length === 0) return undefined;\n\n    return segments[segments.length - 1];\n  };\n}\n"]}