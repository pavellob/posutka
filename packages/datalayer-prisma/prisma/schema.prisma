datasource db {
  provider = "postgresql"
  url = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-arm64-openssl-3.0.x", "linux-musl-openssl-3.0.x"]
}

model Organization {
  id          String       @id @default(cuid())
  name        String
  timezone    String
  currency    String
  properties  Property[]
  memberships Membership[]
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
}

model Property {
  id        String   @id @default(cuid())
  orgId     String
  title     String
  address   String
  amenities String[]

  // Яндекс.Недвижимость поля
  propertyType String? // "жилая" / "коммерческая"
  category     String? // "квартира" / "комната" / "дом" / "гараж"
  dealStatus   String? // "первичная продажа" / "вторичка" / "аренда"

  // Локация
  country      String?
  region       String?
  district     String?
  localityName String?
  apartment    String?

  // Метро
  metroName            String?
  metroTimeOnFoot      Int?
  metroTimeOnTransport Int?

  // Координаты
  latitude  Float?
  longitude Float?

  // Площадь и характеристики
  totalArea    Float?
  livingArea   Float?
  kitchenArea  Float?
  rooms        Int?
  roomsOffered Int?
  floor        Int?
  floorsTotal  Int?

  // Тип здания
  buildingType   String? // "кирпичный" / "панельный" / "монолитный"
  buildingYear   Int?
  buildingSeries String?

  // Удобства здания
  elevator   Boolean? @default(false)
  parking    Boolean? @default(false)
  security   Boolean? @default(false)
  concierge  Boolean? @default(false)
  playground Boolean? @default(false)
  gym        Boolean? @default(false)

  // Удобства квартиры
  balcony         Boolean? @default(false)
  loggia          Boolean? @default(false)
  airConditioning Boolean? @default(false)
  internet        Boolean? @default(false)
  washingMachine  Boolean? @default(false)
  dishwasher      Boolean? @default(false)
  tv              Boolean? @default(false)

  // Состояние
  renovation String? // "без отделки" / "требует ремонта" / "хорошее" / "отличное"
  furniture  Boolean? @default(false)

  // Элитная недвижимость
  isElite Boolean? @default(false)

  // Внешние ID
  yandexBuildingId String?
  yandexHouseId    String?

  org       Organization @relation(fields: [orgId], references: [id])
  units     Unit[]
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
}

model Unit {
  id                String               @id @default(cuid())
  propertyId        String
  name              String
  capacity          Int
  beds              Int
  bathrooms         Int
  amenities         String[]
  property          Property             @relation(fields: [propertyId], references: [id])
  preferredCleaners UnitPreferredCleaner[] // Привязанные уборщики для этой квартиры
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt
}

// Связь Unit ↔ Cleaner (many-to-many)
model UnitPreferredCleaner {
  id        String   @id @default(cuid())
  unitId    String
  cleanerId String
  unit      Unit     @relation(fields: [unitId], references: [id], onDelete: Cascade)
  cleaner   Cleaner  @relation(fields: [cleanerId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([unitId, cleanerId])
  @@index([unitId])
  @@index([cleanerId])
}

model CalendarBlock {
  id        String   @id @default(cuid())
  unitId    String
  from      DateTime
  to        DateTime
  note      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Guest {
  id             String    @id @default(cuid())
  name           String
  email          String
  phone          String?
  documentType   String?
  documentNumber String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  bookings       Booking[]
}

model Booking {
  id                  String               @id @default(cuid())
  orgId               String
  unitId              String
  guestId             String
  status              BookingStatus        @default(PENDING)
  source              BookingSource        @default(DIRECT)
  checkIn             DateTime
  checkOut            DateTime
  guestsCount         Int
  basePriceAmount     Int
  basePriceCurrency   String
  cleaningFeeAmount   Int?
  cleaningFeeCurrency String?
  serviceFeeAmount    Int?
  serviceFeeCurrency  String?
  taxesAmount         Int?
  taxesCurrency       String?
  totalAmount         Int
  totalCurrency       String
  notes               String?
  cancellationReason  String?
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  guest               Guest                @relation(fields: [guestId], references: [id])
  documents           Document[]
  depositTransactions DepositTransaction[]
}

model Document {
  id        String    @id @default(cuid())
  bookingId String
  type      String
  template  String
  content   String
  signedAt  DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  booking   Booking   @relation(fields: [bookingId], references: [id])
}

model DepositTransaction {
  id            String            @id @default(cuid())
  bookingId     String
  action        DepositAction
  amount        Int
  currency      String
  status        TransactionStatus @default(PENDING)
  transactionId String?
  notes         String?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  booking       Booking           @relation(fields: [bookingId], references: [id])
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
  NO_SHOW
}

enum BookingSource {
  DIRECT
  AIRBNB
  BOOKING_COM
  AVITO
  OTHER
}

enum DepositAction {
  HOLD
  RELEASE
  CHARGE
  REFUND
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
}

model ServiceProvider {
  id            String         @id @default(cuid())
  name          String
  serviceTypes  String[]
  rating        Float?
  contact       String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  tasks         Task[]
  serviceOrders ServiceOrder[]
}

model Task {
  id                 String           @id @default(cuid())
  orgId              String
  unitId             String?
  bookingId          String?
  type               TaskType
  status             TaskStatus       @default(TODO)
  dueAt              DateTime?
  assignedProviderId String?
  assignedCleanerId  String? // Для задач типа CLEANING
  checklist          String[]
  note               String?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  assignedProvider   ServiceProvider? @relation(fields: [assignedProviderId], references: [id])
  assignedCleaner    Cleaner?         @relation(fields: [assignedCleanerId], references: [id])
  serviceOrders      ServiceOrder[]

  @@index([assignedCleanerId])
}

model ServiceOrder {
  id           String             @id @default(cuid())
  orgId        String
  taskId       String
  providerId   String?
  status       ServiceOrderStatus @default(CREATED)
  costAmount   Int?
  costCurrency String?
  invoiceId    String?
  notes        String?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  task         Task               @relation(fields: [taskId], references: [id])
  provider     ServiceProvider?   @relation(fields: [providerId], references: [id])
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  DONE
  CANCELED
}

enum TaskType {
  CLEANING
  CHECKIN
  CHECKOUT
  MAINTENANCE
  INVENTORY
}

enum ServiceOrderStatus {
  CREATED
  ACCEPTED
  DONE
  CANCELED
}

model Invoice {
  id            String        @id @default(cuid())
  orgId         String
  orderId       String?
  totalAmount   Int
  totalCurrency String
  status        InvoiceStatus @default(OPEN)
  issuedAt      DateTime
  dueAt         DateTime?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  items         InvoiceItem[]
  payments      Payment[]
}

model InvoiceItem {
  id            String   @id @default(cuid())
  invoiceId     String
  name          String
  qty           Int
  priceAmount   Int
  priceCurrency String
  sumAmount     Int
  sumCurrency   String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  invoice       Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
}

model Payment {
  id             String        @id @default(cuid())
  invoiceId      String
  method         PaymentMethod
  amountAmount   Int
  amountCurrency String
  status         PaymentStatus @default(PENDING)
  provider       String?
  providerRef    String?
  receiptUrl     String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  invoice        Invoice       @relation(fields: [invoiceId], references: [id])
}

enum InvoiceStatus {
  OPEN
  PAID
  CANCELED
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  CANCELED
}

enum PaymentMethod {
  CARD
  CASH
  TRANSFER
  OTHER
}

model User {
  id                     String                      @id @default(cuid())
  email                  String                      @unique
  name                   String?
  phoneNumber            String?
  emailVerified          Boolean                     @default(false)
  password               String?                     @default("")
  systemRoles            String[]                    @default(["USER"])
  status                 String                      @default("ACTIVE")
  isLocked               Boolean                     @default(false)
  lastLoginAt            DateTime?
  createdAt              DateTime                    @default(now())
  updatedAt              DateTime                    @updatedAt
  memberships            Membership[]
  refreshTokens          RefreshToken[]
  notificationSettings   UserNotificationSettings?
}

model Membership {
  id        String       @id @default(cuid())
  userId    String
  orgId     String
  role      Role
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  user      User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  org       Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([userId, orgId])
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum Role {
  OWNER
  MANAGER
  STAFF
}

model Listing {
  id                String         @id @default(cuid())
  unitId            String
  status            ListingStatus  @default(DRAFT)
  channel           Channel
  basePriceAmount   Int
  basePriceCurrency String
  minNights         Int
  maxNights         Int?
  externalId        String?
  lastSyncAt        DateTime?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  discounts         DiscountRule[]
}

model DiscountRule {
  id         String   @id @default(cuid())
  listingId  String
  name       String
  percentOff Int
  minNights  Int?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  listing    Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
}

enum ListingStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum Channel {
  DIRECT
  AIRBNB
  BOOKING_COM
  AVITO
}

model LegalDocument {
  id        String   @id @default(cuid())
  type      String
  url       String
  bookingId String?
  meta      Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model LegalDepositTransaction {
  id               String   @id @default(cuid())
  bookingId        String
  holdAmount       Int
  holdCurrency     String
  capturedAmount   Int?
  capturedCurrency String?
  refundedAmount   Int?
  refundedCurrency String?
  method           String
  status           String
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

// ===== Cleaning Models =====

model Cleaner {
  id                String                 @id @default(cuid())
  type              CleanerType            @default(EXTERNAL)
  userId            String? // Для сотрудников (internal)
  orgId             String
  firstName         String
  lastName          String
  phone             String?
  email             String?
  telegramUsername  String? // Username в Telegram (без @) для автопривязки
  rating            Float?                 @default(0)
  isActive          Boolean                @default(true)
  deletedAt         DateTime? // Soft delete - дата деактивации
  createdAt         DateTime               @default(now())
  updatedAt         DateTime               @updatedAt
  cleanings         Cleaning[]
  tasks             Task[] // Задачи, назначенные на уборщика
  preferredUnits    UnitPreferredCleaner[] // Квартиры, где этот уборщик предпочтителен

  @@index([orgId])
  @@index([userId])
  @@index([type])
  @@index([isActive])
  @@index([deletedAt])
  @@index([telegramUsername])
}

enum CleanerType {
  INTERNAL // Сотрудник компании (User)
  EXTERNAL // Внешний подрядчик
}

model CleaningTemplate {
  id                  String                     @id @default(cuid())
  unitId              String
  name                String
  description         String?
  requiresLinenChange Boolean                    @default(false)
  estimatedDuration   Int? // minutes
  createdAt           DateTime                   @default(now())
  updatedAt           DateTime                   @updatedAt
  checklistItems      CleaningTemplateCheckbox[]

  @@index([unitId])
}

model CleaningTemplateCheckbox {
  id         String           @id @default(cuid())
  templateId String
  label      String
  order      Int              @default(0)
  isRequired Boolean          @default(false)
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  template   CleaningTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  @@index([templateId])
}

model Cleaning {
  id                  String              @id @default(cuid())
  orgId               String
  cleanerId           String? // Теперь опциональный - может быть не назначен
  unitId              String
  bookingId           String?
  taskId              String? // Связь с Task из ops-subgraph
  status              CleaningStatus      @default(SCHEDULED)
  scheduledAt         DateTime
  startedAt           DateTime?
  completedAt         DateTime?
  notes               String?
  requiresLinenChange Boolean             @default(false)
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  cleaner             Cleaner?            @relation(fields: [cleanerId], references: [id])
  documents           CleaningDocument[]
  checklistItems      CleaningChecklist[]

  @@index([orgId])
  @@index([cleanerId])
  @@index([unitId])
  @@index([bookingId])
  @@index([taskId])
  @@index([scheduledAt])
}

model CleaningChecklist {
  id         String   @id @default(cuid())
  cleaningId String
  label      String
  isChecked  Boolean  @default(false)
  order      Int      @default(0)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  cleaning   Cleaning @relation(fields: [cleaningId], references: [id], onDelete: Cascade)

  @@index([cleaningId])
}

model CleaningDocument {
  id         String                  @id @default(cuid())
  cleaningId String
  type       CleaningDocumentType
  notes      String?
  createdAt  DateTime                @default(now())
  updatedAt  DateTime                @updatedAt
  cleaning   Cleaning                @relation(fields: [cleaningId], references: [id], onDelete: Cascade)
  photos     CleaningDocumentPhoto[]

  @@index([cleaningId])
}

model CleaningDocumentPhoto {
  id         String           @id @default(cuid())
  documentId String
  url        String
  caption    String?
  order      Int              @default(0)
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  document   CleaningDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
}

enum CleaningStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum CleaningDocumentType {
  PRE_CLEANING_ACCEPTANCE
  POST_CLEANING_HANDOVER
}

// ===== Notification Models =====

model Notification {
  id               String                 @id @default(cuid())
  eventId          String?                // Ссылка на Event (NEW!)
  orgId            String?
  userId           String?                // Основной получатель (User ID)
  eventType        String
  priority         NotificationPriority   @default(NORMAL)
  status           NotificationStatus     @default(PENDING)
  title            String
  message          String
  metadata         String?
  actionUrl        String?
  actionText       String?
  scheduledAt      DateTime?
  sentAt           DateTime?
  deliveredAt      DateTime?
  readAt           DateTime?
  error            String?
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt
  deliveryStatuses NotificationDelivery[]
  eventLinks       EventNotification[]    // Связь с Events (NEW! many-to-many)

  @@index([eventId])
  @@index([orgId])
  @@index([userId])
  @@index([status])
  @@index([eventType])
  @@index([createdAt])
}

model NotificationDelivery {
  id             String                @id @default(cuid())
  notificationId String
  channel        NotificationChannel   // TELEGRAM | WEBSOCKET | EMAIL | SMS
  recipientType  RecipientType         // USER_ID | TELEGRAM_CHAT_ID | EMAIL | PHONE
  recipientId    String                // Идентификатор получателя для конкретного канала
  status         DeliveryStatus        @default(PENDING)
  externalId     String?               // ID в системе провайдера (message_id в Telegram)
  deliveredAt    DateTime?
  error          String?
  createdAt      DateTime              @default(now())
  updatedAt      DateTime              @updatedAt
  notification   Notification          @relation(fields: [notificationId], references: [id], onDelete: Cascade)

  @@index([notificationId])
  @@index([channel])
  @@index([recipientId])
  @@index([status])
}

enum NotificationChannel {
  TELEGRAM
  WEBSOCKET
  EMAIL
  SMS
  PUSH
  IN_APP
}

enum RecipientType {
  USER_ID
  TELEGRAM_CHAT_ID
  EMAIL
  PHONE
}

enum DeliveryStatus {
  PENDING
  SENDING
  SENT
  DELIVERED
  FAILED
  BOUNCED
}

model UserNotificationSettings {
  userId           String   @id
  telegramChatId   String?
  email            String?
  phone            String?
  enabled          Boolean  @default(true)
  enabledChannels  String[]
  subscribedEvents String[]
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([telegramChatId])
}

model NotificationTemplate {
  id              String               @id @default(cuid())
  eventType       String
  name            String
  titleTemplate   String
  messageTemplate String
  defaultChannels String[]
  defaultPriority NotificationPriority @default(NORMAL)
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt

  @@unique([eventType, name])
  @@index([eventType])
}

enum NotificationStatus {
  PENDING
  SCHEDULED
  SENT
  FAILED
  DELIVERED
  READ
  CANCELLED
}

enum NotificationPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

// ============================================
// EVENT BUS MODELS
// ============================================

model Event {
  id             String       @id @default(cuid())
  type           EventType
  sourceSubgraph String       // cleaning-subgraph, bookings-subgraph...
  entityType     String       // Cleaning, Booking, Task...
  entityId       String       // ID сущности
  orgId          String?      // Контекст организации
  
  // Участники события
  actorUserId    String?      // Кто инициировал
  targetUserIds  String[]     // Кто затронут (массив)
  
  // Данные события
  payload        Json         // Полные данные события
  metadata       Json?        // Дополнительные метаданные
  
  status         EventStatus  @default(PENDING)
  processedAt    DateTime?
  createdAt      DateTime     @default(now())
  
  // Связи
  notifications  EventNotification[]
  
  @@index([type])
  @@index([entityType, entityId])
  @@index([orgId])
  @@index([status])
  @@index([createdAt])
}

model EventSubscription {
  id          String      @id @default(cuid())
  handlerType HandlerType // NOTIFICATION, ANALYTICS, AUDIT, WEBHOOK...
  eventTypes  String[]    // [CLEANING_SCHEDULED, BOOKING_CREATED...]
  targetUrl   String?     // Для WEBHOOK
  isActive    Boolean     @default(true)
  config      Json?       // Дополнительная конфигурация
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  @@index([handlerType])
  @@index([isActive])
}

model EventNotification {
  id             String   @id @default(cuid())
  eventId        String
  notificationId String
  createdAt      DateTime @default(now())
  
  event        Event        @relation(fields: [eventId], references: [id], onDelete: Cascade)
  notification Notification @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  
  @@unique([eventId, notificationId])
  @@index([eventId])
  @@index([notificationId])
}

enum EventType {
  // Cleaning
  CLEANING_SCHEDULED
  CLEANING_ASSIGNED
  CLEANING_STARTED
  CLEANING_COMPLETED
  CLEANING_CANCELLED
  
  // Booking
  BOOKING_CREATED
  BOOKING_CONFIRMED
  BOOKING_CANCELLED
  BOOKING_CHECKIN
  BOOKING_CHECKOUT
  
  // Task
  TASK_CREATED
  TASK_ASSIGNED
  TASK_STATUS_CHANGED
  TASK_COMPLETED
  
  // User
  USER_CREATED
  USER_UPDATED
  USER_LOCKED
  USER_UNLOCKED
  
  // Organization
  ORG_CREATED
  ORG_UPDATED
  MEMBER_ADDED
  MEMBER_REMOVED
}

enum EventStatus {
  PENDING
  PROCESSING
  PROCESSED
  FAILED
  CANCELLED
}

enum HandlerType {
  NOTIFICATION
  ANALYTICS
  AUDIT
  WEBHOOK
  CUSTOM
}
